diff --git a/ayanavita-fontend/src/api/adminCourses.api.ts b/ayanavita-fontend/src/api/adminCourses.api.ts
index 7f4ee7b295265e7a35433c9a98e2591a76d71bea..656341f67a0d3bed109059c2fac5cbe7450fc5d4 100644
--- a/ayanavita-fontend/src/api/adminCourses.api.ts
+++ b/ayanavita-fontend/src/api/adminCourses.api.ts
@@ -1,166 +1,157 @@
 import { del, get, patch, post } from './http'

 export type CourseTopicTranslations = Record<string, { name?: string; description?: string | null }>

 export type CourseTopic = {
   id: number
   name: string
   description?: string | null
   translations?: CourseTopicTranslations
   _count?: { courses: number }
 }

-export type LocalizedText = { vi?: string; en?: string; 'en-US'?: string; de?: string }
+export type LocalizedText = { vi?: string; en?: string; de?: string }

 export type LessonVideoPayload = {
   title: string
   description?: string
-  titleI18n?: LocalizedText
-  descriptionI18n?: LocalizedText
+  translations?: Record<string, { title: string; shortDescription?: string; description?: string }>
   sourceUrl?: string
   durationSec?: number
   order?: number
   published?: boolean
 }

 export type LessonModulePayload = {
   title: string
   description?: string
-  titleI18n?: LocalizedText
-  descriptionI18n?: LocalizedText
+  translations?: Record<string, { title: string; shortDescription?: string; description?: string }>
   order?: number
   published?: boolean
   videos?: LessonVideoPayload[]
 }

 export type LessonPayload = {
   title: string
   slug: string
   description?: string
-  titleI18n?: LocalizedText
-  descriptionI18n?: LocalizedText
+  translations?: Record<string, { title: string; description?: string }>
   content?: string
   videoUrl?: string
   modules?: LessonModulePayload[]
   order?: number
   published?: boolean
 }

 export type LessonVideoAdmin = LessonVideoPayload & { id: number; hlsPlaylistKey?: string }
 export type LessonModuleAdmin = LessonModulePayload & { id: number; videos: LessonVideoAdmin[] }

 export type LessonAdmin = {
   id: number
   courseId: number
   title: string
   slug: string
   description?: string
-  titleI18n?: LocalizedText
-  descriptionI18n?: LocalizedText
+  translations?: Record<string, { title: string; description?: string }>
   content?: string
   order?: number
   published: boolean
   createdAt?: string
   updatedAt?: string
 }

 export type LessonDetailAdmin = LessonAdmin & { modules: LessonModuleAdmin[] }

 export type CourseAdmin = {
   id: number
   topicId?: number | null
   title: string
   shortDescription?: string | null
   slug: string
   description?: string | null
   thumbnail?: string | null
   published: boolean
   price: number
   topic?: { id: number; name: string } | null
-  titleI18n?: LocalizedText
-  descriptionI18n?: LocalizedText
-  shortDescriptionI18n?: LocalizedText
+  translations?: Record<string, { title: string; description?: string }>
   objectives?: string[]
   targetAudience?: string[]
   benefits?: string[]
+  contentTranslations?: Record<string, { objectives?: string[]; targetAudience?: string[]; benefits?: string[] }>
   ratingAvg?: number
   ratingCount?: number
   enrollmentCount?: number
   createdAt?: string
   updatedAt?: string
   videoCount?: number
   _count?: { lessons?: number }
 }

 export type TopicPayload = {
   name?: string
   description?: string
   translations?: {
     vi?: { name?: string; description?: string }
     'en-US'?: { name?: string; description?: string }
     de?: { name?: string; description?: string }
   }
 }

 export type CoursePayload = {
   topicId?: number
   title: string
   shortDescription?: string
   slug: string
   description?: string
   thumbnail?: string
   price?: number
   published?: boolean
-  titleI18n?: LocalizedText
-  descriptionI18n?: LocalizedText
-  shortDescriptionI18n?: LocalizedText
+  translations?: Record<string, { title: string; description?: string }>
   objectives?: string[]
   targetAudience?: string[]
   benefits?: string[]
+  contentTranslations?: Record<string, { objectives?: string[]; targetAudience?: string[]; benefits?: string[] }>
   ratingAvg?: number
   ratingCount?: number
   enrollmentCount?: number
 }

 export type CourseListResponse = {
   items: CourseAdmin[]
   total: number
   page: number
   pageSize: number
 }

 export const adminCoursesApi = {
   listTopics: () => get<CourseTopic[]>('/admin/course-topics', { auth: true }),
   createTopic: (body: TopicPayload) => post<CourseTopic>('/admin/course-topics', body, { auth: true }),
   updateTopic: (id: number, body: TopicPayload) => patch<CourseTopic>(`/admin/course-topics/${id}`, body, { auth: true }),
   deleteTopic: (id: number) => del<{ id: number }>(`/admin/course-topics/${id}`, { auth: true }),
   listCourses: (params?: { topicId?: number; search?: string; page?: number; pageSize?: number; lang?: string }) => {
     const qs = new URLSearchParams()
     if (params?.topicId) qs.set('topicId', String(params.topicId))
     if (params?.search?.trim()) qs.set('search', params.search.trim())
     if (params?.page) qs.set('page', String(params.page))
     if (params?.pageSize) qs.set('pageSize', String(params.pageSize))
     if (params?.lang) qs.set('lang', params.lang)
     const suffix = qs.toString() ? `?${qs.toString()}` : ''
     return get<CourseListResponse>(`/courses${suffix}`, { auth: true })
   },
   createCourse: (body: CoursePayload) => post<CourseAdmin>('/courses', body, { auth: true }),
   updateCourse: (id: number, body: Partial<CoursePayload>) => patch<CourseAdmin>(`/courses/${id}`, body, { auth: true }),
   deleteCourse: (id: number) => del<{ id: number }>(`/courses/${id}`, { auth: true }),

   listCourseLessons: (courseId: number) => get<LessonAdmin[]>(`/courses/${courseId}/lessons-outline`, { auth: true }),
   getLessonDetail: (lessonId: number) => get<LessonDetailAdmin>(`/lessons/${lessonId}`, { auth: true }),
   createLesson: (courseId: number, body: LessonPayload) => post<LessonAdmin>(`/courses/${courseId}/lessons`, body, { auth: true }),
   updateLesson: (lessonId: number, body: Partial<LessonPayload>) => patch<LessonAdmin>(`/lessons/${lessonId}`, body, { auth: true }),
   deleteLesson: (lessonId: number) => del<{ id: number }>(`/lessons/${lessonId}`, { auth: true }),

-  uploadModuleVideo: (lessonId: number, moduleId: string | number, file: File) => {
+  uploadModuleMedia: (lessonId: number, moduleId: string | number, file: File, type: 'video' | 'image') => {
     const body = new FormData()
     body.append('file', file)
-    return post<{ moduleId: string; lessonId: number; hlsPlaylistKey: string; segmentCount: number; storage: string }>(
-      `/lessons/${lessonId}/modules/${moduleId}/videos/upload`,
-      body,
-      { auth: true },
-    )
+    body.append('type', type)
+    return post<{ moduleId?: string; lessonId?: number; hlsPlaylistKey?: string; segmentCount?: number; imageKey?: string; sourceUrl?: string; storage: string }>(`/lessons/${lessonId}/modules/${moduleId}/media/upload`, body, { auth: true })
   },
 }
diff --git a/ayanavita-fontend/src/pages/admin/courseTabs/CreateCourseModal.tsx b/ayanavita-fontend/src/pages/admin/courseTabs/CreateCourseModal.tsx
index 0ac655cbb4322a072cc504a3dda55127fba6096e..840936ee11fb2e0eb6728a35425989e4b9ef2e4f 100644
--- a/ayanavita-fontend/src/pages/admin/courseTabs/CreateCourseModal.tsx
+++ b/ayanavita-fontend/src/pages/admin/courseTabs/CreateCourseModal.tsx
@@ -1,27 +1,28 @@
 import { useMemo, useState } from 'react'
 import { autoTranslateFromVietnamese } from '../tabs/i18nForm'
+import { adminCoursesApi } from '../../../api/adminCourses.api'
 import './CreateCourseModal.css'

 type AdminLang = 'vi' | 'en' | 'de'
 type MediaType = 'video' | 'image'

 type TopicItem = { id: number; name: string; translations?: { vi?: { name?: string }; en?: { name?: string }; de?: { name?: string } } }

 type Props = {
   open: boolean
   lang: AdminLang
   topics: TopicItem[]
   onClose: () => void
 }

 type I18nText = Record<AdminLang, string>
 type I18nStringArray = Record<AdminLang, string[]>

 type MediaForm = { type: MediaType; file?: File | null; orderIndex: number }
 type ModuleForm = { title: I18nText; description: I18nText; orderIndex: number; medias: MediaForm[] }
 type LessonForm = { title: I18nText; description: I18nText; orderIndex: number; modules: ModuleForm[] }

 type CourseForm = {
   title: I18nText
   shortDescription: I18nText
   description: I18nText
@@ -139,50 +140,51 @@ const textMap: Record<AdminLang, Record<string, string>> = {
     medias: 'IV. Medien',
     topic: 'Thema *',
     titleLabel: 'Titel *',
     shortDescription: 'Kurzbeschreibung',
     description: 'Beschreibung',
     thumbnailUpload: 'Thumbnail (Bild hochladen)',
     price: 'Preis',
     published: 'Veröffentlicht',
     addLesson: 'Lektion hinzufügen',
     addModule: 'Modul hinzufügen',
     addMedia: 'Medien hinzufügen',
     addItem: 'Zeile hinzufügen',
     remove: 'Löschen',
     objective: 'Ziele',
     audience: 'Zielgruppe',
     benefits: 'Vorteile',
     mediaType: 'Medientyp',
     upload: 'Datei hochladen',
     orderIndex: 'Reihenfolge',
   },
 }

 export function CreateCourseModal({ open, lang, topics, onClose }: Props) {
   const [form, setForm] = useState<CourseForm>(() => initialForm())
   const [inputLang, setInputLang] = useState<AdminLang>('vi')
+  const [submitting, setSubmitting] = useState(false)
   const t = textMap[lang]

   const displayTopicName = (topic: TopicItem) => {
     if (lang === 'en') return topic.translations?.en?.name || topic.name
     if (lang === 'de') return topic.translations?.de?.name || topic.name
     return topic.translations?.vi?.name || topic.name
   }

   const slug = useMemo(() => slugify(form.title.vi || ''), [form.title.vi])

   const translateVietnameseToOthers = async (value: string, updater: (en: string, de: string) => void) => {
     const [en, de] = await Promise.all([autoTranslateFromVietnamese(value, 'en-US'), autoTranslateFromVietnamese(value, 'de')])
     updater(en, de)
   }

   const updateI18nField = (field: 'title' | 'shortDescription' | 'description', value: string) => {
     setForm((prev) => ({ ...prev, [field]: { ...prev[field], [inputLang]: value } }))
     if (inputLang !== 'vi') return
     void translateVietnameseToOthers(value, (en, de) => setForm((prev) => ({ ...prev, [field]: { ...prev[field], en, de } })))
   }

   const updateI18nListItem = (field: 'objectives' | 'targetAudience' | 'benefits', index: number, value: string) => {
     setForm((prev) => {
       const localList = [...prev[field][inputLang]]
       localList[index] = value
@@ -266,93 +268,116 @@ export function CreateCourseModal({ open, lang, topics, onClose }: Props) {

   const toLanguageVersion = (locale: AdminLang) => ({
     title: form.title[locale],
     shortDescription: form.shortDescription[locale],
     description: form.description[locale],
     objectives: form.objectives[locale].filter((v) => v.trim()),
     targetAudience: form.targetAudience[locale].filter((v) => v.trim()),
     benefits: form.benefits[locale].filter((v) => v.trim()),
     lessons: form.lessons.map((lesson) => ({
       title: lesson.title[locale],
       description: lesson.description[locale],
       orderIndex: lesson.orderIndex,
       modules: lesson.modules.map((module) => ({
         title: module.title[locale],
         description: module.description[locale],
         orderIndex: module.orderIndex,
         medias: module.medias.map((media) => ({
           type: media.type,
           uploadFileName: media.file?.name,
           orderIndex: media.orderIndex,
         })),
       })),
     })),
   })

-  const submit = () => {
+  const submit = async () => {
     if (!validate()) {
       if (Number.isFinite(getPrice()) && getPrice() >= 0) window.alert(t.required)
       return
     }

-    const now = new Date().toISOString()
-    const payload = {
-      title: form.title,
-      shortDescription: form.shortDescription,
-      description: form.description,
-      thumbnail: { uploadFileName: form.thumbnailFile?.name },
-      price: getPrice(),
-      published: form.published,
-      topicId: form.topicId,
-      objectives: form.objectives,
-      targetAudience: form.targetAudience,
-      benefits: form.benefits,
-      slug,
-      createdAt: now,
-      updatedAt: now,
-      lessons: form.lessons.map((lesson) => ({
-        title: lesson.title,
-        description: lesson.description,
-        orderIndex: lesson.orderIndex,
-        modules: lesson.modules.map((module) => ({
-          title: module.title,
-          description: module.description,
-          orderIndex: module.orderIndex,
-          medias: module.medias.map((media) => ({ type: media.type, uploadFileName: media.file?.name, orderIndex: media.orderIndex })),
-        })),
-      })),
-      languageVersions: {
-        vi: toLanguageVersion('vi'),
-        en: toLanguageVersion('en'),
-        de: toLanguageVersion('de'),
-      },
-    }
+    setSubmitting(true)
+    try {
+      const course = await adminCoursesApi.createCourse({
+        title: form.title.vi,
+        shortDescription: form.shortDescription.vi,
+        description: form.description.vi,
+        price: getPrice(),
+        published: form.published,
+        topicId: form.topicId,
+        objectives: form.objectives.vi.filter((v) => v.trim()),
+        targetAudience: form.targetAudience.vi.filter((v) => v.trim()),
+        benefits: form.benefits.vi.filter((v) => v.trim()),
+        slug,
+        translations: {
+          vi: { title: form.title.vi, shortDescription: form.shortDescription.vi, description: form.description.vi },
+          en: { title: form.title.en, shortDescription: form.shortDescription.en, description: form.description.en },
+          de: { title: form.title.de, shortDescription: form.shortDescription.de, description: form.description.de },
+        },
+        contentTranslations: {
+          vi: { objectives: form.objectives.vi.filter((v) => v.trim()), targetAudience: form.targetAudience.vi.filter((v) => v.trim()), benefits: form.benefits.vi.filter((v) => v.trim()) },
+          en: { objectives: form.objectives.en.filter((v) => v.trim()), targetAudience: form.targetAudience.en.filter((v) => v.trim()), benefits: form.benefits.en.filter((v) => v.trim()) },
+          de: { objectives: form.objectives.de.filter((v) => v.trim()), targetAudience: form.targetAudience.de.filter((v) => v.trim()), benefits: form.benefits.de.filter((v) => v.trim()) },
+        },
+      })
+
+      for (const lesson of form.lessons) {
+        const createdLesson = await adminCoursesApi.createLesson(course.id, {
+          title: lesson.title.vi,
+          slug: slugify(lesson.title.vi || `lesson-${lesson.orderIndex}`),
+          description: lesson.description.vi,
+          order: lesson.orderIndex,
+          published: form.published,
+          translations: { vi: { title: lesson.title.vi, description: lesson.description.vi }, en: { title: lesson.title.en, description: lesson.description.en }, de: { title: lesson.title.de, description: lesson.description.de } },
+          modules: lesson.modules.map((module) => ({
+            title: module.title.vi,
+            description: module.description.vi,
+            order: module.orderIndex,
+            published: true,
+            translations: { vi: { title: module.title.vi, description: module.description.vi }, en: { title: module.title.en, description: module.description.en }, de: { title: module.title.de, description: module.description.de } },
+            videos: module.medias.map((media) => ({ title: media.file?.name || media.type, description: '', order: media.orderIndex, mediaType: media.type === 'image' ? 'IMAGE' : 'VIDEO', published: true })),
+          })),
+        })
+
+        const detail = await adminCoursesApi.getLessonDetail(createdLesson.id)
+        for (const module of lesson.modules) {
+          const apiModule = detail.modules.find((m) => m.order === module.orderIndex)
+          if (!apiModule) continue
+          for (const media of module.medias) {
+            if (!media.file) continue
+            await adminCoursesApi.uploadModuleMedia(createdLesson.id, apiModule.id, media.file, media.type)
+          }
+        }
+      }

-    console.log('NEW_COURSE_PAYLOAD', payload)
-    onClose()
-    setForm(initialForm())
-    setInputLang('vi')
+      onClose()
+      setForm(initialForm())
+      setInputLang('vi')
+    } finally {
+      setSubmitting(false)
+    }
   }

   if (!open) return null

   return (
     <div className='admin-modal-backdrop' role='dialog' aria-modal='true'>
       <div className='admin-modal create-course-modal'>
         <div className='admin-modal-header'>
           <h4><i className='fa-solid fa-circle-plus create-course-icon-orange' /> {t.title}</h4>
           <div className='admin-row'>
             <span className='create-course-muted'>{t.langInput}:</span>
             {(['vi', 'en', 'de'] as AdminLang[]).map((code) => (
               <button key={code} type='button' className={`admin-btn ${inputLang === code ? 'admin-btn-primary' : 'admin-btn-ghost'}`} onClick={() => setInputLang(code)}>{code.toUpperCase()}</button>
             ))}
             <button type='button' className='admin-btn admin-btn-ghost' onClick={onClose}>{t.close}</button>
           </div>
         </div>

         <section className='admin-card create-course-section'>
           <h5><i className='fa-solid fa-book create-course-icon-orange' /> {t.courseInfo}</h5>
           <div className='admin-form-grid admin-form-grid-2col'>
             <label className='admin-field'><span className='admin-label'><i className='fa-solid fa-tags create-course-icon-orange' /> {t.topic}</span><select className='admin-input' value={form.topicId || ''} onChange={(e) => setForm((prev) => ({ ...prev, topicId: Number(e.target.value) || undefined }))}><option value=''>--</option>{topics.map((topic) => <option key={topic.id} value={topic.id}>{displayTopicName(topic)}</option>)}</select></label>
             <label className='admin-field'><span className='admin-label'><i className='fa-solid fa-link create-course-icon-orange' /> Slug</span><input className='admin-input' value={slug} disabled /></label>
             <label className='admin-field'><span className='admin-label'><i className='fa-solid fa-heading create-course-icon-orange' /> {t.titleLabel}</span><input className='admin-input' value={form.title[inputLang]} onChange={(e) => updateI18nField('title', e.target.value)} /></label>
             <label className='admin-field'><span className='admin-label'><i className='fa-solid fa-note-sticky create-course-icon-orange' /> {t.shortDescription}</span><input className='admin-input' value={form.shortDescription[inputLang]} onChange={(e) => updateI18nField('shortDescription', e.target.value)} /></label>
@@ -407,31 +432,31 @@ export function CreateCourseModal({ open, lang, topics, onClose }: Props) {

                 {module.medias.map((media, mediaIdx) => (
                   <div key={`media-${mediaIdx}`} className='admin-card create-course-inner-card'>
                     <div className='admin-row create-course-title-row'>
                       <strong><i className='fa-solid fa-photo-film create-course-icon-green' /> {t.medias} #{mediaIdx + 1}</strong>
                       <button type='button' className='admin-btn admin-btn-danger' onClick={() => removeMedia(lessonIdx, moduleIdx, mediaIdx)}><i className='fa-solid fa-trash' /> {t.remove}</button>
                     </div>
                     <div className='admin-form-grid admin-form-grid-2col'>
                       <label className='admin-field'><span className='admin-label'>{t.mediaType}</span><select className='admin-input' value={media.type} onChange={(e) => updateMedia(lessonIdx, moduleIdx, mediaIdx, (old) => ({ ...old, type: e.target.value as MediaType }))}><option value='video'>video</option><option value='image'>image</option></select></label>
                       <label className='admin-field'><span className='admin-label'>{t.orderIndex}</span><input type='number' className='admin-input' value={media.orderIndex} onChange={(e) => updateMedia(lessonIdx, moduleIdx, mediaIdx, (old) => ({ ...old, orderIndex: Number(e.target.value) }))} /></label>
                       <label className='admin-field admin-field-full'><span className='admin-label'>{t.upload}</span><input type='file' accept={media.type === 'image' ? 'image/*' : 'video/*'} onChange={(e) => updateMedia(lessonIdx, moduleIdx, mediaIdx, (old) => ({ ...old, file: e.target.files?.[0] || null }))} /></label>
                     </div>
                   </div>
                 ))}

                 <button type='button' className='admin-btn create-course-btn-add' onClick={() => addMedia(lessonIdx, moduleIdx)}><i className='fa-solid fa-plus' /> {t.addMedia}</button>
               </div>
             ))}

             <button type='button' className='admin-btn create-course-btn-add' onClick={() => addModule(lessonIdx)}><i className='fa-solid fa-plus' /> {t.addModule}</button>
           </section>
         ))}

         <div className='admin-row create-course-footer'>
           <button type='button' className='admin-btn create-course-btn-add' onClick={addLesson}><i className='fa-solid fa-plus' /> {t.addLesson}</button>
-          <button type='button' className='admin-btn admin-btn-save' onClick={submit}><i className='fa-solid fa-paper-plane' /> {t.submit}</button>
+          <button type='button' className='admin-btn admin-btn-save' onClick={() => void submit()} disabled={submitting}><i className='fa-solid fa-paper-plane' /> {t.submit}</button>
         </div>
       </div>
     </div>
   )
 }
diff --git a/backend/ayanavitabackend/app/api/prisma/migrations/202603100001_course_translation_refactor/migration.sql b/backend/ayanavitabackend/app/api/prisma/migrations/202603100001_course_translation_refactor/migration.sql
new file mode 100644
index 0000000000000000000000000000000000000000..dd52cc96a51231e3004d92fec1e11a6b8575f302
--- /dev/null
+++ b/backend/ayanavitabackend/app/api/prisma/migrations/202603100001_course_translation_refactor/migration.sql
@@ -0,0 +1,86 @@
+ALTER TABLE `Course`
+  DROP COLUMN `titleI18n`,
+  DROP COLUMN `descriptionI18n`,
+  DROP COLUMN `shortDescriptionI18n`;
+
+ALTER TABLE `Lesson`
+  DROP COLUMN `titleI18n`,
+  DROP COLUMN `descriptionI18n`;
+
+ALTER TABLE `LessonModule`
+  DROP COLUMN `titleI18n`,
+  DROP COLUMN `descriptionI18n`;
+
+ALTER TABLE `LessonVideo`
+  DROP COLUMN `titleI18n`,
+  DROP COLUMN `descriptionI18n`,
+  ADD COLUMN `mediaType` ENUM('VIDEO','IMAGE') NOT NULL DEFAULT 'VIDEO';
+
+CREATE TABLE `CourseContentTranslation` (
+  `id` INTEGER NOT NULL AUTO_INCREMENT,
+  `courseId` INTEGER NOT NULL,
+  `locale` VARCHAR(10) NOT NULL,
+  `objectives` JSON NULL,
+  `targetAudience` JSON NULL,
+  `benefits` JSON NULL,
+  `createdAt` DATETIME(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),
+  `updatedAt` DATETIME(3) NOT NULL,
+  UNIQUE INDEX `CourseContentTranslation_courseId_locale_key`(`courseId`, `locale`),
+  INDEX `CourseContentTranslation_locale_idx`(`locale`),
+  PRIMARY KEY (`id`)
+) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
+
+CREATE TABLE `LessonTranslation` (
+  `id` INTEGER NOT NULL AUTO_INCREMENT,
+  `lessonId` INTEGER NOT NULL,
+  `locale` VARCHAR(10) NOT NULL,
+  `title` VARCHAR(255) NOT NULL,
+  `description` LONGTEXT NULL,
+  `createdAt` DATETIME(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),
+  `updatedAt` DATETIME(3) NOT NULL,
+  UNIQUE INDEX `LessonTranslation_lessonId_locale_key`(`lessonId`, `locale`),
+  INDEX `LessonTranslation_locale_idx`(`locale`),
+  PRIMARY KEY (`id`)
+) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
+
+CREATE TABLE `LessonModuleTranslation` (
+  `id` INTEGER NOT NULL AUTO_INCREMENT,
+  `moduleId` INTEGER NOT NULL,
+  `locale` VARCHAR(10) NOT NULL,
+  `title` VARCHAR(255) NOT NULL,
+  `description` LONGTEXT NULL,
+  `createdAt` DATETIME(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),
+  `updatedAt` DATETIME(3) NOT NULL,
+  UNIQUE INDEX `LessonModuleTranslation_moduleId_locale_key`(`moduleId`, `locale`),
+  INDEX `LessonModuleTranslation_locale_idx`(`locale`),
+  PRIMARY KEY (`id`)
+) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
+
+CREATE TABLE `LessonVideoTranslation` (
+  `id` INTEGER NOT NULL AUTO_INCREMENT,
+  `videoId` INTEGER NOT NULL,
+  `locale` VARCHAR(10) NOT NULL,
+  `title` VARCHAR(255) NOT NULL,
+  `description` LONGTEXT NULL,
+  `createdAt` DATETIME(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),
+  `updatedAt` DATETIME(3) NOT NULL,
+  UNIQUE INDEX `LessonVideoTranslation_videoId_locale_key`(`videoId`, `locale`),
+  INDEX `LessonVideoTranslation_locale_idx`(`locale`),
+  PRIMARY KEY (`id`)
+) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
+
+ALTER TABLE `CourseContentTranslation`
+  ADD CONSTRAINT `CourseContentTranslation_courseId_fkey`
+  FOREIGN KEY (`courseId`) REFERENCES `Course`(`id`) ON DELETE CASCADE ON UPDATE CASCADE;
+
+ALTER TABLE `LessonTranslation`
+  ADD CONSTRAINT `LessonTranslation_lessonId_fkey`
+  FOREIGN KEY (`lessonId`) REFERENCES `Lesson`(`id`) ON DELETE CASCADE ON UPDATE CASCADE;
+
+ALTER TABLE `LessonModuleTranslation`
+  ADD CONSTRAINT `LessonModuleTranslation_moduleId_fkey`
+  FOREIGN KEY (`moduleId`) REFERENCES `LessonModule`(`id`) ON DELETE CASCADE ON UPDATE CASCADE;
+
+ALTER TABLE `LessonVideoTranslation`
+  ADD CONSTRAINT `LessonVideoTranslation_videoId_fkey`
+  FOREIGN KEY (`videoId`) REFERENCES `LessonVideo`(`id`) ON DELETE CASCADE ON UPDATE CASCADE;
diff --git a/backend/ayanavitabackend/app/api/prisma/schema.prisma b/backend/ayanavitabackend/app/api/prisma/schema.prisma
index e143a75c7bff7ffa1bdbb7abd317a6bc356b0c2e..5bbf204d6ba781458b8865a7f8cdabc686120cc4 100644
--- a/backend/ayanavitabackend/app/api/prisma/schema.prisma
+++ b/backend/ayanavitabackend/app/api/prisma/schema.prisma
@@ -230,66 +230,64 @@ model ServiceReview {

   @@index([serviceId])
 }


 model RegistrationOtp {
   id        Int      @id @default(autoincrement())
   email     String   @unique
   code      String   @db.VarChar(6)
   expiresAt DateTime
   usedAt    DateTime?
   createdAt DateTime @default(now())
   updatedAt DateTime @updatedAt
 }

 model Course {
   id                  Int      @id @default(autoincrement())
   topicId             Int?
   title               String
   shortDescription    String?  @db.VarChar(500)
   slug                String   @unique
   description         String?
   thumbnail           String?
   price               Int      @default(0)
   published           Boolean  @default(false)
-  titleI18n           Json?
-  descriptionI18n     Json?
-  shortDescriptionI18n Json?
   objectives          Json?
   targetAudience      Json?
   benefits            Json?
   ratingAvg           Float    @default(0)
   ratingCount         Int      @default(0)
   enrollmentCount     Int      @default(0)
   createdAt           DateTime @default(now())
   updatedAt           DateTime @updatedAt

   lessons     Lesson[]
   enrollments Enrollment[]
   topic       CourseTopic? @relation(fields: [topicId], references: [id], onDelete: Restrict)
   translations CourseTranslation[]
+  contentTranslations CourseContentTranslation[]

   // ✅ ADD
   orderItems OrderItem[] // <— opposite for OrderItem.course

   @@index([topicId])
 }

 model CourseTranslation {
   id               Int      @id @default(autoincrement())
   courseId         Int
   locale           String   @db.VarChar(10)
   title            String   @db.VarChar(255)
   shortDescription String?  @db.VarChar(500)
   description      String?  @db.Text
   createdAt        DateTime @default(now())
   updatedAt        DateTime @updatedAt

   course Course @relation(fields: [courseId], references: [id], onDelete: Cascade)

   @@unique([courseId, locale])
   @@index([locale])
 }

 model CourseTopic {
   id          Int      @id @default(autoincrement())
@@ -326,149 +324,215 @@ model Product {
   description      String?  @db.LongText
   shortDescription String?  @db.VarChar(500)
   imageUrl         String?  @db.Text
   type             String   @default("cleanser") @db.VarChar(40)
   concerns         String   @default("") @db.VarChar(255)
   rating           Float    @default(4.5)
   sold             Int      @default(0)
   price            Int      @default(0)
   published        Boolean  @default(true)
   createdAt        DateTime @default(now())
   updatedAt        DateTime @updatedAt

   @@index([type])
   @@index([published])
   @@index([price])
 }

 model Lesson {
   id              Int              @id @default(autoincrement())
   courseId        Int
   title           String
   slug            String
   description     String?
   content         String?          @db.LongText
   videoUrl        String?
-  titleI18n       Json?
-  descriptionI18n Json?
   order           Int              @default(0)
   published       Boolean          @default(false)
   createdAt       DateTime         @default(now())
   updatedAt       DateTime         @updatedAt
   course          Course           @relation(fields: [courseId], references: [id], onDelete: Cascade)
   progress        LessonProgress[]
   modules         LessonModule[]
+  translations    LessonTranslation[]

   @@unique([courseId, slug])
   @@index([courseId, order])
 }

 model LessonModule {
   id              Int          @id @default(autoincrement())
   lessonId        Int
   title           String
   description     String?
-  titleI18n       Json?
-  descriptionI18n Json?
   order           Int          @default(0)
   published       Boolean      @default(true)
   createdAt       DateTime     @default(now())
   updatedAt       DateTime     @updatedAt

   lesson Lesson @relation(fields: [lessonId], references: [id], onDelete: Cascade)
   videos LessonVideo[]
+  translations LessonModuleTranslation[]

   @@index([lessonId, order])
 }

 model LessonVideo {
   id              Int          @id @default(autoincrement())
   moduleId        Int
   title           String
   description     String?
-  titleI18n       Json?
-  descriptionI18n Json?
   sourceUrl       String?
   hlsPlaylistKey  String?
   durationSec     Int          @default(0)
   order           Int          @default(0)
   published       Boolean      @default(true)
   createdAt       DateTime     @default(now())
   updatedAt       DateTime     @updatedAt

+  mediaType       LessonMediaType @default(VIDEO)
+
   module LessonModule @relation(fields: [moduleId], references: [id], onDelete: Cascade)
+  translations LessonVideoTranslation[]

   @@index([moduleId, order])
 }

+
+model CourseContentTranslation {
+  id             Int      @id @default(autoincrement())
+  courseId       Int
+  locale         String   @db.VarChar(10)
+  objectives     Json?
+  targetAudience Json?
+  benefits       Json?
+  createdAt      DateTime @default(now())
+  updatedAt      DateTime @updatedAt
+
+  course Course @relation(fields: [courseId], references: [id], onDelete: Cascade)
+
+  @@unique([courseId, locale])
+  @@index([locale])
+}
+
+model LessonTranslation {
+  id          Int      @id @default(autoincrement())
+  lessonId    Int
+  locale      String   @db.VarChar(10)
+  title       String   @db.VarChar(255)
+  description String?  @db.Text
+  createdAt   DateTime @default(now())
+  updatedAt   DateTime @updatedAt
+
+  lesson Lesson @relation(fields: [lessonId], references: [id], onDelete: Cascade)
+
+  @@unique([lessonId, locale])
+  @@index([locale])
+}
+
+model LessonModuleTranslation {
+  id          Int      @id @default(autoincrement())
+  moduleId    Int
+  locale      String   @db.VarChar(10)
+  title       String   @db.VarChar(255)
+  description String?  @db.Text
+  createdAt   DateTime @default(now())
+  updatedAt   DateTime @updatedAt
+
+  module LessonModule @relation(fields: [moduleId], references: [id], onDelete: Cascade)
+
+  @@unique([moduleId, locale])
+  @@index([locale])
+}
+
+model LessonVideoTranslation {
+  id          Int      @id @default(autoincrement())
+  videoId     Int
+  locale      String   @db.VarChar(10)
+  title       String   @db.VarChar(255)
+  description String?  @db.Text
+  createdAt   DateTime @default(now())
+  updatedAt   DateTime @updatedAt
+
+  video LessonVideo @relation(fields: [videoId], references: [id], onDelete: Cascade)
+
+  @@unique([videoId, locale])
+  @@index([locale])
+}
+
 model Enrollment {
   id       Int @id @default(autoincrement())
   userId   Int
   courseId Int
   orderId  Int

   createdAt DateTime @default(now())

   status     EnrollmentStatus @default(ACTIVE)
   enrolledAt DateTime         @default(now())
   updatedAt  DateTime         @updatedAt
   user       User             @relation(fields: [userId], references: [id], onDelete: Cascade)
   course     Course           @relation(fields: [courseId], references: [id], onDelete: Restrict)
   order      Order            @relation(fields: [orderId], references: [id], onDelete: Cascade)

   @@unique([userId, courseId])
   @@index([courseId])
   @@index([orderId])
 }

 model LessonProgress {
   id           Int      @id @default(autoincrement())
   userId       Int
   lessonId     Int
   completed    Boolean  @default(false)
   lastOpenedAt DateTime @default(now())

   // tiến độ
   status          ProgressStatus @default(IN_PROGRESS)
   percent         Int            @default(0) // 0..100
   lastPositionSec Int            @default(0)
   completedAt     DateTime?

   createdAt DateTime @default(now())
   updatedAt DateTime @updatedAt
   lesson    Lesson   @relation(fields: [lessonId], references: [id], onDelete: Cascade)
   user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

   @@unique([userId, lessonId])
   @@index([lessonId])
 }

 enum ProgressStatus {
   IN_PROGRESS
   COMPLETED
 }

+enum LessonMediaType {
+  VIDEO
+  IMAGE
+}
+
 enum SpecialistLevel {
   JUNIOR
   SENIOR
   EXPERT
   THERAPIST
 }

 enum AppointmentStatus {
   PENDING
   CONFIRMED
   DONE
   CANCELED
 }

 enum Role {
   ADMIN
   MANAGER
   STAFF
   USER
 }


 enum EnrollmentStatus {
   ACTIVE
   CANCELED
diff --git a/backend/ayanavitabackend/app/api/src/courses/courses.service.ts b/backend/ayanavitabackend/app/api/src/courses/courses.service.ts
index c8b0bc07f57d417fa894491383f89c39fc7727e1..ff702a4ee792b3a061e76b793874239b5f59bebe 100644
--- a/backend/ayanavitabackend/app/api/src/courses/courses.service.ts
+++ b/backend/ayanavitabackend/app/api/src/courses/courses.service.ts
@@ -1,350 +1,178 @@
-import { BadRequestException, ConflictException, ForbiddenException, Injectable, NotFoundException } from "@nestjs/common";
-import { PrismaService } from "../prisma/prisma.service";
-import { EnrollmentsService } from "../enrollments/enrollments.service";
-import { CreateCourseDto } from "./dto/create-course.dto";
-import { UpdateCourseDto } from "./dto/update-course.dto";
-import { Prisma, ProgressStatus } from "@prisma/client";
-import { CourseQueryDto } from "./dto/course-query.dto";
+import { BadRequestException, ConflictException, ForbiddenException, Injectable, NotFoundException } from '@nestjs/common'
+import { PrismaService } from '../prisma/prisma.service'
+import { EnrollmentsService } from '../enrollments/enrollments.service'
+import { CreateCourseDto } from './dto/create-course.dto'
+import { UpdateCourseDto } from './dto/update-course.dto'
+import { Prisma, ProgressStatus } from '@prisma/client'
+import { CourseQueryDto } from './dto/course-query.dto'

 type JwtUser = { sub: number; role: string }

 @Injectable()
 export class CoursesService {
   constructor(
     private readonly prisma: PrismaService,
-    private readonly enrollments: EnrollmentsService
+    private readonly enrollments: EnrollmentsService,
   ) {}

   private readonly baseCourseSelect = {
     id: true,
     topicId: true,
     title: true,
     shortDescription: true,
     slug: true,
     description: true,
     thumbnail: true,
     price: true,
     published: true,
-    titleI18n: true,
-    descriptionI18n: true,
-    shortDescriptionI18n: true,
     objectives: true,
     targetAudience: true,
     benefits: true,
     ratingAvg: true,
     ratingCount: true,
     enrollmentCount: true,
     createdAt: true,
     updatedAt: true,
-    topic: { select: { id: true, name: true } },
     _count: { select: { lessons: true } },
   } as const

   private buildCreateCoursePayload(dto: CreateCourseDto & { title: string }): Prisma.CourseUncheckedCreateInput {
     return {
       title: dto.title,
       slug: dto.slug,
       ...(dto.description !== undefined ? { description: dto.description } : {}),
       ...(dto.shortDescription !== undefined ? { shortDescription: dto.shortDescription } : {}),
       ...(dto.thumbnail !== undefined ? { thumbnail: dto.thumbnail } : {}),
       ...(dto.price !== undefined ? { price: dto.price } : {}),
       ...(dto.published !== undefined ? { published: dto.published } : {}),
       ...(dto.topicId !== undefined ? { topicId: dto.topicId } : {}),
-      ...(dto.titleI18n !== undefined ? { titleI18n: dto.titleI18n as any } : {}),
-      ...(dto.descriptionI18n !== undefined ? { descriptionI18n: dto.descriptionI18n as any } : {}),
-      ...(dto.shortDescriptionI18n !== undefined ? { shortDescriptionI18n: dto.shortDescriptionI18n as any } : {}),
       ...(dto.objectives !== undefined ? { objectives: dto.objectives as any } : {}),
       ...(dto.targetAudience !== undefined ? { targetAudience: dto.targetAudience as any } : {}),
       ...(dto.benefits !== undefined ? { benefits: dto.benefits as any } : {}),
       ...(dto.ratingAvg !== undefined ? { ratingAvg: dto.ratingAvg } : {}),
       ...(dto.ratingCount !== undefined ? { ratingCount: dto.ratingCount } : {}),
       ...(dto.enrollmentCount !== undefined ? { enrollmentCount: dto.enrollmentCount } : {}),
     }
   }

   private buildUpdateCoursePayload(dto: UpdateCourseDto): Prisma.CourseUncheckedUpdateInput {
     return {
       ...(dto.title !== undefined ? { title: dto.title } : {}),
       ...(dto.slug !== undefined ? { slug: dto.slug } : {}),
       ...(dto.description !== undefined ? { description: dto.description } : {}),
       ...(dto.shortDescription !== undefined ? { shortDescription: dto.shortDescription } : {}),
       ...(dto.thumbnail !== undefined ? { thumbnail: dto.thumbnail } : {}),
       ...(dto.price !== undefined ? { price: dto.price } : {}),
       ...(dto.published !== undefined ? { published: dto.published } : {}),
       ...(dto.topicId !== undefined ? { topicId: dto.topicId } : {}),
-      ...(dto.titleI18n !== undefined ? { titleI18n: dto.titleI18n as any } : {}),
-      ...(dto.descriptionI18n !== undefined ? { descriptionI18n: dto.descriptionI18n as any } : {}),
-      ...(dto.shortDescriptionI18n !== undefined ? { shortDescriptionI18n: dto.shortDescriptionI18n as any } : {}),
       ...(dto.objectives !== undefined ? { objectives: dto.objectives as any } : {}),
       ...(dto.targetAudience !== undefined ? { targetAudience: dto.targetAudience as any } : {}),
       ...(dto.benefits !== undefined ? { benefits: dto.benefits as any } : {}),
       ...(dto.ratingAvg !== undefined ? { ratingAvg: dto.ratingAvg } : {}),
       ...(dto.ratingCount !== undefined ? { ratingCount: dto.ratingCount } : {}),
       ...(dto.enrollmentCount !== undefined ? { enrollmentCount: dto.enrollmentCount } : {}),
     }
   }

-  async lessonsOutline(user: JwtUser, courseId: number) {
-    const course = await this.prisma.course.findUnique({
-      where: { id: courseId },
-      select: { id: true, published: true },
-    })
+  async lessonsOutline(user: JwtUser, courseId: number) { /* unchanged */
+    const course = await this.prisma.course.findUnique({ where: { id: courseId }, select: { id: true, published: true } })
     if (!course) throw new NotFoundException('Course not found')
-
-    if (user.role !== 'ADMIN' && !course.published) {
-      throw new NotFoundException('Course not found')
-    }
-
-    return this.prisma.lesson.findMany({
-      where: {
-        courseId,
-        ...(user.role === 'ADMIN' ? {} : { published: true }),
-      },
-      select: {
-        id: true,
-        courseId: true,
-        title: true,
-        slug: true,
-        order: true,
-        published: true,
-        createdAt: true,
-        updatedAt: true,
-      },
-      orderBy: [{ order: 'asc' }, { id: 'asc' }],
-    })
+    if (user.role !== 'ADMIN' && !course.published) throw new NotFoundException('Course not found')
+    return this.prisma.lesson.findMany({ where: { courseId, ...(user.role === 'ADMIN' ? {} : { published: true }) }, select: { id: true, courseId: true, title: true, slug: true, order: true, published: true, createdAt: true, updatedAt: true }, orderBy: [{ order: 'asc' }, { id: 'asc' }] })
   }

   async findAll(query: CourseQueryDto, user?: { sub: number; role: string } | null) {
     const activeLang = (query.lang || 'vi').toLowerCase()
     const courseLocale = activeLang === 'en-us' || activeLang === 'en' ? 'en' : activeLang === 'de' ? 'de' : 'vi'
-    const topicLocale = activeLang === 'en' ? 'en' : activeLang === 'en-us' ? 'en' : activeLang === 'de' ? 'de' : 'vi'
-
+    const topicLocale = courseLocale
     const where: Prisma.CourseWhereInput = {
       ...(user?.role === 'ADMIN' ? {} : { published: true }),
       ...(query.topicId ? { topicId: query.topicId } : {}),
-      ...(query.search?.trim()
-        ? {
-            OR: [
-              { title: { contains: query.search.trim() } },
-              { slug: { contains: query.search.trim() } },
-            ],
-          }
-        : {}),
+      ...(query.search?.trim() ? { OR: [{ title: { contains: query.search.trim() } }, { slug: { contains: query.search.trim() } }] } : {}),
     }
-
-    const page = Math.max(1, Number(query.page || 1))
-    const pageSize = Math.min(100, Math.max(1, Number(query.pageSize || 10)))
-
+    const page = Math.max(1, Number(query.page || 1)); const pageSize = Math.min(100, Math.max(1, Number(query.pageSize || 10)))
     const [rows, total] = await Promise.all([
       this.prisma.course.findMany({
-      where,
-      select: {
-        ...this.baseCourseSelect,
-        translations: {
-          where: { locale: { in: [courseLocale, 'vi'] } },
-          select: { locale: true, title: true, shortDescription: true, description: true },
-        },
-        topic: {
-          select: {
-            id: true,
-            name: true,
-            translations: {
-              where: { locale: { in: [topicLocale, 'vi'] } },
-              select: { locale: true, name: true },
-            },
-          },
+        where,
+        select: {
+          ...this.baseCourseSelect,
+          translations: { where: { locale: { in: [courseLocale, 'vi'] } }, select: { locale: true, title: true, shortDescription: true, description: true } },
+          contentTranslations: { where: { locale: { in: [courseLocale, 'vi'] } }, select: { locale: true, objectives: true, targetAudience: true, benefits: true } },
+          topic: { select: { id: true, name: true, translations: { where: { locale: { in: [topicLocale, 'vi'] } }, select: { locale: true, name: true } } } },
         },
-      },
-      skip: (page - 1) * pageSize,
-      take: pageSize,
-      orderBy: { id: "desc" },
+        skip: (page - 1) * pageSize, take: pageSize, orderBy: { id: 'desc' },
       }),
       this.prisma.course.count({ where }),
     ])
-
-    const courseIds = rows.map((row) => row.id)
-    if (!courseIds.length) {
-      return { items: [], total, page, pageSize }
-    }
-
-    const videoRows = await this.prisma.$queryRaw<Array<{ courseId: number; videoCount: bigint | number }>>`
-      SELECT l.courseId as courseId, COUNT(v.id) as videoCount
-      FROM LessonVideo v
-      INNER JOIN LessonModule m ON m.id = v.moduleId
-      INNER JOIN Lesson l ON l.id = m.lessonId
-      WHERE l.courseId IN (${Prisma.join(courseIds)})
-      GROUP BY l.courseId
-    `
-
-    const videoCountMap = new Map(videoRows.map((row) => [Number(row.courseId), Number(row.videoCount)]))
+    const courseIds = rows.map((r) => r.id)
+    if (!courseIds.length) return { items: [], total, page, pageSize }
+    const videoRows = await this.prisma.$queryRaw<Array<{ courseId: number; videoCount: bigint | number }>>`SELECT l.courseId as courseId, COUNT(v.id) as videoCount FROM LessonVideo v INNER JOIN LessonModule m ON m.id = v.moduleId INNER JOIN Lesson l ON l.id = m.lessonId WHERE l.courseId IN (${Prisma.join(courseIds)}) GROUP BY l.courseId`
+    const videoCountMap = new Map(videoRows.map((r) => [Number(r.courseId), Number(r.videoCount)]))
     const items = rows.map((row: any) => {
-      const chosenCourseTrans = row.translations?.find((item: any) => item.locale === courseLocale) || row.translations?.find((item: any) => item.locale === 'vi')
-      const chosenTopicTrans = row.topic?.translations?.find((item: any) => item.locale === topicLocale) || row.topic?.translations?.find((item: any) => item.locale === 'vi')
-
-      return {
-        ...row,
-        title: chosenCourseTrans?.title || row.title,
-        shortDescription: chosenCourseTrans?.shortDescription || row.shortDescription,
-        description: chosenCourseTrans?.description || row.description,
-        topic: row.topic
-          ? {
-              id: row.topic.id,
-              name: chosenTopicTrans?.name || row.topic.name,
-            }
-          : null,
-        videoCount: videoCountMap.get(row.id) || 0,
-      }
+      const tr = row.translations?.find((x: any) => x.locale === courseLocale) || row.translations?.find((x: any) => x.locale === 'vi')
+      const ct = row.contentTranslations?.find((x: any) => x.locale === courseLocale) || row.contentTranslations?.find((x: any) => x.locale === 'vi')
+      const tt = row.topic?.translations?.find((x: any) => x.locale === topicLocale) || row.topic?.translations?.find((x: any) => x.locale === 'vi')
+      return { ...row, title: tr?.title || row.title, shortDescription: tr?.shortDescription || row.shortDescription, description: tr?.description || row.description, objectives: ct?.objectives || row.objectives, targetAudience: ct?.targetAudience || row.targetAudience, benefits: ct?.benefits || row.benefits, topic: row.topic ? { id: row.topic.id, name: tt?.name || row.topic.name } : null, videoCount: videoCountMap.get(row.id) || 0 }
     })
-
     return { items, total, page, pageSize }
   }

-  async findOne(id: number) {
-    const course = await this.prisma.course.findUnique({
-      where: { id },
-      select: this.baseCourseSelect,
-    });
-    if (!course) throw new NotFoundException("Course not found");
-    return course;
-  }
+  async findOne(id: number) { const c = await this.prisma.course.findUnique({ where: { id }, select: this.baseCourseSelect }); if (!c) throw new NotFoundException('Course not found'); return c }

   async create(dto: CreateCourseDto) {
-    if (!dto.title?.trim()) {
-      throw new BadRequestException("Title is required")
-    }
-
+    if (!dto.title?.trim()) throw new BadRequestException('Title is required')
     try {
-      const created = await this.prisma.course.create({
-        data: this.buildCreateCoursePayload({ ...dto, title: dto.title.trim() }),
-        select: this.baseCourseSelect,
-      })
+      const created = await this.prisma.course.create({ data: this.buildCreateCoursePayload({ ...dto, title: dto.title.trim() }), select: this.baseCourseSelect })
       await this.syncCourseTranslations(created.id, dto)
       return created
     } catch (e) {
-      if (e instanceof Prisma.PrismaClientKnownRequestError && e.code === "P2002") {
-        const target = (e.meta as any)?.target;
-        if (Array.isArray(target) ? target.includes("slug") : String(target).includes("slug")) {
-          throw new ConflictException("Slug already exists");
-        }
-        throw new ConflictException("Unique constraint failed");
-      }
-      throw e;
+      if (e instanceof Prisma.PrismaClientKnownRequestError && e.code === 'P2002') throw new ConflictException('Slug already exists')
+      throw e
     }
   }

-  async update(id: number, dto: UpdateCourseDto) {
-    await this.ensureCourseExists(id);
-    const updated = await this.prisma.course.update({
-      where: { id },
-      data: this.buildUpdateCoursePayload(dto),
-      select: this.baseCourseSelect,
-    })
-    await this.syncCourseTranslations(id, dto)
-    return updated
-  }
+  async update(id: number, dto: UpdateCourseDto) { await this.ensureCourseExists(id); const updated = await this.prisma.course.update({ where: { id }, data: this.buildUpdateCoursePayload(dto), select: this.baseCourseSelect }); await this.syncCourseTranslations(id, dto); return updated }
+  async remove(id: number) { await this.ensureCourseExists(id); return this.prisma.course.delete({ where: { id }, select: { id: true } }) }

-  async remove(id: number) {
-    await this.ensureCourseExists(id);
-    return this.prisma.course.delete({ where: { id }, select: { id: true } });
+  async listLessons(user: { sub: number; role: string }, courseId: number) { /* kept */
+    const course = await this.prisma.course.findUnique({ where: { id: courseId }, select: { id: true, published: true } }); if (!course) throw new NotFoundException('Course not found'); await this.enrollments.assertEnrolledOrAdmin(user, courseId); if (user.role !== 'ADMIN' && !course.published) throw new NotFoundException('Course not found')
+    const lessons = await this.prisma.lesson.findMany({ where: { courseId, ...(user.role === 'ADMIN' ? {} : { published: true }) }, select: { id: true, courseId: true, title: true, slug: true, order: true, published: true, createdAt: true, updatedAt: true }, orderBy: [{ order: 'asc' }, { id: 'asc' }] })
+    if (user.role === 'ADMIN') return lessons.map((l) => ({ ...l, locked: false, lockReason: null, progress: null }))
+    const progressRows = await this.prisma.lessonProgress.findMany({ where: { userId: user.sub, lessonId: { in: lessons.map((l) => l.id) } }, select: { lessonId: true, status: true, percent: true, lastPositionSec: true, lastOpenedAt: true, completedAt: true, updatedAt: true } })
+    const progressMap = new Map(progressRows.map((p) => [p.lessonId, p])); let prevCompleted = true
+    return lessons.map((lesson, idx) => { const progress = progressMap.get(lesson.id) ?? null; const locked = idx === 0 ? false : prevCompleted === false; const lockReason = locked ? 'PREV_NOT_COMPLETED' : null; prevCompleted = progress?.status === ProgressStatus.COMPLETED; return { ...lesson, locked, lockReason, progress } })
   }

-  async listLessons(user: { sub: number; role: string }, courseId: number) {
-    const course = await this.prisma.course.findUnique({ where: { id: courseId }, select: { id: true, published: true } });
-    if (!course) throw new NotFoundException("Course not found");
-    await this.enrollments.assertEnrolledOrAdmin(user, courseId);
-    if (user.role !== "ADMIN" && !course.published) throw new NotFoundException("Course not found");
-
-    const lessons = await this.prisma.lesson.findMany({
-      where: { courseId, ...(user.role === "ADMIN" ? {} : { published: true }) },
-      select: { id: true, courseId: true, title: true, slug: true, order: true, published: true, createdAt: true, updatedAt: true },
-      orderBy: [{ order: "asc" }, { id: "asc" }],
-    });
-
-    if (user.role === "ADMIN") return lessons.map((l) => ({ ...l, locked: false, lockReason: null, progress: null }));
-
-    const progressRows = await this.prisma.lessonProgress.findMany({
-      where: { userId: user.sub, lessonId: { in: lessons.map((l) => l.id) } },
-      select: { lessonId: true, status: true, percent: true, lastPositionSec: true, lastOpenedAt: true, completedAt: true, updatedAt: true },
-    });
-
-    const progressMap = new Map(progressRows.map((p) => [p.lessonId, p]));
-    let prevCompleted = true;
-    return lessons.map((lesson, idx) => {
-      const progress = progressMap.get(lesson.id) ?? null;
-      const locked = idx === 0 ? false : prevCompleted === false;
-      const lockReason = locked ? "PREV_NOT_COMPLETED" : null;
-      prevCompleted = progress?.status === ProgressStatus.COMPLETED;
-      return { ...lesson, locked, lockReason, progress };
-    });
+  async getLessonDetail(user: { sub: number; role: string }, courseId: number, lessonId: number) { /* kept */
+    const course = await this.prisma.course.findUnique({ where: { id: courseId }, select: { id: true, published: true } }); if (!course) throw new NotFoundException('Course not found'); await this.enrollments.assertEnrolledOrAdmin(user, courseId); if (user.role !== 'ADMIN' && !course.published) throw new NotFoundException('Course not found')
+    const lesson = await this.prisma.lesson.findFirst({ where: { id: lessonId, courseId }, select: { id: true, courseId: true, title: true, slug: true, content: true, videoUrl: true, order: true, published: true, createdAt: true, updatedAt: true } }); if (!lesson) throw new NotFoundException('Lesson not found')
+    if (user.role !== 'ADMIN' && !lesson.published) throw new NotFoundException('Lesson not found')
+    if (user.role !== 'ADMIN') { const orderedLessons = await this.prisma.lesson.findMany({ where: { courseId, published: true }, select: { id: true }, orderBy: [{ order: 'asc' }, { id: 'asc' }] }); const idx = orderedLessons.findIndex((l) => l.id === lessonId); if (idx < 0) throw new NotFoundException('Lesson not found'); if (idx > 0) { const prevLessonId = orderedLessons[idx - 1].id; const prevProgress = await this.prisma.lessonProgress.findUnique({ where: { userId_lessonId: { userId: user.sub, lessonId: prevLessonId } }, select: { status: true } }); if (prevProgress?.status !== ProgressStatus.COMPLETED) throw new ForbiddenException('Lesson locked') } }
+    const progress = await this.prisma.lessonProgress.findUnique({ where: { userId_lessonId: { userId: user.sub, lessonId } }, select: { lessonId: true, status: true, percent: true, lastPositionSec: true, lastOpenedAt: true, completedAt: true, updatedAt: true } })
+    return { ...lesson, progress: progress ?? null }
   }

-  async getLessonDetail(user: { sub: number; role: string }, courseId: number, lessonId: number) {
-    const course = await this.prisma.course.findUnique({ where: { id: courseId }, select: { id: true, published: true } });
-    if (!course) throw new NotFoundException("Course not found");
-    await this.enrollments.assertEnrolledOrAdmin(user, courseId);
-    if (user.role !== "ADMIN" && !course.published) throw new NotFoundException("Course not found");
-
-    const lesson = await this.prisma.lesson.findFirst({
-      where: { id: lessonId, courseId },
-      select: { id: true, courseId: true, title: true, slug: true, content: true, videoUrl: true, order: true, published: true, createdAt: true, updatedAt: true },
-    });
-    if (!lesson) throw new NotFoundException("Lesson not found");
-    if (user.role !== "ADMIN" && !lesson.published) throw new NotFoundException("Lesson not found");
-
-    if (user.role !== "ADMIN") {
-      const orderedLessons = await this.prisma.lesson.findMany({ where: { courseId, published: true }, select: { id: true }, orderBy: [{ order: "asc" }, { id: "asc" }] });
-      const idx = orderedLessons.findIndex((l) => l.id === lessonId);
-      if (idx < 0) throw new NotFoundException("Lesson not found");
-      if (idx > 0) {
-        const prevLessonId = orderedLessons[idx - 1].id;
-        const prevProgress = await this.prisma.lessonProgress.findUnique({ where: { userId_lessonId: { userId: user.sub, lessonId: prevLessonId } }, select: { status: true } });
-        const unlocked = prevProgress?.status === ProgressStatus.COMPLETED;
-        if (!unlocked) throw new ForbiddenException("Lesson locked");
-      }
-    }
-
-    const progress = await this.prisma.lessonProgress.findUnique({
-      where: { userId_lessonId: { userId: user.sub, lessonId } },
-      select: { lessonId: true, status: true, percent: true, lastPositionSec: true, lastOpenedAt: true, completedAt: true, updatedAt: true },
-    });
-
-    return { ...lesson, progress: progress ?? null };
-  }
-
-  private async ensureCourseExists(id: number) {
-    const ok = await this.prisma.course.findUnique({ where: { id }, select: { id: true } });
-    if (!ok) throw new NotFoundException("Course not found");
-  }
+  private async ensureCourseExists(id: number) { if (!(await this.prisma.course.findUnique({ where: { id }, select: { id: true } }))) throw new NotFoundException('Course not found') }

   private async syncCourseTranslations(courseId: number, dto: Partial<CreateCourseDto>) {
     const locales: Array<'vi' | 'en' | 'de'> = ['vi', 'en', 'de']
-    const mapLocale = (locale: 'vi' | 'en' | 'de') => (locale === 'en' ? 'en' : locale)
-
-    await Promise.all(
-      locales.map((locale) => {
-        const inputLocale = mapLocale(locale)
-        const title = dto.titleI18n?.[inputLocale] || (locale === 'vi' ? dto.title : undefined)
-        const description = dto.descriptionI18n?.[inputLocale] || (locale === 'vi' ? dto.description : undefined)
-        const shortDescription = dto.shortDescriptionI18n?.[inputLocale] || (locale === 'vi' ? dto.shortDescription : undefined)
-
-        if (!title?.trim()) return Promise.resolve(null)
-
-        return this.prisma.courseTranslation.upsert({
+    await Promise.all(locales.map(async (locale) => {
+      const tr = dto.translations?.[locale]
+      const title = tr?.title || (locale === 'vi' ? dto.title : undefined)
+      if (!title?.trim()) return
+      await this.prisma.courseTranslation.upsert({
+        where: { courseId_locale: { courseId, locale } },
+        update: { title: title.trim(), shortDescription: tr?.shortDescription?.trim() || (locale === 'vi' ? dto.shortDescription?.trim() || null : null), description: tr?.description?.trim() || (locale === 'vi' ? dto.description?.trim() || null : null) },
+        create: { courseId, locale, title: title.trim(), shortDescription: tr?.shortDescription?.trim() || (locale === 'vi' ? dto.shortDescription?.trim() || null : null), description: tr?.description?.trim() || (locale === 'vi' ? dto.description?.trim() || null : null) },
+      })
+      const ct = dto.contentTranslations?.[locale]
+      if (ct || locale === 'vi') {
+        await this.prisma.courseContentTranslation.upsert({
           where: { courseId_locale: { courseId, locale } },
-          update: {
-            title: title.trim(),
-            shortDescription: shortDescription?.trim() || null,
-            description: description?.trim() || null,
-          },
-          create: {
-            courseId,
-            locale,
-            title: title.trim(),
-            shortDescription: shortDescription?.trim() || null,
-            description: description?.trim() || null,
-          },
+          update: { objectives: (ct?.objectives || (locale === 'vi' ? dto.objectives : undefined) || []) as any, targetAudience: (ct?.targetAudience || (locale === 'vi' ? dto.targetAudience : undefined) || []) as any, benefits: (ct?.benefits || (locale === 'vi' ? dto.benefits : undefined) || []) as any },
+          create: { courseId, locale, objectives: (ct?.objectives || (locale === 'vi' ? dto.objectives : undefined) || []) as any, targetAudience: (ct?.targetAudience || (locale === 'vi' ? dto.targetAudience : undefined) || []) as any, benefits: (ct?.benefits || (locale === 'vi' ? dto.benefits : undefined) || []) as any },
         })
-      }),
-    )
+      }
+    }))
   }
 }
diff --git a/backend/ayanavitabackend/app/api/src/courses/dto/create-course.dto.ts b/backend/ayanavitabackend/app/api/src/courses/dto/create-course.dto.ts
index 810721154abb5527883ada5c171f0c2978e74b9e..a9a8cab49b963a772af4a3130bd0c981a518e0ec 100644
--- a/backend/ayanavitabackend/app/api/src/courses/dto/create-course.dto.ts
+++ b/backend/ayanavitabackend/app/api/src/courses/dto/create-course.dto.ts
@@ -1,112 +1,110 @@
-import {
-  IsArray,
-  IsBoolean,
-  IsInt,
-  IsNumber,
-  IsObject,
-  IsOptional,
-  IsString,
-  Max,
-  Min,
-  ValidateNested,
-} from 'class-validator'
 import { Type } from 'class-transformer'
+import { IsArray, IsBoolean, IsInt, IsNumber, IsObject, IsOptional, IsString, Max, Min, ValidateNested } from 'class-validator'

-class I18nTextDto {
-  @IsOptional()
+class TranslationDto {
   @IsString()
-  vi?: string
+  title: string

   @IsOptional()
   @IsString()
-  'en'?: string
+  shortDescription?: string

   @IsOptional()
   @IsString()
-  de?: string
+  description?: string
+}
+
+class ContentTranslationDto {
+  @IsOptional()
+  @IsArray()
+  @IsString({ each: true })
+  objectives?: string[]
+
+  @IsOptional()
+  @IsArray()
+  @IsString({ each: true })
+  targetAudience?: string[]
+
+  @IsOptional()
+  @IsArray()
+  @IsString({ each: true })
+  benefits?: string[]
 }

 export class CreateCourseDto {
   @IsString()
   slug: string

   @IsOptional()
   @IsString()
   title?: string

   @IsOptional()
   @IsString()
   shortDescription?: string

-  @IsOptional()
-  @ValidateNested()
-  @Type(() => I18nTextDto)
-  titleI18n?: I18nTextDto
-
   @IsOptional()
   @IsString()
   description?: string

-  @IsOptional()
-  @ValidateNested()
-  @Type(() => I18nTextDto)
-  descriptionI18n?: I18nTextDto
-
-  @IsOptional()
-  @ValidateNested()
-  @Type(() => I18nTextDto)
-  shortDescriptionI18n?: I18nTextDto
-
   @IsOptional()
   @IsString()
   thumbnail?: string

   @IsOptional()
   @IsInt()
   @Min(0)
   price?: number

   @IsOptional()
   @IsBoolean()
   published?: boolean

   @IsOptional()
   @IsInt()
   @Min(1)
   topicId?: number

   @IsOptional()
   @IsArray()
   @IsString({ each: true })
   objectives?: string[]

   @IsOptional()
   @IsArray()
   @IsString({ each: true })
   targetAudience?: string[]

   @IsOptional()
   @IsArray()
   @IsString({ each: true })
   benefits?: string[]

+  @IsOptional()
+  @IsObject()
+  @ValidateNested({ each: true })
+  @Type(() => TranslationDto)
+  translations?: Record<string, TranslationDto>
+
+  @IsOptional()
+  @IsObject()
+  @ValidateNested({ each: true })
+  @Type(() => ContentTranslationDto)
+  contentTranslations?: Record<string, ContentTranslationDto>
+
   @IsOptional()
   @IsNumber()
   @Min(0)
   @Max(5)
   ratingAvg?: number

   @IsOptional()
   @IsInt()
   @Min(0)
   ratingCount?: number

   @IsOptional()
   @IsInt()
   @Min(0)
   enrollmentCount?: number
-
-  @IsOptional()
-  @IsObject()
-  extraMeta?: Record<string, unknown>
 }
diff --git a/backend/ayanavitabackend/app/api/src/lessons/dto/create-lesson.dto.ts b/backend/ayanavitabackend/app/api/src/lessons/dto/create-lesson.dto.ts
index 402618d9994330f22b7c0e0edce81b89eba9a3cc..d8ad824a47954c3f19b76bfa829de95f367bc049 100644
--- a/backend/ayanavitabackend/app/api/src/lessons/dto/create-lesson.dto.ts
+++ b/backend/ayanavitabackend/app/api/src/lessons/dto/create-lesson.dto.ts
@@ -1,141 +1,49 @@
 import { Type } from 'class-transformer'
-import {
-  IsArray,
-  IsBoolean,
-  IsInt,
-  IsObject,
-  IsOptional,
-  IsString,
-  Min,
-  ValidateNested,
-} from 'class-validator'
+import { IsArray, IsBoolean, IsInt, IsObject, IsOptional, IsString, Min, ValidateNested } from 'class-validator'

-class I18nTextDto {
-  @IsOptional()
-  @IsString()
-  vi?: string
-
-  @IsOptional()
+class TranslationDto {
   @IsString()
-  'en'?: string
+  title: string

   @IsOptional()
   @IsString()
-  de?: string
+  description?: string
 }

 class LessonVideoDto {
   @IsString()
   title: string
-
-  @IsOptional()
-  @IsString()
-  description?: string
-
-  @IsOptional()
-  @ValidateNested()
-  @Type(() => I18nTextDto)
-  titleI18n?: I18nTextDto
-
-  @IsOptional()
-  @ValidateNested()
-  @Type(() => I18nTextDto)
-  descriptionI18n?: I18nTextDto
-
-  @IsOptional()
-  @IsString()
-  sourceUrl?: string
-
-  @IsOptional()
-  @IsInt()
-  @Min(0)
-  durationSec?: number
-
-  @IsOptional()
-  @IsInt()
-  @Min(0)
-  order?: number
-
-  @IsOptional()
-  @IsBoolean()
-  published?: boolean
+  @IsOptional() @IsString() description?: string
+  @IsOptional() @IsString() sourceUrl?: string
+  @IsOptional() @IsString() mediaType?: 'VIDEO' | 'IMAGE'
+  @IsOptional() @IsInt() @Min(0) durationSec?: number
+  @IsOptional() @IsInt() @Min(0) order?: number
+  @IsOptional() @IsBoolean() published?: boolean
+  @IsOptional() @IsObject() @ValidateNested({ each: true }) @Type(() => TranslationDto)
+  translations?: Record<string, TranslationDto>
 }

 class LessonModuleDto {
-  @IsString()
-  title: string
-
-  @IsOptional()
-  @IsString()
-  description?: string
-
-  @IsOptional()
-  @ValidateNested()
-  @Type(() => I18nTextDto)
-  titleI18n?: I18nTextDto
-
-  @IsOptional()
-  @ValidateNested()
-  @Type(() => I18nTextDto)
-  descriptionI18n?: I18nTextDto
-
-  @IsOptional()
-  @IsInt()
-  @Min(0)
-  order?: number
-
-  @IsOptional()
-  @IsBoolean()
-  published?: boolean
-
-  @IsOptional()
-  @IsArray()
-  @ValidateNested({ each: true })
-  @Type(() => LessonVideoDto)
+  @IsString() title: string
+  @IsOptional() @IsString() description?: string
+  @IsOptional() @IsInt() @Min(0) order?: number
+  @IsOptional() @IsBoolean() published?: boolean
+  @IsOptional() @IsObject() @ValidateNested({ each: true }) @Type(() => TranslationDto)
+  translations?: Record<string, TranslationDto>
+  @IsOptional() @IsArray() @ValidateNested({ each: true }) @Type(() => LessonVideoDto)
   videos?: LessonVideoDto[]
 }

 export class CreateLessonDto {
-  @IsString()
-  title!: string
-
-  @IsString()
-  slug!: string
-
-  @IsOptional()
-  @IsString()
-  description?: string
-
-  @IsOptional()
-  @ValidateNested()
-  @Type(() => I18nTextDto)
-  titleI18n?: I18nTextDto
-
-  @IsOptional()
-  @ValidateNested()
-  @Type(() => I18nTextDto)
-  descriptionI18n?: I18nTextDto
-
-  @IsOptional()
-  @IsString()
-  content?: string
-
-  @IsOptional()
-  @IsString()
-  videoUrl?: string
-
-  @IsOptional()
-  @IsArray()
-  @ValidateNested({ each: true })
-  @Type(() => LessonModuleDto)
+  @IsString() title!: string
+  @IsString() slug!: string
+  @IsOptional() @IsString() description?: string
+  @IsOptional() @IsObject() @ValidateNested({ each: true }) @Type(() => TranslationDto)
+  translations?: Record<string, TranslationDto>
+  @IsOptional() @IsString() content?: string
+  @IsOptional() @IsString() videoUrl?: string
+  @IsOptional() @IsArray() @ValidateNested({ each: true }) @Type(() => LessonModuleDto)
   modules?: LessonModuleDto[]
-
-  @IsOptional()
-  @IsInt()
-  @Min(0)
-  order?: number
-
-  @IsOptional()
-  @IsBoolean()
-  published?: boolean
+  @IsOptional() @IsInt() @Min(0) order?: number
+  @IsOptional() @IsBoolean() published?: boolean
 }
diff --git a/backend/ayanavitabackend/app/api/src/lessons/lessons-media.service.ts b/backend/ayanavitabackend/app/api/src/lessons/lessons-media.service.ts
index 3e035327bd276032fa93728d9925eed097a3f565..5c416bd4921d0b3666f91fac27e281e486b7f25b 100644
--- a/backend/ayanavitabackend/app/api/src/lessons/lessons-media.service.ts
+++ b/backend/ayanavitabackend/app/api/src/lessons/lessons-media.service.ts
@@ -67,50 +67,67 @@ export class LessonsMediaService {
       body: new Uint8Array(body),
     })

     if (!res.ok) {
       const text = await res.text()
       throw new InternalServerErrorException(`Upload video failed: ${res.status} ${text}`)
     }

     return key
   }

   private runFfmpeg(args: string[]) {
     return new Promise<void>((resolve, reject) => {
       const ffmpeg = spawn('ffmpeg', args)
       let stderr = ''
       ffmpeg.stderr.on('data', (chunk) => {
         stderr += chunk.toString()
       })
       ffmpeg.on('close', (code) => {
         if (code === 0) return resolve()
         reject(new Error(stderr || `ffmpeg exited with ${code}`))
       })
     })
   }

+
+  async convertImageToWebpAndUpload(file: { buffer: Buffer; originalname?: string }, lessonId: number, moduleId: string) {
+    const workDir = join(tmpdir(), `lms-img-${randomUUID()}`)
+    await mkdir(workDir, { recursive: true })
+    const inputPath = join(workDir, file.originalname || 'input')
+    const outputPath = join(workDir, 'image.webp')
+    try {
+      await writeFile(inputPath, file.buffer)
+      await this.runFfmpeg(['-y', '-i', inputPath, '-qscale', '75', outputPath])
+      const webp = await readFile(outputPath)
+      const imageKey = `private/courses/${lessonId}/modules/${moduleId}/${randomUUID()}.webp`
+      await this.uploadPrivateObject(imageKey, webp, 'image/webp')
+      return { imageKey, sourceUrl: imageKey, storage: 'private-bucket' }
+    } finally {
+      await rm(workDir, { recursive: true, force: true })
+    }
+  }
   async transcodeToHlsAndUpload(file: { buffer: Buffer; originalname?: string }, lessonId: number, moduleId: string) {
     const workDir = join(tmpdir(), `lms-hls-${randomUUID()}`)
     await mkdir(workDir, { recursive: true })

     const inputPath = join(workDir, file.originalname || 'input.mp4')
     const outputPlaylist = join(workDir, 'index.m3u8')

     try {
       await writeFile(inputPath, file.buffer)
       await this.runFfmpeg([
         '-y',
         '-i',
         inputPath,
         '-preset',
         'veryfast',
         '-g',
         '48',
         '-sc_threshold',
         '0',
         '-hls_time',
         '6',
         '-hls_playlist_type',
         'vod',
         '-hls_segment_filename',
         join(workDir, 'segment_%03d.ts'),
diff --git a/backend/ayanavitabackend/app/api/src/lessons/lessons.controller.ts b/backend/ayanavitabackend/app/api/src/lessons/lessons.controller.ts
index deaeecb1588582e45cd2900354154843171d7e7b..0bd6bd2fb641d67e8291472adcdf467fef130d97 100644
--- a/backend/ayanavitabackend/app/api/src/lessons/lessons.controller.ts
+++ b/backend/ayanavitabackend/app/api/src/lessons/lessons.controller.ts
@@ -28,55 +28,56 @@ export class LessonsController {

   // USER/ADMIN: xem chi tiết lesson
   // Rule: USER chỉ xem được khi Enrollment ACTIVE; ADMIN bypass
   @Get('lessons/:id')
   findOne(
     @CurrentUser() user: JwtUser,
     @Param('id', ParseIntPipe) id: number,
   ) {
     return this.lessons.findOne(user, id)
   }

   // ADMIN: tạo lesson trong course
   @UseGuards(RolesGuard)
   @Roles('ADMIN')
   @Post('courses/:courseId/lessons')
   create(
     @Param('courseId', ParseIntPipe) courseId: number,
     @Body() dto: CreateLessonDto,
   ) {
     return this.lessons.create(courseId, dto)
   }


   @UseGuards(RolesGuard)
   @Roles('ADMIN')
-  @Post('lessons/:id/modules/:moduleId/videos/upload')
+  @Post('lessons/:id/modules/:moduleId/media/upload')
   @UseInterceptors(FileInterceptor('file', { storage: memoryStorage() }))
-  uploadModuleVideo(
+  uploadModuleMedia(
     @Param('id', ParseIntPipe) lessonId: number,
     @Param('moduleId') moduleId: string,
     @UploadedFile() file?: any,
+    @Body('type') type?: string,
   ) {
-    if (!file) return { message: 'Missing video file' }
-    return this.lessons.uploadModuleVideo(lessonId, moduleId, file)
+    if (!file) return { message: 'Missing media file' }
+    return this.lessons.uploadModuleMedia(lessonId, moduleId, type === 'image' ? 'image' : 'video', file)
   }

   // ADMIN: update lesson
   @UseGuards(RolesGuard)
   @Roles('ADMIN')
   @Patch('lessons/:id')
   update(
     @Param('id', ParseIntPipe) id: number,
     @Body() dto: UpdateLessonDto,
   ) {
     return this.lessons.update(id, dto)
   }

   // ADMIN: delete lesson
   @UseGuards(RolesGuard)
   @Roles('ADMIN')
   @Delete('lessons/:id')
   remove(@Param('id', ParseIntPipe) id: number) {
     return this.lessons.remove(id)
   }
 }
diff --git a/backend/ayanavitabackend/app/api/src/lessons/lessons.service.ts b/backend/ayanavitabackend/app/api/src/lessons/lessons.service.ts
index addf16d317fe52ae31d7b1958d37cbb6bba43778..d0ce85be7af9a7dda4bc49b497ce7463dc548042 100644
--- a/backend/ayanavitabackend/app/api/src/lessons/lessons.service.ts
+++ b/backend/ayanavitabackend/app/api/src/lessons/lessons.service.ts
@@ -1,226 +1,115 @@
 import { ForbiddenException, Injectable, NotFoundException } from '@nestjs/common'
 import { PrismaService } from '../prisma/prisma.service'
 import { CreateLessonDto } from './dto/create-lesson.dto'
 import { UpdateLessonDto } from './dto/update-lesson.dto'
 import { EnrollmentsService } from '../enrollments/enrollments.service'
 import { LessonsMediaService } from './lessons-media.service'
 import { JwtUser } from '../auth/decorators/current-user.decorator'
-import { ProgressStatus } from '@prisma/client'
+import { LessonMediaType, ProgressStatus } from '@prisma/client'

 @Injectable()
 export class LessonsService {
-  constructor(
-    private readonly prisma: PrismaService,
-    private readonly enrollments: EnrollmentsService,
-    private readonly media: LessonsMediaService,
-  ) {}
+  constructor(private readonly prisma: PrismaService, private readonly enrollments: EnrollmentsService, private readonly media: LessonsMediaService) {}

   async findOne(user: JwtUser, id: number) {
     const lesson = await this.prisma.lesson.findUnique({
       where: { id },
       select: {
-        id: true,
-        courseId: true,
-        title: true,
-        slug: true,
-        description: true,
-        titleI18n: true,
-        descriptionI18n: true,
-        order: true,
-        published: true,
-        content: true,
-        videoUrl: true,
-        createdAt: true,
-        updatedAt: true,
-        modules: {
-          where: user.role === 'ADMIN' ? {} : { published: true },
-          orderBy: [{ order: 'asc' }, { id: 'asc' }],
-          select: {
-            id: true,
-            title: true,
-            description: true,
-            titleI18n: true,
-            descriptionI18n: true,
-            order: true,
-            published: true,
-            videos: {
-              where: user.role === 'ADMIN' ? {} : { published: true },
-              orderBy: [{ order: 'asc' }, { id: 'asc' }],
-              select: {
-                id: true,
-                title: true,
-                description: true,
-                titleI18n: true,
-                descriptionI18n: true,
-                sourceUrl: true,
-                hlsPlaylistKey: true,
-                durationSec: true,
-                order: true,
-                published: true,
-              },
-            },
-          },
-        },
+        id: true, courseId: true, title: true, slug: true, description: true, order: true, published: true, content: true, videoUrl: true, createdAt: true, updatedAt: true,
+        translations: { select: { locale: true, title: true, description: true } },
+        modules: { where: user.role === 'ADMIN' ? {} : { published: true }, orderBy: [{ order: 'asc' }, { id: 'asc' }], select: {
+          id: true, title: true, description: true, order: true, published: true,
+          translations: { select: { locale: true, title: true, description: true } },
+          videos: { where: user.role === 'ADMIN' ? {} : { published: true }, orderBy: [{ order: 'asc' }, { id: 'asc' }], select: { id: true, title: true, description: true, sourceUrl: true, hlsPlaylistKey: true, mediaType: true, durationSec: true, order: true, published: true, translations: { select: { locale: true, title: true, description: true } } } },
+        } },
       },
     })
     if (!lesson) throw new NotFoundException('Lesson not found')
-
     await this.enrollments.assertEnrolledOrAdmin(user, lesson.courseId)
-
-    if (user.role !== 'ADMIN' && !lesson.published) {
-      throw new NotFoundException('Lesson not found')
-    }
-
+    if (user.role !== 'ADMIN' && !lesson.published) throw new NotFoundException('Lesson not found')
     if (user.role !== 'ADMIN') {
-      const prev = await this.prisma.lesson.findFirst({
-        where: {
-          courseId: lesson.courseId,
-          published: true,
-          OR: [{ order: { lt: lesson.order ?? 0 } }, { order: lesson.order ?? 0, id: { lt: lesson.id } }],
-        },
-        select: { id: true },
-        orderBy: [{ order: 'desc' }, { id: 'desc' }],
-      })
-
+      const prev = await this.prisma.lesson.findFirst({ where: { courseId: lesson.courseId, published: true, OR: [{ order: { lt: lesson.order ?? 0 } }, { order: lesson.order ?? 0, id: { lt: lesson.id } }] }, select: { id: true }, orderBy: [{ order: 'desc' }, { id: 'desc' }] })
       if (prev) {
-        const prevProgress = await this.prisma.lessonProgress.findUnique({
-          where: { userId_lessonId: { userId: user.sub, lessonId: prev.id } },
-          select: { status: true },
-        })
-        if (!prevProgress || prevProgress.status !== ProgressStatus.COMPLETED) {
-          throw new ForbiddenException('Complete previous lesson first')
-        }
+        const prevProgress = await this.prisma.lessonProgress.findUnique({ where: { userId_lessonId: { userId: user.sub, lessonId: prev.id } }, select: { status: true } })
+        if (!prevProgress || prevProgress.status !== ProgressStatus.COMPLETED) throw new ForbiddenException('Complete previous lesson first')
       }
     }
-
     return lesson
   }

   async create(courseId: number, dto: CreateLessonDto) {
     return this.prisma.$transaction(async (tx) => {
-      const lesson = await tx.lesson.create({
-        data: {
-          courseId,
-          title: dto.title,
-          slug: dto.slug,
-          description: dto.description,
-          titleI18n: dto.titleI18n as any,
-          descriptionI18n: dto.descriptionI18n as any,
-          content: dto.content,
-          videoUrl: dto.videoUrl,
-          order: dto.order,
-          published: dto.published,
-        } as any,
-      })
-
+      const lesson = await tx.lesson.create({ data: { courseId, title: dto.title, slug: dto.slug, description: dto.description, content: dto.content, videoUrl: dto.videoUrl, order: dto.order, published: dto.published } as any })
+      await this.upsertLessonTranslations(tx, lesson.id, dto)
       if (dto.modules?.length) {
         for (const m of dto.modules) {
-          const mod = await tx.lessonModule.create({
-            data: {
-              lessonId: lesson.id,
-              title: m.title,
-              description: m.description,
-              titleI18n: m.titleI18n as any,
-              descriptionI18n: m.descriptionI18n as any,
-              order: m.order,
-              published: m.published,
-            } as any,
-          })
-
+          const mod = await tx.lessonModule.create({ data: { lessonId: lesson.id, title: m.title, description: m.description, order: m.order, published: m.published } as any })
+          await this.upsertModuleTranslations(tx, mod.id, m)
           if (m.videos?.length) {
-            await tx.lessonVideo.createMany({
-              data: m.videos.map((v, idx) => ({
-                moduleId: mod.id,
-                title: v.title,
-                description: v.description,
-                titleI18n: v.titleI18n as any,
-                descriptionI18n: v.descriptionI18n as any,
-                sourceUrl: v.sourceUrl,
-                durationSec: v.durationSec ?? 0,
-                order: v.order ?? idx,
-                published: v.published ?? true,
-              })) as any,
-            })
+            for (const [idx, v] of m.videos.entries()) {
+              const video = await tx.lessonVideo.create({ data: { moduleId: mod.id, title: v.title, description: v.description, sourceUrl: v.sourceUrl, mediaType: v.mediaType === 'IMAGE' ? LessonMediaType.IMAGE : LessonMediaType.VIDEO, durationSec: v.durationSec ?? 0, order: v.order ?? idx, published: v.published ?? true } as any })
+              await this.upsertVideoTranslations(tx, video.id, v)
+            }
           }
         }
       }
-
       return lesson
     })
   }

-  async uploadModuleVideo(lessonId: number, moduleId: string, file: { buffer: Buffer; originalname?: string }) {
+  async uploadModuleMedia(lessonId: number, moduleId: string, type: 'video' | 'image', file: { buffer: Buffer; originalname?: string }) {
     const lesson = await this.prisma.lesson.findUnique({ where: { id: lessonId }, select: { id: true } })
     if (!lesson) throw new NotFoundException('Lesson not found')
-
-    const upload = await this.media.transcodeToHlsAndUpload(file, lessonId, moduleId)
-
-    return {
-      moduleId,
-      lessonId,
-      hlsPlaylistKey: upload.playlistKey,
-      segmentCount: upload.segmentKeys.length,
-      storage: 'private-bucket',
-    }
+    if (type === 'image') return this.media.convertImageToWebpAndUpload(file, lessonId, moduleId)
+    return this.media.transcodeToHlsAndUpload(file, lessonId, moduleId)
   }

   async update(id: number, dto: UpdateLessonDto) {
     return this.prisma.$transaction(async (tx) => {
-      const lesson = await tx.lesson.update({
-        where: { id },
-        data: {
-          title: dto.title,
-          slug: dto.slug,
-          description: dto.description,
-          titleI18n: dto.titleI18n as any,
-          descriptionI18n: dto.descriptionI18n as any,
-          content: dto.content,
-          videoUrl: dto.videoUrl,
-          order: dto.order,
-          published: dto.published,
-        } as any,
-      })
-
+      const lesson = await tx.lesson.update({ where: { id }, data: { title: dto.title, slug: dto.slug, description: dto.description, content: dto.content, videoUrl: dto.videoUrl, order: dto.order, published: dto.published } as any })
+      await this.upsertLessonTranslations(tx, id, dto)
       if (dto.modules) {
+        await tx.lessonVideoTranslation.deleteMany({ where: { video: { module: { lessonId: id } } } as any })
+        await tx.lessonModuleTranslation.deleteMany({ where: { module: { lessonId: id } } as any })
         await tx.lessonVideo.deleteMany({ where: { module: { lessonId: id } } as any })
         await tx.lessonModule.deleteMany({ where: { lessonId: id } })
-
         for (const m of dto.modules) {
-          const mod = await tx.lessonModule.create({
-            data: {
-              lessonId: id,
-              title: m.title,
-              description: m.description,
-              titleI18n: m.titleI18n as any,
-              descriptionI18n: m.descriptionI18n as any,
-              order: m.order,
-              published: m.published,
-            } as any,
-          })
-
-          if (m.videos?.length) {
-            await tx.lessonVideo.createMany({
-              data: m.videos.map((v, idx) => ({
-                moduleId: mod.id,
-                title: v.title,
-                description: v.description,
-                titleI18n: v.titleI18n as any,
-                descriptionI18n: v.descriptionI18n as any,
-                sourceUrl: v.sourceUrl,
-                durationSec: v.durationSec ?? 0,
-                order: v.order ?? idx,
-                published: v.published ?? true,
-              })) as any,
-            })
+          const mod = await tx.lessonModule.create({ data: { lessonId: id, title: m.title, description: m.description, order: m.order, published: m.published } as any })
+          await this.upsertModuleTranslations(tx, mod.id, m)
+          for (const [idx, v] of (m.videos || []).entries()) {
+            const video = await tx.lessonVideo.create({ data: { moduleId: mod.id, title: v.title, description: v.description, sourceUrl: v.sourceUrl, mediaType: v.mediaType === 'IMAGE' ? LessonMediaType.IMAGE : LessonMediaType.VIDEO, durationSec: v.durationSec ?? 0, order: v.order ?? idx, published: v.published ?? true } as any })
+            await this.upsertVideoTranslations(tx, video.id, v)
           }
         }
       }
-
       return lesson
     })
   }

-  remove(id: number) {
-    return this.prisma.lesson.delete({ where: { id } })
+  remove(id: number) { return this.prisma.lesson.delete({ where: { id } }) }
+
+  private async upsertLessonTranslations(tx: any, lessonId: number, dto: any) {
+    for (const locale of ['vi', 'en', 'de']) {
+      const tr = dto.translations?.[locale]
+      const title = tr?.title || (locale === 'vi' ? dto.title : undefined)
+      if (!title) continue
+      await tx.lessonTranslation.upsert({ where: { lessonId_locale: { lessonId, locale } }, update: { title, description: tr?.description || (locale === 'vi' ? dto.description : null) }, create: { lessonId, locale, title, description: tr?.description || (locale === 'vi' ? dto.description : null) } })
+    }
+  }
+  private async upsertModuleTranslations(tx: any, moduleId: number, dto: any) {
+    for (const locale of ['vi', 'en', 'de']) {
+      const tr = dto.translations?.[locale]
+      const title = tr?.title || (locale === 'vi' ? dto.title : undefined)
+      if (!title) continue
+      await tx.lessonModuleTranslation.upsert({ where: { moduleId_locale: { moduleId, locale } }, update: { title, description: tr?.description || (locale === 'vi' ? dto.description : null) }, create: { moduleId, locale, title, description: tr?.description || (locale === 'vi' ? dto.description : null) } })
+    }
+  }
+  private async upsertVideoTranslations(tx: any, videoId: number, dto: any) {
+    for (const locale of ['vi', 'en', 'de']) {
+      const tr = dto.translations?.[locale]
+      const title = tr?.title || (locale === 'vi' ? dto.title : undefined)
+      if (!title) continue
+      await tx.lessonVideoTranslation.upsert({ where: { videoId_locale: { videoId, locale } }, update: { title, description: tr?.description || (locale === 'vi' ? dto.description : null) }, create: { videoId, locale, title, description: tr?.description || (locale === 'vi' ? dto.description : null) } })
+    }
   }
 }
