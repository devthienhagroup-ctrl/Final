diff --git a/backend/ayanavitabackend/app/admin/src/api/productAdmin.api.ts b/backend/ayanavitabackend/app/admin/src/api/productAdmin.api.ts
index 83d759cc460f8b90b0ab7ca9783ef083ce31319b..74241f4b68fff7b361c42ddab9c551cf25fa750b 100644
--- a/backend/ayanavitabackend/app/admin/src/api/productAdmin.api.ts
+++ b/backend/ayanavitabackend/app/admin/src/api/productAdmin.api.ts
@@ -1,130 +1,171 @@
 import { api } from "../lib/http";
 import {
   type AdminLanguage,
   type LanguageCode,
   type ProductAdminItem,
   type ProductAttribute,
   type ProductCategory,
   type ProductIngredient,
   type ProductTranslation,
+  type ProductGuideContent,
 } from "../types/productAdmin";

 const uid = () => Math.random().toString(36).slice(2, 10);

 const slugify = (text: string) =>
   text
     .toLowerCase()
     .trim()
     .normalize("NFD")
     .replace(/[\u0300-\u036f]/g, "")
     .replace(/[^a-z0-9\s-]/g, "")
     .replace(/\s+/g, "-")
     .replace(/-+/g, "-") || `item-${uid()}`;

 const defaultLanguages: AdminLanguage[] = [
   { code: "vi", label: "Tiếng Việt" },
   { code: "en", label: "English" },
   { code: "de", label: "Deutsch" },
 ];

 let languageCache: AdminLanguage[] | null = null;

+const emptyGuideContent = (): ProductGuideContent => ({
+  intro: "",
+  steps: [],
+});
+
+const normalizeGuideContent = (value: unknown): ProductGuideContent => {
+  if (!value || typeof value !== "object") return emptyGuideContent();
+
+  const raw = value as { intro?: unknown; steps?: unknown };
+  const intro = typeof raw.intro === "string" ? raw.intro : "";
+  const steps = Array.isArray(raw.steps)
+    ? raw.steps
+        .map((step) => {
+          if (!step || typeof step !== "object") return null;
+          const s = step as { order?: unknown; content?: unknown };
+          const content = typeof s.content === "string" ? s.content : "";
+          const order = Number(s.order);
+          if (!content) return null;
+          return { order: Number.isFinite(order) && order > 0 ? Math.floor(order) : 1, content };
+        })
+        .filter((step): step is { order: number; content: string } => Boolean(step))
+        .sort((a, b) => a.order - b.order)
+    : [];
+
+  return { intro, steps };
+};
+
 export async function fetchCatalogLanguages(): Promise<AdminLanguage[]> {
   if (languageCache) return languageCache;
   try {
     const rows = await api<Array<{ code: string; name: string }>>("/catalog/languages");
     languageCache =
       rows.map((row) => ({ code: row.code, label: row.name })) || defaultLanguages;
   } catch {
     languageCache = defaultLanguages;
   }
   return languageCache;
 }

 const ensureTranslations = (
   languages: AdminLanguage[],
-  rows: Array<{ languageCode: string; name?: string; shortDescription?: string; description?: string }> = [],
+  rows: Array<{
+    languageCode: string;
+    name?: string;
+    shortDescription?: string;
+    description?: string;
+    guideContent?: unknown;
+  }> = [],
 ): ProductTranslation[] =>
   languages.map((lang) => {
     const found = rows.find((item) => item.languageCode === lang.code);
     return {
       lang: lang.code,
       name: found?.name || "",
       shortDescription: found?.shortDescription || "",
       description: found?.description || "",
+      guideContent: normalizeGuideContent(found?.guideContent),
     };
   });

 type ApiCategory = {
   id: string | number;
   translations?: Array<{ languageCode: string; name: string; description?: string }>;
 };

 type ApiAttributeKey = {
   id: string | number;
   code: string;
   translations?: Array<{ languageCode: string; displayName: string }>;
 };

 type ApiIngredientKey = {
   id: string | number;
   code: string;
   translations?: Array<{ languageCode: string; displayName: string }>;
 };

 const loadAttributeKeys = async (): Promise<Record<string, ApiAttributeKey>> => {
   const rows = await api<ApiAttributeKey[]>("/catalog/attributes");
   return Object.fromEntries(rows.map((item) => [String(item.id), item]));
 };

 const loadIngredientKeys = async (): Promise<Record<string, ApiIngredientKey>> => {
   const rows = await api<ApiIngredientKey[]>("/catalog/ingredients");
   return Object.fromEntries(rows.map((item) => [String(item.id), item]));
 };

 const mapCategory = (item: ApiCategory, languages: AdminLanguage[]): ProductCategory => ({
   id: String(item.id),
   translations: languages.map((lang) => {
     const found = item.translations?.find((row) => row.languageCode === lang.code);
     return {
       lang: lang.code,
       name: found?.name || "",
       description: found?.description || "",
     };
   }),
 });

 type ApiProduct = {
   id: string | number;
   sku: string;
   categoryId?: string | number | null;
   price: number;
   status?: string;
   stock?: number;
   updatedAt?: string;
-  translations?: Array<{ languageCode: string; name: string; shortDescription?: string; description?: string }>;
+  translations?: Array<{
+    languageCode: string;
+    name: string;
+    shortDescription?: string;
+    description?: string;
+    guideContent?: unknown;
+  }>;
   attributes?: Array<{ attributeKeyId: string | number; valueText?: string; valueNumber?: number }>;
   ingredients?: Array<{ ingredientKeyId: string | number; note?: string; value?: string }>;
 };

 const mapProduct = (
   item: ApiProduct,
   languages: AdminLanguage[],
   ingredientKeys: Record<string, ApiIngredientKey> = {},
   attributeKeys: Record<string, ApiAttributeKey> = {},
 ): ProductAdminItem => ({
   id: String(item.id),
   sku: item.sku,
   categoryId: item.categoryId ? String(item.categoryId) : "",
   price: Number(item.price || 0),
   stock: Number(item.stock || 0),
   status: item.status === "active" ? "active" : "draft",
   translations: ensureTranslations(languages, item.translations),
   ingredients: (item.ingredients || []).map((row) => {
     const key = ingredientKeys[String(row.ingredientKeyId)];
     const nameByLang = Object.fromEntries(
       languages.map((lang) => [
         lang.code,
         key?.translations?.find((x) => x.languageCode === lang.code)?.displayName || "",
       ]),
     );
@@ -142,89 +183,91 @@ const mapProduct = (
         lang.code,
         key?.translations?.find((x) => x.languageCode === lang.code)?.displayName || "",
       ]),
     );

     return {
       id: String(row.attributeKeyId),
       keyByLang,
       value: row.valueText || String(row.valueNumber ?? ""),
     };
   }),
   updatedAt: item.updatedAt || new Date().toISOString(),
 });

 const toProductPayload = (item: ProductAdminItem) => ({
   sku: item.sku,
   categoryId: item.categoryId ? Number(item.categoryId) : null,
   price: Number(item.price || 0),
   status: item.status,
   translations: item.translations.map((row) => ({
     languageCode: row.lang,
     name: row.name || "",
     slug: slugify(row.name || `${item.sku}-${row.lang}`),
     shortDescription: row.shortDescription || "",
     description: row.description || "",
+    guideContent: row.guideContent,
   })),
 });

 export async function fetchAdminProducts(): Promise<ProductAdminItem[]> {
   const languages = await fetchCatalogLanguages();
   const [products, ingredientKeys, attributeKeys] = await Promise.all([
     api<ApiProduct[]>("/catalog/products"),
     loadIngredientKeys(),
     loadAttributeKeys(),
   ]);
   return products.map((item) => mapProduct(item, languages, ingredientKeys, attributeKeys));
 }

 export async function fetchAdminProductById(id: string): Promise<ProductAdminItem | null> {
   const languages = await fetchCatalogLanguages();
   try {
     const [item, ingredientKeys, attributeKeys] = await Promise.all([
       api<ApiProduct>(`/catalog/products/${id}`),
       loadIngredientKeys(),
       loadAttributeKeys(),
     ]);
     return mapProduct(item, languages, ingredientKeys, attributeKeys);
   } catch {
     return null;
   }
 }

 export async function createAdminProduct(): Promise<ProductAdminItem> {
   const languages = await fetchCatalogLanguages();
   const payload = {
     sku: `AYA-${uid().toUpperCase()}`,
     price: 0,
     status: "draft",
     translations: languages.map((lang) => ({
       languageCode: lang.code,
       name: "",
       slug: `new-${lang.code}-${uid()}`,
       shortDescription: "",
       description: "",
+      guideContent: emptyGuideContent(),
     })),
   };
   const created = await api<ApiProduct>("/catalog/products", { method: "POST", body: JSON.stringify(payload) });
   return mapProduct(created, languages);
 }

 export async function updateAdminProduct(item: ProductAdminItem): Promise<ProductAdminItem> {
   const languages = await fetchCatalogLanguages();
   const product = await api<ApiProduct>(`/catalog/products/${item.id}`, {
     method: "PATCH",
     body: JSON.stringify(toProductPayload(item)),
   });

   const ingredientKeysByCode = await api<ApiIngredientKey[]>("/catalog/ingredients");
   const ingredientKeyMap = new Map(ingredientKeysByCode.map((k) => [k.code.toLowerCase(), k]));
   const ingredientItems: Array<{ ingredientKeyId: number; note: string; value: string; sortOrder: number }> = [];
   for (const [idx, ingredient] of item.ingredients.entries()) {
     const viName = ingredient.nameByLang.vi || ingredient.nameByLang.en || Object.values(ingredient.nameByLang)[0] || "";
     const code = slugify(viName || `ingredient-${idx}`);
     let key = ingredientKeyMap.get(code);
     if (!key) {
       key = await api<ApiIngredientKey>("/catalog/ingredients", {
         method: "POST",
         body: JSON.stringify({
           code,
@@ -326,32 +369,32 @@ export async function updateAdminCategory(category: ProductCategory): Promise<Pr
     method: "PATCH",
     body: JSON.stringify({
       translations: category.translations.map((row) => ({
         languageCode: row.lang,
         name: row.name,
         slug: slugify(`${row.name || "category"}-${row.lang}`),
         description: row.description || "",
       })),
     }),
   });
   const languages = await fetchCatalogLanguages();
   return mapCategory(updated, languages);
 }

 export async function deleteAdminCategory(categoryId: string): Promise<void> {
   await api(`/catalog/categories/${categoryId}`, { method: "DELETE" });
 }

 export function upsertTranslation(
   translations: ProductTranslation[],
   lang: LanguageCode,
   patch: Partial<ProductTranslation>,
 ): ProductTranslation[] {
   const existing = translations.find((item) => item.lang === lang);
   if (!existing) {
-    return [...translations, { lang, name: "", shortDescription: "", description: "", ...patch }];
+    return [...translations, { lang, name: "", shortDescription: "", description: "", guideContent: emptyGuideContent(), ...patch }];
   }
   return translations.map((item) => (item.lang === lang ? { ...item, ...patch } : item));
 }

 export const createIngredient = (): ProductIngredient => ({ id: uid(), nameByLang: {}, note: "" });
 export const createAttribute = (): ProductAttribute => ({ id: uid(), keyByLang: {}, value: "" });
diff --git a/backend/ayanavitabackend/app/admin/src/pages/ProductAdminDetailPage.tsx b/backend/ayanavitabackend/app/admin/src/pages/ProductAdminDetailPage.tsx
index 70592e8b82334574773c9803772ff8bb964b9df5..8d070ca0950febbeb6f10e50a5c82053aa21d059 100644
--- a/backend/ayanavitabackend/app/admin/src/pages/ProductAdminDetailPage.tsx
+++ b/backend/ayanavitabackend/app/admin/src/pages/ProductAdminDetailPage.tsx
@@ -134,50 +134,176 @@ export function ProductAdminDetailPage() {
             <input
               className="input"
               value={translation?.shortDescription || ""}
               onChange={(e) =>
                 setProduct((prev) =>
                   prev
                     ? { ...prev, translations: upsertTranslation(prev.translations, activeLang, { shortDescription: e.target.value }) }
                     : prev,
                 )
               }
             />
           </label>
           <label>
             <div className="muted">Mô tả chi tiết</div>
             <textarea
               rows={4}
               className="input"
               value={translation?.description || ""}
               onChange={(e) =>
                 setProduct((prev) =>
                   prev ? { ...prev, translations: upsertTranslation(prev.translations, activeLang, { description: e.target.value }) } : prev,
                 )
               }
             />
           </label>
+          <label>
+            <div className="muted">Hướng dẫn sử dụng - Giới thiệu</div>
+            <textarea
+              rows={3}
+              className="input"
+              value={translation?.guideContent?.intro || ""}
+              onChange={(e) =>
+                setProduct((prev) =>
+                  prev
+                    ? {
+                        ...prev,
+                        translations: upsertTranslation(prev.translations, activeLang, {
+                          guideContent: {
+                            intro: e.target.value,
+                            steps: translation?.guideContent?.steps || [],
+                          },
+                        }),
+                      }
+                    : prev,
+                )
+              }
+            />
+          </label>
+
+          <div>
+            <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: 8 }}>
+              <div className="muted">Hướng dẫn sử dụng - Các bước</div>
+              <button
+                className="btn"
+                onClick={() =>
+                  setProduct((prev) => {
+                    if (!prev) return prev;
+                    const current = prev.translations.find((item) => item.lang === activeLang)?.guideContent;
+                    const steps = current?.steps || [];
+                    return {
+                      ...prev,
+                      translations: upsertTranslation(prev.translations, activeLang, {
+                        guideContent: {
+                          intro: current?.intro || "",
+                          steps: [...steps, { order: steps.length + 1, content: "" }],
+                        },
+                      }),
+                    };
+                  })
+                }
+              >
+                + Thêm bước
+              </button>
+            </div>
+
+            <div className="grid" style={{ gap: 8 }}>
+              {(translation?.guideContent?.steps || []).map((step, idx) => (
+                <div key={`${step.order}-${idx}`} className="card" style={{ padding: 10 }}>
+                  <div className="grid grid-2">
+                    <label>
+                      <div className="muted">Thứ tự</div>
+                      <input
+                        type="number"
+                        min={1}
+                        className="input"
+                        value={step.order}
+                        onChange={(e) =>
+                          setProduct((prev) => {
+                            if (!prev) return prev;
+                            const current = prev.translations.find((item) => item.lang === activeLang)?.guideContent;
+                            const steps = (current?.steps || []).map((row, rowIdx) =>
+                              rowIdx === idx ? { ...row, order: Number(e.target.value) || 1 } : row,
+                            );
+                            return {
+                              ...prev,
+                              translations: upsertTranslation(prev.translations, activeLang, {
+                                guideContent: { intro: current?.intro || "", steps },
+                              }),
+                            };
+                          })
+                        }
+                      />
+                    </label>
+                    <label>
+                      <div className="muted">Nội dung bước</div>
+                      <input
+                        className="input"
+                        value={step.content}
+                        onChange={(e) =>
+                          setProduct((prev) => {
+                            if (!prev) return prev;
+                            const current = prev.translations.find((item) => item.lang === activeLang)?.guideContent;
+                            const steps = (current?.steps || []).map((row, rowIdx) =>
+                              rowIdx === idx ? { ...row, content: e.target.value } : row,
+                            );
+                            return {
+                              ...prev,
+                              translations: upsertTranslation(prev.translations, activeLang, {
+                                guideContent: { intro: current?.intro || "", steps },
+                              }),
+                            };
+                          })
+                        }
+                      />
+                    </label>
+                  </div>
+                  <button
+                    className="btn btn-danger"
+                    style={{ marginTop: 8 }}
+                    onClick={() =>
+                      setProduct((prev) => {
+                        if (!prev) return prev;
+                        const current = prev.translations.find((item) => item.lang === activeLang)?.guideContent;
+                        const steps = (current?.steps || [])
+                          .filter((_, rowIdx) => rowIdx !== idx)
+                          .map((row, orderIdx) => ({ ...row, order: orderIdx + 1 }));
+                        return {
+                          ...prev,
+                          translations: upsertTranslation(prev.translations, activeLang, {
+                            guideContent: { intro: current?.intro || "", steps },
+                          }),
+                        };
+                      })
+                    }
+                  >
+                    Xóa bước
+                  </button>
+                </div>
+              ))}
+            </div>
+          </div>
         </div>
       </div>

       <div className="grid grid-2">
         <div className="card">
           <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center" }}>
             <h3 className="h2">CRUD thành phần</h3>
             <button className="btn" onClick={() => setProduct((prev) => (prev ? { ...prev, ingredients: [...prev.ingredients, createIngredient()] } : prev))}>+ Thêm</button>
           </div>
           <div className="grid" style={{ marginTop: 10 }}>
             {product.ingredients.map((item) => (
               <div key={item.id} className="card" style={{ padding: 10 }}>
                 <input
                   className="input"
                   placeholder={`Tên thành phần (${activeLang})`}
                   value={item.nameByLang[activeLang] || ""}
                   onChange={(e) =>
                     setProduct((prev) =>
                       prev
                         ? {
                             ...prev,
                             ingredients: prev.ingredients.map((row) =>
                               row.id === item.id
                                 ? { ...row, nameByLang: { ...row.nameByLang, [activeLang]: e.target.value } }
                                 : row,
diff --git a/backend/ayanavitabackend/app/admin/src/types/productAdmin.ts b/backend/ayanavitabackend/app/admin/src/types/productAdmin.ts
index 414b149a633418d041cda7d3c3860004a287c665..b162bda86e4713a5f10e25f2631e9f3e01f1d94c 100644
--- a/backend/ayanavitabackend/app/admin/src/types/productAdmin.ts
+++ b/backend/ayanavitabackend/app/admin/src/types/productAdmin.ts
@@ -1,37 +1,48 @@
 export type LanguageCode = string;

 export type AdminLanguage = {
   code: LanguageCode;
   label: string;
 };

 export type ProductTranslation = {
   lang: LanguageCode;
   name: string;
   shortDescription: string;
   description: string;
+  guideContent: ProductGuideContent;
+};
+
+export type ProductGuideStep = {
+  order: number;
+  content: string;
+};
+
+export type ProductGuideContent = {
+  intro: string;
+  steps: ProductGuideStep[];
 };

 export type LocalizedTextMap = Record<LanguageCode, string>;

 export type ProductIngredient = {
   id: string;
   nameByLang: LocalizedTextMap;
   note: string;
 };

 export type ProductAttribute = {
   id: string;
   keyByLang: LocalizedTextMap;
   value: string;
 };

 export type CategoryTranslation = {
   lang: LanguageCode;
   name: string;
   description: string;
 };

 export type ProductCategory = {
   id: string;
   translations: CategoryTranslation[];
diff --git a/backend/ayanavitabackend/app/api/prisma/migrations/20260226022000_add_product_translation_guide_content/migration.sql b/backend/ayanavitabackend/app/api/prisma/migrations/20260226022000_add_product_translation_guide_content/migration.sql
new file mode 100644
index 0000000000000000000000000000000000000000..c55074d6c6ee7c2de492a48fb753bb3b5a5d1245
--- /dev/null
+++ b/backend/ayanavitabackend/app/api/prisma/migrations/20260226022000_add_product_translation_guide_content/migration.sql
@@ -0,0 +1,2 @@
+ALTER TABLE `product_translations`
+ADD COLUMN `guide_content` JSON NULL;
diff --git a/backend/ayanavitabackend/app/api/prisma/schema.prisma b/backend/ayanavitabackend/app/api/prisma/schema.prisma
index 42aee322f13c50bc41fe16151bd5a9e9809c970f..df45b6bcea3ef8468faeef6223a605a382e10850 100644
--- a/backend/ayanavitabackend/app/api/prisma/schema.prisma
+++ b/backend/ayanavitabackend/app/api/prisma/schema.prisma
@@ -351,50 +351,51 @@ model CategoryTranslation {

 model CatalogProduct {
   id         BigInt   @id @default(autoincrement())
   sku        String   @unique @db.VarChar(64)
   categoryId BigInt?  @map("category_id")
   price      Decimal  @default(0) @db.Decimal(18, 2)
   status     String   @default("active") @db.VarChar(20)
   createdAt  DateTime @default(now()) @map("created_at")
   updatedAt  DateTime @updatedAt @map("updated_at")

   category     Category? @relation(fields: [categoryId], references: [id], onDelete: SetNull)
   translations ProductTranslation[]
   attributes   ProductAttribute[]
   ingredients  ProductIngredient[]

   @@map("products")
 }

 model ProductTranslation {
   productId         BigInt @map("product_id")
   languageCode      String @map("language_code") @db.VarChar(10)
   name              String @db.VarChar(255)
   slug              String @db.VarChar(255)
   shortDescription  String? @map("short_description") @db.VarChar(500)
   description       String? @db.Text
+  guideContent      Json?   @map("guide_content")

   product  CatalogProduct @relation(fields: [productId], references: [id], onDelete: Cascade)
   language Language       @relation(fields: [languageCode], references: [code], onDelete: Restrict)

   @@id([productId, languageCode])
   @@unique([languageCode, slug], map: "uq_product_slug_per_lang")
   @@index([languageCode], map: "idx_product_translation_lang")
   @@map("product_translations")
 }

 model AttributeKey {
   id        BigInt  @id @default(autoincrement())
   code      String  @unique @db.VarChar(100)
   valueType String  @default("text") @map("value_type") @db.VarChar(20)
   isActive  Boolean @default(true) @map("is_active")

   translations AttributeKeyTranslation[]
   products     ProductAttribute[]

   @@map("attribute_keys")
 }

 model AttributeKeyTranslation {
   attributeKeyId BigInt @map("attribute_key_id")
   languageCode   String @map("language_code") @db.VarChar(10)
diff --git a/backend/ayanavitabackend/app/api/src/catalog/dto/product.dto.ts b/backend/ayanavitabackend/app/api/src/catalog/dto/product.dto.ts
index c08c96e133163aa3ab7c2acaef65ba9d9c0b5fae..9fba626ce7b2110c7009d62504c1f80d266f0a8a 100644
--- a/backend/ayanavitabackend/app/api/src/catalog/dto/product.dto.ts
+++ b/backend/ayanavitabackend/app/api/src/catalog/dto/product.dto.ts
@@ -1,60 +1,88 @@
 import { Type } from 'class-transformer'
 import {
   IsArray,
   IsInt,
   IsNotEmpty,
   IsNumber,
   IsOptional,
   IsString,
   MaxLength,
+  Min,
   ValidateNested,
 } from 'class-validator'

+export class ProductGuideStepDto {
+  @Type(() => Number)
+  @IsInt()
+  @Min(1)
+  order!: number
+
+  @IsString()
+  @IsNotEmpty()
+  content!: string
+}
+
+export class ProductGuideContentDto {
+  @IsString()
+  @IsNotEmpty()
+  intro!: string
+
+  @IsArray()
+  @ValidateNested({ each: true })
+  @Type(() => ProductGuideStepDto)
+  steps!: ProductGuideStepDto[]
+}
+
 export class ProductTranslationDto {
   @IsString()
   @MaxLength(10)
   languageCode!: string

   @IsString()
   @IsNotEmpty()
   @MaxLength(255)
   name!: string

   @IsString()
   @IsNotEmpty()
   @MaxLength(255)
   slug!: string

   @IsOptional()
   @IsString()
   @MaxLength(500)
   shortDescription?: string

   @IsOptional()
   @IsString()
   description?: string
+
+  @IsOptional()
+  @ValidateNested()
+  @Type(() => ProductGuideContentDto)
+  guideContent?: ProductGuideContentDto
 }

 export class CreateProductDto {
   @IsString()
   @MaxLength(64)
   sku!: string

   @IsOptional()
   @Type(() => Number)
   @IsInt()
   categoryId?: number

   @Type(() => Number)
   @IsNumber()
   price!: number

   @IsOptional()
   @IsString()
   @MaxLength(20)
   status?: string

   @IsArray()
   @ValidateNested({ each: true })
   @Type(() => ProductTranslationDto)
   translations!: ProductTranslationDto[]
diff --git a/backend/ayanavitabackend/app/api/src/catalog/products.service.ts b/backend/ayanavitabackend/app/api/src/catalog/products.service.ts
index 2f99c029b1578dcdb243d5e1582c72d10bc270aa..8a49553a923a34479ff30fedf789fa27e0fcb010 100644
--- a/backend/ayanavitabackend/app/api/src/catalog/products.service.ts
+++ b/backend/ayanavitabackend/app/api/src/catalog/products.service.ts
@@ -1,81 +1,105 @@
 import { Injectable, NotFoundException } from '@nestjs/common'
 import { PrismaService } from '../prisma/prisma.service'
 import { CreateProductDto, UpdateProductDto } from './dto/product.dto'
 import { UpsertProductAttributesDto, UpsertProductIngredientsDto } from './dto/product-metadata.dto'
 import { normalizeBigInt } from './utils'

+const toProductTranslationCreateManyData = (
+  productId: number,
+  translations: CreateProductDto['translations'] | UpdateProductDto['translations'],
+) =>
+  (translations ?? []).map((translation) => ({
+    productId: BigInt(productId),
+    languageCode: translation.languageCode,
+    name: translation.name,
+    slug: translation.slug,
+    shortDescription: translation.shortDescription,
+    description: translation.description,
+    guideContent: translation.guideContent,
+  }))
+
 @Injectable()
 export class ProductsService {
   constructor(private readonly prisma: PrismaService) {}

   async findAll() {
     const rows = await this.prisma.catalogProduct.findMany({
       include: { translations: true, category: true },
       orderBy: { id: 'desc' },
     })
     return normalizeBigInt(rows)
   }

   async findOne(id: number) {
     const row = await this.prisma.catalogProduct.findUnique({
       where: { id: BigInt(id) },
       include: { translations: true, category: true, attributes: true, ingredients: true },
     })
     if (!row) throw new NotFoundException('Product not found')
     return normalizeBigInt(row)
   }

   async create(dto: CreateProductDto) {
-    const row = await this.prisma.catalogProduct.create({
-      data: {
-        sku: dto.sku,
-        categoryId: dto.categoryId ? BigInt(dto.categoryId) : null,
-        price: dto.price,
-        status: dto.status ?? 'active',
-        translations: { create: dto.translations },
-      },
-      include: { translations: true, category: true },
+    const row = await this.prisma.$transaction(async (tx) => {
+      const createdProduct = await tx.catalogProduct.create({
+        data: {
+          sku: dto.sku,
+          categoryId: dto.categoryId ? BigInt(dto.categoryId) : null,
+          price: dto.price,
+          status: dto.status ?? 'active',
+        },
+      })
+
+      await tx.productTranslation.createMany({
+        data: toProductTranslationCreateManyData(Number(createdProduct.id), dto.translations),
+      })
+
+      return tx.catalogProduct.findUniqueOrThrow({
+        where: { id: createdProduct.id },
+        include: { translations: true, category: true },
+      })
     })
+
     return normalizeBigInt(row)
   }

   async update(id: number, dto: UpdateProductDto) {
     await this.findOne(id)
     const row = await this.prisma.$transaction(async (tx) => {
       if (dto.translations) {
         await tx.productTranslation.deleteMany({ where: { productId: BigInt(id) } })
+        await tx.productTranslation.createMany({ data: toProductTranslationCreateManyData(id, dto.translations) })
       }

       return tx.catalogProduct.update({
         where: { id: BigInt(id) },
         data: {
           sku: dto.sku,
           categoryId: dto.categoryId === undefined ? undefined : dto.categoryId === null ? null : BigInt(dto.categoryId),
           price: dto.price,
           status: dto.status,
-          translations: dto.translations ? { create: dto.translations } : undefined,
         },
         include: { translations: true, category: true },
       })
     })
     return normalizeBigInt(row)
   }

   async replaceAttributes(id: number, dto: UpsertProductAttributesDto) {
     await this.findOne(id)
     const rows = await this.prisma.$transaction(async (tx) => {
       await tx.productAttribute.deleteMany({ where: { productId: BigInt(id) } })
       if (dto.items.length) {
         await tx.productAttribute.createMany({
           data: dto.items.map((item) => ({
             productId: BigInt(id),
             attributeKeyId: BigInt(item.attributeKeyId),
             valueText: item.valueText,
             valueNumber: item.valueNumber,
             valueBoolean: item.valueBoolean,
             valueJson: item.valueJson,
           })),
         })
       }
       return tx.productAttribute.findMany({ where: { productId: BigInt(id) } })
     })
