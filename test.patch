diff --git a/ayanavita-fontend/src/api/adminCourses.api.ts b/ayanavita-fontend/src/api/adminCourses.api.ts
index 7a0eb527064549e6a25ff3235318c1c7a43086b3..2a2394c1639bad9f358ea683613b32031815aabf 100644
--- a/ayanavita-fontend/src/api/adminCourses.api.ts
+++ b/ayanavita-fontend/src/api/adminCourses.api.ts
@@ -1,83 +1,78 @@
 import { del, get, patch, post } from './http'

 export type CourseTopicTranslations = Record<string, { name?: string; description?: string | null }>

 export type CourseTopic = {
   id: number
   name: string
   description?: string | null
   translations?: CourseTopicTranslations
   _count?: { courses: number }
 }

 export type LocalizedText = { vi?: string; en?: string; de?: string }

 export type LessonVideoPayload = {
   title: string
   description?: string
   translations?: Record<string, { title: string; shortDescription?: string; description?: string }>
   sourceUrl?: string
   durationSec?: number
-  order?: number
-  published?: boolean
+  stt: number
 }

 export type LessonModulePayload = {
   title: string
   description?: string
   translations?: Record<string, { title: string; shortDescription?: string; description?: string }>
-  order?: number
-  published?: boolean
+  stt: number
   videos?: LessonVideoPayload[]
 }

 export type LessonPayload = {
   title: string
   slug: string
   description?: string
   translations?: Record<string, { title: string; description?: string }>
   content?: string
-  videoUrl?: string
   modules?: LessonModulePayload[]
-  order?: number
-  published?: boolean
+  stt: number
 }

 export type LessonVideoAdmin = LessonVideoPayload & { id: number; hlsPlaylistKey?: string }
 export type LessonModuleAdmin = LessonModulePayload & { id: number; videos: LessonVideoAdmin[] }

 export type LessonAdmin = {
   id: number
   courseId: number
   title: string
   slug: string
   description?: string
   translations?: Record<string, { title: string; description?: string }>
   content?: string
-  order?: number
-  published: boolean
+  stt: number
   createdAt?: string
   updatedAt?: string
 }

 export type LessonDetailAdmin = LessonAdmin & { modules: LessonModuleAdmin[] }

 export type CourseAdmin = {
   id: number
   topicId?: number | null
   title: string
   shortDescription?: string | null
   slug: string
   description?: string | null
   thumbnail?: string | null
   published: boolean
   price: number
   topic?: { id: number; name: string } | null
   translations?: Record<string, { title: string; description?: string }>
   objectives?: string[]
   targetAudience?: string[]
   benefits?: string[]
   contentTranslations?: Record<string, { objectives?: string[]; targetAudience?: string[]; benefits?: string[] }>
   ratingAvg?: number
   ratingCount?: number
   enrollmentCount?: number
@@ -128,39 +123,44 @@ export type CourseDetailAdmin = CourseAdmin
 export const adminCoursesApi = {
   listTopics: () => get<CourseTopic[]>('/admin/course-topics', { auth: true }),
   createTopic: (body: TopicPayload) => post<CourseTopic>('/admin/course-topics', body, { auth: true }),
   updateTopic: (id: number, body: TopicPayload) => patch<CourseTopic>(`/admin/course-topics/${id}`, body, { auth: true }),
   deleteTopic: (id: number) => del<{ id: number }>(`/admin/course-topics/${id}`, { auth: true }),
   listCourses: (params?: { topicId?: number; search?: string; page?: number; pageSize?: number; lang?: string }) => {
     const qs = new URLSearchParams()
     if (params?.topicId) qs.set('topicId', String(params.topicId))
     if (params?.search?.trim()) qs.set('search', params.search.trim())
     if (params?.page) qs.set('page', String(params.page))
     if (params?.pageSize) qs.set('pageSize', String(params.pageSize))
     if (params?.lang) qs.set('lang', params.lang)
     const suffix = qs.toString() ? `?${qs.toString()}` : ''
     return get<CourseListResponse>(`/courses${suffix}`, { auth: true })
   },
   createCourse: (body: CoursePayload | FormData) => post<CourseAdmin>('/courses', body, { auth: true }),
   updateCourse: (id: number, body: Partial<CoursePayload> | FormData) => patch<CourseAdmin>(`/courses/${id}`, body, { auth: true }),
   deleteCourse: (id: number) => del<{ id: number }>(`/courses/${id}`, { auth: true }),
   getCourseDetail: (id: number, lang?: string) => {
     const qs = new URLSearchParams()
     if (lang) qs.set('lang', lang)
     const suffix = qs.toString() ? `?${qs.toString()}` : ''
     return get<CourseDetailAdmin>(`/courses/${id}${suffix}`, { auth: true })
   },

-  listCourseLessons: (courseId: number) => get<LessonAdmin[]>(`/courses/${courseId}/lessons-outline`, { auth: true }),
+  listCourseLessons: (courseId: number, lang?: string) => {
+    const qs = new URLSearchParams()
+    if (lang) qs.set('lang', lang)
+    const suffix = qs.toString() ? `?${qs.toString()}` : ''
+    return get<LessonAdmin[]>(`/courses/${courseId}/lessons-outline${suffix}`, { auth: true })
+  },
   getLessonDetail: (lessonId: number) => get<LessonDetailAdmin>(`/lessons/${lessonId}`, { auth: true }),
   createLesson: (courseId: number, body: LessonPayload) => post<LessonAdmin>(`/courses/${courseId}/lessons`, body, { auth: true }),
   updateLesson: (lessonId: number, body: Partial<LessonPayload>) => patch<LessonAdmin>(`/lessons/${lessonId}`, body, { auth: true }),
   deleteLesson: (lessonId: number) => del<{ id: number }>(`/lessons/${lessonId}`, { auth: true }),

-  uploadModuleMedia: (lessonId: number, moduleId: string | number, file: File, type: 'video' | 'image', order?: number) => {
+  uploadModuleMedia: (lessonId: number, moduleId: string | number, file: File, type: 'video' | 'image', stt?: number) => {
     const body = new FormData()
     body.append('file', file)
     body.append('type', type)
-    if (order !== undefined) body.append('order', String(order))
+    if (stt !== undefined) body.append('stt', String(stt))
     return post<{ moduleId?: string; lessonId?: number; hlsPlaylistKey?: string; segmentCount?: number; imageKey?: string; sourceUrl?: string; storage: string; videoId?: number }>(`/lessons/${lessonId}/modules/${moduleId}/media/upload`, body, { auth: true })
   },
 }
diff --git a/ayanavita-fontend/src/pages/admin/courseTabs/courseDetail/CourseDetailTabs.tsx b/ayanavita-fontend/src/pages/admin/courseTabs/courseDetail/CourseDetailTabs.tsx
index fdca5ad86d362ca59053425e4374bfc1abc82d98..f9e043ebcf67ea3207aa064cef8a43d08a4f0456 100644
--- a/ayanavita-fontend/src/pages/admin/courseTabs/courseDetail/CourseDetailTabs.tsx
+++ b/ayanavita-fontend/src/pages/admin/courseTabs/courseDetail/CourseDetailTabs.tsx
@@ -1,66 +1,42 @@
 import { useMemo, useState } from 'react'
 import { type CourseDetailAdmin, type CourseTopic } from '../../../../api/adminCourses.api'
 import { CourseDetailInfoTab } from './CourseDetailInfoTab'
+import { CourseLessonListTab } from './CourseLessonListTab'

 type Props = {
   course: CourseDetailAdmin
   lang: 'vi' | 'en' | 'de'
   text: Record<string, string>
   topics: CourseTopic[]
   onCourseUpdated: () => Promise<void> | void
 }

-type DetailTabKey = 'info' | 'content'
+type DetailTabKey = 'info' | 'lessons'

 export function CourseDetailTabs({ course, lang, text, topics, onCourseUpdated }: Props) {
   const [activeTab, setActiveTab] = useState<DetailTabKey>('info')

-  const localizedContent = useMemo(() => ({
-    objectives: course.objectives || [],
-    targetAudience: course.targetAudience || [],
-    benefits: course.benefits || [],
-  }), [course])
+  const lessonTabLabel = useMemo(() => (lang === 'vi' ? 'Danh sách bài học' : lang === 'en' ? 'Lesson list' : 'Lektionsliste'), [lang])

   return (
     <section>
       <div className='admin-tabs' style={{ marginBottom: 10 }}>
         <button className={`admin-tab ${activeTab === 'info' ? 'active' : ''}`} type='button' onClick={() => setActiveTab('info')}>
           <i className='fa-solid fa-circle-info' />{' '}
           {lang === 'vi'
               ? 'Thông tin khóa học'
               : lang === 'en'
                   ? 'Course Information'
                   : 'Kursinformationen'}
         </button>
-        <button className={`admin-tab ${activeTab === 'content' ? 'active' : ''}`} type='button' onClick={() => setActiveTab('content')}>
-          <i className='fa-solid fa-list-check' /> {lang === 'vi' ? 'Nội dung mở rộng' : lang === 'en' ? 'Extended content' : 'Erweiterte Inhalte'}
+        <button className={`admin-tab ${activeTab === 'lessons' ? 'active' : ''}`} type='button' onClick={() => setActiveTab('lessons')}>
+          <i className='fa-solid fa-list-check' /> {lessonTabLabel}
         </button>
       </div>

       {activeTab === 'info' && <CourseDetailInfoTab course={course} text={text} lang={lang} topics={topics} onUpdated={onCourseUpdated} />}

-      {activeTab === 'content' && (
-        <div className='admin-row' style={{ alignItems: 'flex-start', gap: 16, flexWrap: 'wrap' }}>
-          <div className='admin-card' style={{ flex: 1, minWidth: 240 }}>
-            <h4>Objectives</h4>
-            <ul>
-              {localizedContent.objectives.length ? localizedContent.objectives.map((item, idx) => <li key={`${item}-${idx}`}>{item}</li>) : <li>--</li>}
-            </ul>
-          </div>
-          <div className='admin-card' style={{ flex: 1, minWidth: 240 }}>
-            <h4>Target audience</h4>
-            <ul>
-              {localizedContent.targetAudience.length ? localizedContent.targetAudience.map((item, idx) => <li key={`${item}-${idx}`}>{item}</li>) : <li>--</li>}
-            </ul>
-          </div>
-          <div className='admin-card' style={{ flex: 1, minWidth: 240 }}>
-            <h4>Benefits</h4>
-            <ul>
-              {localizedContent.benefits.length ? localizedContent.benefits.map((item, idx) => <li key={`${item}-${idx}`}>{item}</li>) : <li>--</li>}
-            </ul>
-          </div>
-        </div>
-      )}
+      {activeTab === 'lessons' && <CourseLessonListTab course={course} lang={lang} onUpdated={onCourseUpdated} />}
     </section>
   )
 }
diff --git a/ayanavita-fontend/src/pages/admin/courseTabs/courseDetail/CourseLessonListTab.tsx b/ayanavita-fontend/src/pages/admin/courseTabs/courseDetail/CourseLessonListTab.tsx
new file mode 100644
index 0000000000000000000000000000000000000000..ce052babac6efe6d374c792e1c044d4bf5dbe128
--- /dev/null
+++ b/ayanavita-fontend/src/pages/admin/courseTabs/courseDetail/CourseLessonListTab.tsx
@@ -0,0 +1,60 @@
+import { useEffect, useMemo, useState } from 'react'
+import { adminCoursesApi, type LessonAdmin } from '../../../../api/adminCourses.api'
+import type { CourseDetailAdmin } from '../../../../api/adminCourses.api'
+import { CreateLessonModal } from './CreateLessonModal'
+
+type Props = {
+  course: CourseDetailAdmin
+  lang: 'vi' | 'en' | 'de'
+  onUpdated: () => Promise<void> | void
+}
+
+export function CourseLessonListTab({ course, lang, onUpdated }: Props) {
+  const [items, setItems] = useState<LessonAdmin[]>([])
+  const [loading, setLoading] = useState(false)
+  const [open, setOpen] = useState(false)
+
+  const t = useMemo(() => {
+    if (lang === 'en') return { title: 'Lesson list', add: 'Add lesson', empty: 'No lessons yet' }
+    if (lang === 'de') return { title: 'Lektionsliste', add: 'Lektion hinzufügen', empty: 'Noch keine Lektionen' }
+    return { title: 'Danh sách bài học', add: 'Thêm bài học mới', empty: 'Chưa có bài học' }
+  }, [lang])
+
+  const load = async () => {
+    setLoading(true)
+    try {
+      const rows = await adminCoursesApi.listCourseLessons(course.id, lang)
+      setItems(rows)
+    } finally {
+      setLoading(false)
+    }
+  }
+
+  useEffect(() => {
+    void load()
+  }, [course.id, lang])
+
+  return (
+    <div className='admin-card'>
+      <div className='admin-row' style={{ justifyContent: 'space-between' }}>
+        <h4>{t.title}</h4>
+        <button type='button' className='admin-btn' onClick={() => setOpen(true)}>{t.add}</button>
+      </div>
+      {loading ? <p>Loading...</p> : (
+        <ul>
+          {items.length ? items.map((item) => <li key={item.id}>{item.stt}. {item.title}</li>) : <li>{t.empty}</li>}
+        </ul>
+      )}
+      <CreateLessonModal
+        open={open}
+        lang={lang}
+        courseId={course.id}
+        onClose={() => setOpen(false)}
+        onCreated={async () => {
+          await load()
+          await onUpdated()
+        }}
+      />
+    </div>
+  )
+}
diff --git a/ayanavita-fontend/src/pages/admin/courseTabs/courseDetail/CreateLessonModal.tsx b/ayanavita-fontend/src/pages/admin/courseTabs/courseDetail/CreateLessonModal.tsx
new file mode 100644
index 0000000000000000000000000000000000000000..51c771f09301db02e39ae33edd2461c5d1c5faaa
--- /dev/null
+++ b/ayanavita-fontend/src/pages/admin/courseTabs/courseDetail/CreateLessonModal.tsx
@@ -0,0 +1,134 @@
+import { useMemo, useState } from 'react'
+import { adminCoursesApi, type LessonPayload } from '../../../../api/adminCourses.api'
+
+type AdminLang = 'vi' | 'en' | 'de'
+
+type Props = {
+  open: boolean
+  lang: AdminLang
+  courseId: number
+  onClose: () => void
+  onCreated: () => Promise<void> | void
+}
+
+type I18n = Record<AdminLang, string>
+
+const emptyI18n = (): I18n => ({ vi: '', en: '', de: '' })
+const slugify = (input: string) => input.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '').replace(/[^a-z0-9\s-]/g, '').trim().replace(/\s+/g, '-')
+
+export function CreateLessonModal({ open, lang, courseId, onClose, onCreated }: Props) {
+  const [submitting, setSubmitting] = useState(false)
+  const [error, setError] = useState('')
+  const [lessonStt, setLessonStt] = useState('1')
+  const [lessonTitle, setLessonTitle] = useState<I18n>(() => emptyI18n())
+  const [lessonDescription, setLessonDescription] = useState<I18n>(() => emptyI18n())
+  const [moduleStt, setModuleStt] = useState('1')
+  const [moduleTitle, setModuleTitle] = useState<I18n>(() => emptyI18n())
+  const [moduleDescription, setModuleDescription] = useState<I18n>(() => emptyI18n())
+  const [videoStt, setVideoStt] = useState('1')
+  const [videoTitle, setVideoTitle] = useState<I18n>(() => emptyI18n())
+  const [videoDescription, setVideoDescription] = useState<I18n>(() => emptyI18n())
+  const [videoSource, setVideoSource] = useState('')
+
+  const t = useMemo(() => {
+    if (lang === 'en') return { title: 'Create lesson', create: 'Create', close: 'Close', invalid: 'Please fill all required fields for lesson, module, and video/image.' }
+    if (lang === 'de') return { title: 'Lektion erstellen', create: 'Erstellen', close: 'Schließen', invalid: 'Bitte alle Pflichtfelder für Lektion, Modul und Video/Bild ausfüllen.' }
+    return { title: 'Tạo bài học', create: 'Tạo mới', close: 'Đóng', invalid: 'Vui lòng nhập đầy đủ thông tin bài học, module và video/ảnh.' }
+  }, [lang])
+
+  const reset = () => {
+    setError('')
+    setLessonStt('1'); setModuleStt('1'); setVideoStt('1')
+    setLessonTitle(emptyI18n()); setLessonDescription(emptyI18n())
+    setModuleTitle(emptyI18n()); setModuleDescription(emptyI18n())
+    setVideoTitle(emptyI18n()); setVideoDescription(emptyI18n())
+    setVideoSource('')
+  }
+
+  if (!open) return null
+
+  const submit = async () => {
+    if (!lessonTitle.vi.trim() || !moduleTitle.vi.trim() || !videoTitle.vi.trim() || !videoSource.trim()) {
+      setError(t.invalid)
+      return
+    }
+    const sttLesson = Number(lessonStt)
+    const sttModule = Number(moduleStt)
+    const sttVideo = Number(videoStt)
+    if (!Number.isFinite(sttLesson) || !Number.isFinite(sttModule) || !Number.isFinite(sttVideo)) {
+      setError(t.invalid)
+      return
+    }
+
+    const payload: LessonPayload = {
+      title: lessonTitle.vi,
+      slug: slugify(lessonTitle.vi),
+      description: lessonDescription.vi || undefined,
+      stt: sttLesson,
+      translations: {
+        vi: { title: lessonTitle.vi, description: lessonDescription.vi || undefined },
+        en: { title: lessonTitle.en || lessonTitle.vi, description: lessonDescription.en || undefined },
+        de: { title: lessonTitle.de || lessonTitle.vi, description: lessonDescription.de || undefined },
+      },
+      modules: [{
+        title: moduleTitle.vi,
+        description: moduleDescription.vi || undefined,
+        stt: sttModule,
+        translations: {
+          vi: { title: moduleTitle.vi, description: moduleDescription.vi || undefined },
+          en: { title: moduleTitle.en || moduleTitle.vi, description: moduleDescription.en || undefined },
+          de: { title: moduleTitle.de || moduleTitle.vi, description: moduleDescription.de || undefined },
+        },
+        videos: [{
+          title: videoTitle.vi,
+          description: videoDescription.vi || undefined,
+          stt: sttVideo,
+          sourceUrl: videoSource,
+          translations: {
+            vi: { title: videoTitle.vi, description: videoDescription.vi || undefined },
+            en: { title: videoTitle.en || videoTitle.vi, description: videoDescription.en || undefined },
+            de: { title: videoTitle.de || videoTitle.vi, description: videoDescription.de || undefined },
+          },
+        }],
+      }],
+    }
+
+    setSubmitting(true)
+    try {
+      await adminCoursesApi.createLesson(courseId, payload)
+      await onCreated()
+      reset()
+      onClose()
+    } catch (e: any) {
+      setError(e?.message || t.invalid)
+    } finally {
+      setSubmitting(false)
+    }
+  }
+
+  return (
+    <div className='admin-modal-backdrop' role='dialog' aria-modal='true' onClick={() => { reset(); onClose() }}>
+      <div className='admin-modal create-course-modal' onClick={(e) => e.stopPropagation()}>
+        <div className='admin-modal-header'><h3>{t.title}</h3></div>
+        <div className='admin-modal-body'>
+          {error ? <p style={{ color: 'crimson' }}>{error}</p> : null}
+          <div className='admin-grid-2'>
+            <input className='admin-input' placeholder='STT lesson *' value={lessonStt} onChange={(e) => setLessonStt(e.target.value)} />
+            <input className='admin-input' placeholder='Lesson title VI *' value={lessonTitle.vi} onChange={(e) => setLessonTitle((p) => ({ ...p, vi: e.target.value }))} />
+            <input className='admin-input' placeholder='Lesson title EN' value={lessonTitle.en} onChange={(e) => setLessonTitle((p) => ({ ...p, en: e.target.value }))} />
+            <input className='admin-input' placeholder='Lesson title DE' value={lessonTitle.de} onChange={(e) => setLessonTitle((p) => ({ ...p, de: e.target.value }))} />
+            <input className='admin-input' placeholder='STT module *' value={moduleStt} onChange={(e) => setModuleStt(e.target.value)} />
+            <input className='admin-input' placeholder='Module title VI *' value={moduleTitle.vi} onChange={(e) => setModuleTitle((p) => ({ ...p, vi: e.target.value }))} />
+            <input className='admin-input' placeholder='STT video/image *' value={videoStt} onChange={(e) => setVideoStt(e.target.value)} />
+            <input className='admin-input' placeholder='Video/Image title VI *' value={videoTitle.vi} onChange={(e) => setVideoTitle((p) => ({ ...p, vi: e.target.value }))} />
+            <input className='admin-input' placeholder='Video/Image source URL *' value={videoSource} onChange={(e) => setVideoSource(e.target.value)} />
+          </div>
+        </div>
+        <div className='admin-modal-footer'>
+          <button type='button' className='admin-btn secondary' onClick={() => { reset(); onClose() }}>{t.close}</button>
+          <button type='button' className='admin-btn' onClick={submit} disabled={submitting}>{submitting ? '...' : t.create}</button>
+        </div>
+      </div>
+    </div>
+  )
+}
diff --git a/backend/ayanavitabackend/app/api/prisma/migrations/202603110001_lesson_stt_refactor/migration.sql b/backend/ayanavitabackend/app/api/prisma/migrations/202603110001_lesson_stt_refactor/migration.sql
new file mode 100644
index 0000000000000000000000000000000000000000..fc36a971cefbecddf6f7be08a3d24f69f0f7bb26
--- /dev/null
+++ b/backend/ayanavitabackend/app/api/prisma/migrations/202603110001_lesson_stt_refactor/migration.sql
@@ -0,0 +1,217 @@
+-- Make migration resilient across MySQL variants (including versions
+-- that do not support IF EXISTS/IF NOT EXISTS in DDL directly).
+-- We use information_schema checks + dynamic SQL.
+
+-- =========================
+-- Drop legacy indexes first
+-- =========================
+SET @sql := IF(
+  EXISTS (
+    SELECT 1
+    FROM information_schema.statistics
+    WHERE table_schema = DATABASE()
+      AND table_name = 'Lesson'
+      AND index_name = 'Lesson_courseId_order_idx'
+  ),
+  'DROP INDEX `Lesson_courseId_order_idx` ON `Lesson`',
+  'SELECT 1'
+);
+PREPARE stmt FROM @sql; EXECUTE stmt; DEALLOCATE PREPARE stmt;
+
+SET @sql := IF(
+  EXISTS (
+    SELECT 1
+    FROM information_schema.statistics
+    WHERE table_schema = DATABASE()
+      AND table_name = 'LessonModule'
+      AND index_name = 'LessonModule_lessonId_order_idx'
+  ),
+  'DROP INDEX `LessonModule_lessonId_order_idx` ON `LessonModule`',
+  'SELECT 1'
+);
+PREPARE stmt FROM @sql; EXECUTE stmt; DEALLOCATE PREPARE stmt;
+
+SET @sql := IF(
+  EXISTS (
+    SELECT 1
+    FROM information_schema.statistics
+    WHERE table_schema = DATABASE()
+      AND table_name = 'LessonVideo'
+      AND index_name = 'LessonVideo_moduleId_order_idx'
+  ),
+  'DROP INDEX `LessonVideo_moduleId_order_idx` ON `LessonVideo`',
+  'SELECT 1'
+);
+PREPARE stmt FROM @sql; EXECUTE stmt; DEALLOCATE PREPARE stmt;
+
+-- =========================
+-- Lesson table
+-- =========================
+SET @sql := IF(
+  EXISTS (
+    SELECT 1
+    FROM information_schema.columns
+    WHERE table_schema = DATABASE()
+      AND table_name = 'Lesson'
+      AND column_name = 'videoUrl'
+  ),
+  'ALTER TABLE `Lesson` DROP COLUMN `videoUrl`',
+  'SELECT 1'
+);
+PREPARE stmt FROM @sql; EXECUTE stmt; DEALLOCATE PREPARE stmt;
+
+SET @sql := IF(
+  EXISTS (
+    SELECT 1
+    FROM information_schema.columns
+    WHERE table_schema = DATABASE()
+      AND table_name = 'Lesson'
+      AND column_name = 'order'
+  ),
+  'ALTER TABLE `Lesson` DROP COLUMN `order`',
+  'SELECT 1'
+);
+PREPARE stmt FROM @sql; EXECUTE stmt; DEALLOCATE PREPARE stmt;
+
+SET @sql := IF(
+  EXISTS (
+    SELECT 1
+    FROM information_schema.columns
+    WHERE table_schema = DATABASE()
+      AND table_name = 'Lesson'
+      AND column_name = 'published'
+  ),
+  'ALTER TABLE `Lesson` DROP COLUMN `published`',
+  'SELECT 1'
+);
+PREPARE stmt FROM @sql; EXECUTE stmt; DEALLOCATE PREPARE stmt;
+
+SET @sql := IF(
+  EXISTS (
+    SELECT 1
+    FROM information_schema.columns
+    WHERE table_schema = DATABASE()
+      AND table_name = 'Lesson'
+      AND column_name = 'stt'
+  ),
+  'SELECT 1',
+  'ALTER TABLE `Lesson` ADD COLUMN `stt` INT NOT NULL DEFAULT 0'
+);
+PREPARE stmt FROM @sql; EXECUTE stmt; DEALLOCATE PREPARE stmt;
+
+-- =========================
+-- LessonModule table
+-- =========================
+SET @sql := IF(
+  EXISTS (
+    SELECT 1
+    FROM information_schema.columns
+    WHERE table_schema = DATABASE()
+      AND table_name = 'LessonModule'
+      AND column_name = 'order'
+  ),
+  'ALTER TABLE `LessonModule` DROP COLUMN `order`',
+  'SELECT 1'
+);
+PREPARE stmt FROM @sql; EXECUTE stmt; DEALLOCATE PREPARE stmt;
+
+SET @sql := IF(
+  EXISTS (
+    SELECT 1
+    FROM information_schema.columns
+    WHERE table_schema = DATABASE()
+      AND table_name = 'LessonModule'
+      AND column_name = 'published'
+  ),
+  'ALTER TABLE `LessonModule` DROP COLUMN `published`',
+  'SELECT 1'
+);
+PREPARE stmt FROM @sql; EXECUTE stmt; DEALLOCATE PREPARE stmt;
+
+SET @sql := IF(
+  EXISTS (
+    SELECT 1
+    FROM information_schema.columns
+    WHERE table_schema = DATABASE()
+      AND table_name = 'LessonModule'
+      AND column_name = 'stt'
+  ),
+  'SELECT 1',
+  'ALTER TABLE `LessonModule` ADD COLUMN `stt` INT NOT NULL DEFAULT 0'
+);
+PREPARE stmt FROM @sql; EXECUTE stmt; DEALLOCATE PREPARE stmt;
+
+-- =========================
+-- LessonVideo table
+-- =========================
+SET @sql := IF(
+  EXISTS (
+    SELECT 1
+    FROM information_schema.columns
+    WHERE table_schema = DATABASE()
+      AND table_name = 'LessonVideo'
+      AND column_name = 'order'
+  ),
+  'ALTER TABLE `LessonVideo` DROP COLUMN `order`',
+  'SELECT 1'
+);
+PREPARE stmt FROM @sql; EXECUTE stmt; DEALLOCATE PREPARE stmt;
+
+SET @sql := IF(
+  EXISTS (
+    SELECT 1
+    FROM information_schema.columns
+    WHERE table_schema = DATABASE()
+      AND table_name = 'LessonVideo'
+      AND column_name = 'stt'
+  ),
+  'SELECT 1',
+  'ALTER TABLE `LessonVideo` ADD COLUMN `stt` INT NOT NULL DEFAULT 0'
+);
+PREPARE stmt FROM @sql; EXECUTE stmt; DEALLOCATE PREPARE stmt;
+
+-- =========================
+-- Recreate STT indexes
+-- =========================
+SET @sql := IF(
+  EXISTS (
+    SELECT 1
+    FROM information_schema.statistics
+    WHERE table_schema = DATABASE()
+      AND table_name = 'Lesson'
+      AND index_name = 'Lesson_courseId_stt_idx'
+  ),
+  'DROP INDEX `Lesson_courseId_stt_idx` ON `Lesson`',
+  'SELECT 1'
+);
+PREPARE stmt FROM @sql; EXECUTE stmt; DEALLOCATE PREPARE stmt;
+
+SET @sql := IF(
+  EXISTS (
+    SELECT 1
+    FROM information_schema.statistics
+    WHERE table_schema = DATABASE()
+      AND table_name = 'LessonModule'
+      AND index_name = 'LessonModule_lessonId_stt_idx'
+  ),
+  'DROP INDEX `LessonModule_lessonId_stt_idx` ON `LessonModule`',
+  'SELECT 1'
+);
+PREPARE stmt FROM @sql; EXECUTE stmt; DEALLOCATE PREPARE stmt;
+
+SET @sql := IF(
+  EXISTS (
+    SELECT 1
+    FROM information_schema.statistics
+    WHERE table_schema = DATABASE()
+      AND table_name = 'LessonVideo'
+      AND index_name = 'LessonVideo_moduleId_stt_idx'
+  ),
+  'DROP INDEX `LessonVideo_moduleId_stt_idx` ON `LessonVideo`',
+  'SELECT 1'
+);
+PREPARE stmt FROM @sql; EXECUTE stmt; DEALLOCATE PREPARE stmt;
+
+CREATE INDEX `Lesson_courseId_stt_idx` ON `Lesson`(`courseId`, `stt`);
+CREATE INDEX `LessonModule_lessonId_stt_idx` ON `LessonModule`(`lessonId`, `stt`);
+CREATE INDEX `LessonVideo_moduleId_stt_idx` ON `LessonVideo`(`moduleId`, `stt`);
diff --git a/backend/ayanavitabackend/app/api/prisma/schema.prisma b/backend/ayanavitabackend/app/api/prisma/schema.prisma
index 5bbf204d6ba781458b8865a7f8cdabc686120cc4..74fc8a56f3030aaf9805e42d999d93ccc9703be4 100644
--- a/backend/ayanavitabackend/app/api/prisma/schema.prisma
+++ b/backend/ayanavitabackend/app/api/prisma/schema.prisma
@@ -323,100 +323,97 @@ model Product {
   name             String   @db.VarChar(255)
   description      String?  @db.LongText
   shortDescription String?  @db.VarChar(500)
   imageUrl         String?  @db.Text
   type             String   @default("cleanser") @db.VarChar(40)
   concerns         String   @default("") @db.VarChar(255)
   rating           Float    @default(4.5)
   sold             Int      @default(0)
   price            Int      @default(0)
   published        Boolean  @default(true)
   createdAt        DateTime @default(now())
   updatedAt        DateTime @updatedAt

   @@index([type])
   @@index([published])
   @@index([price])
 }

 model Lesson {
   id              Int              @id @default(autoincrement())
   courseId        Int
   title           String
   slug            String
   description     String?
   content         String?          @db.LongText
-  videoUrl        String?
-  order           Int              @default(0)
-  published       Boolean          @default(false)
+  stt             Int              @default(0)
   createdAt       DateTime         @default(now())
   updatedAt       DateTime         @updatedAt
   course          Course           @relation(fields: [courseId], references: [id], onDelete: Cascade)
   progress        LessonProgress[]
   modules         LessonModule[]
   translations    LessonTranslation[]

   @@unique([courseId, slug])
-  @@index([courseId, order])
+  @@index([courseId, stt])
 }

 model LessonModule {
   id              Int          @id @default(autoincrement())
   lessonId        Int
   title           String
   description     String?
-  order           Int          @default(0)
-  published       Boolean      @default(true)
+  stt             Int          @default(0)
   createdAt       DateTime     @default(now())
   updatedAt       DateTime     @updatedAt

   lesson Lesson @relation(fields: [lessonId], references: [id], onDelete: Cascade)
   videos LessonVideo[]
   translations LessonModuleTranslation[]

-  @@index([lessonId, order])
+  @@index([lessonId, stt])
 }

 model LessonVideo {
   id              Int          @id @default(autoincrement())
   moduleId        Int
   title           String
   description     String?
   sourceUrl       String?
   hlsPlaylistKey  String?
   durationSec     Int          @default(0)
-  order           Int          @default(0)
+  stt             Int          @default(0)
   published       Boolean      @default(true)
   createdAt       DateTime     @default(now())
   updatedAt       DateTime     @updatedAt

   mediaType       LessonMediaType @default(VIDEO)

   module LessonModule @relation(fields: [moduleId], references: [id], onDelete: Cascade)
   translations LessonVideoTranslation[]

-  @@index([moduleId, order])
+  @@index([moduleId, stt])
 }


 model CourseContentTranslation {
   id             Int      @id @default(autoincrement())
   courseId       Int
   locale         String   @db.VarChar(10)
   objectives     Json?
   targetAudience Json?
   benefits       Json?
   createdAt      DateTime @default(now())
   updatedAt      DateTime @updatedAt

   course Course @relation(fields: [courseId], references: [id], onDelete: Cascade)

   @@unique([courseId, locale])
   @@index([locale])
 }

 model LessonTranslation {
   id          Int      @id @default(autoincrement())
   lessonId    Int
   locale      String   @db.VarChar(10)
   title       String   @db.VarChar(255)
   description String?  @db.Text
diff --git a/backend/ayanavitabackend/app/api/src/courses/courses.controller.ts b/backend/ayanavitabackend/app/api/src/courses/courses.controller.ts
index c3bacee8b703309dccdae201d0e494c569513fe4..f36449d19cf9527030a0ebfc415722f310a1cb54 100644
--- a/backend/ayanavitabackend/app/api/src/courses/courses.controller.ts
+++ b/backend/ayanavitabackend/app/api/src/courses/courses.controller.ts
@@ -34,56 +34,57 @@ const parseMultipartData = (input: Record<string, any>) => {
     const trimmed = value.trim()
     if (trimmed === 'true' || trimmed === 'false') {
       data[key] = trimmed === 'true'
       continue
     }
     if (/^-?\d+(\.\d+)?$/.test(trimmed) && key !== 'slug') {
       data[key] = Number(trimmed)
       continue
     }
     if ((trimmed.startsWith('[') && trimmed.endsWith(']')) || (trimmed.startsWith('{') && trimmed.endsWith('}'))) {
       try {
         data[key] = JSON.parse(trimmed)
       } catch {
         data[key] = value
       }
     }
   }
   return data
 }

 @Controller('courses')
 export class CoursesController {
   constructor(private readonly courses: CoursesService) {}

   @UseGuards(AccessTokenGuard)
-  @Get('courses/:id/lessons-outline')
+  @Get(':id/lessons-outline')
   lessonsOutline(
     @CurrentUser() user: JwtUser,
     @Param('id', ParseIntPipe) id: number,
+    @Query('lang') lang?: string,
   ) {
-    return this.courses.lessonsOutline(user, id)
+    return this.courses.lessonsOutline(user, id, lang)
   }

   @Get()
   @UseGuards(OptionalAccessTokenGuard)
   findAll(@CurrentUser() user: JwtUser | null, @Query() query: CourseQueryDto) {
     return this.courses.findAll(query, user)
   }

   @UseGuards(AccessTokenGuard)
   @Get(':id')
   findOne(@Param('id', ParseIntPipe) id: number, @Query('lang') lang?: string) {
     return this.courses.findOne(id, lang)
   }

   @UseGuards(AccessTokenGuard)
   @Get(':id/lessons')
   listLessons(@CurrentUser() user: any, @Param('id', ParseIntPipe) id: number) {
     return this.courses.listLessons(user, id)
   }

   @UseGuards(AccessTokenGuard)
   @Get(':id/lessons/:lessonId')
   getLesson(
     @CurrentUser() user: any,
     @Param('id', ParseIntPipe) courseId: number,
diff --git a/backend/ayanavitabackend/app/api/src/courses/courses.service.ts b/backend/ayanavitabackend/app/api/src/courses/courses.service.ts
index a157db6c884d19c4d8b1b1a25c921c05d3aee518..16d1a15341f62d760fdb58d63dd1d15e468b361f 100644
--- a/backend/ayanavitabackend/app/api/src/courses/courses.service.ts
+++ b/backend/ayanavitabackend/app/api/src/courses/courses.service.ts
@@ -91,55 +91,67 @@ export class CoursesService {
       ...(dto.ratingAvg !== undefined ? { ratingAvg: dto.ratingAvg } : {}),
       ...(dto.ratingCount !== undefined ? { ratingCount: dto.ratingCount } : {}),
       ...(dto.enrollmentCount !== undefined ? { enrollmentCount: dto.enrollmentCount } : {}),
     }
   }

   private buildUpdateCoursePayload(dto: UpdateCourseDto): Prisma.CourseUncheckedUpdateInput {
     return {
       ...(dto.title !== undefined ? { title: dto.title } : {}),
       ...(dto.slug !== undefined ? { slug: dto.slug } : {}),
       ...(dto.description !== undefined ? { description: dto.description } : {}),
       ...(dto.shortDescription !== undefined ? { shortDescription: dto.shortDescription } : {}),
       ...(dto.thumbnail !== undefined ? { thumbnail: dto.thumbnail } : {}),
       ...(dto.price !== undefined ? { price: dto.price } : {}),
       ...(dto.published !== undefined ? { published: dto.published } : {}),
       ...(dto.topicId !== undefined ? { topicId: dto.topicId } : {}),
       ...(dto.objectives !== undefined ? { objectives: dto.objectives as any } : {}),
       ...(dto.targetAudience !== undefined ? { targetAudience: dto.targetAudience as any } : {}),
       ...(dto.benefits !== undefined ? { benefits: dto.benefits as any } : {}),
       ...(dto.ratingAvg !== undefined ? { ratingAvg: dto.ratingAvg } : {}),
       ...(dto.ratingCount !== undefined ? { ratingCount: dto.ratingCount } : {}),
       ...(dto.enrollmentCount !== undefined ? { enrollmentCount: dto.enrollmentCount } : {}),
     }
   }

-  async lessonsOutline(user: JwtUser, courseId: number) { /* unchanged */
+  async lessonsOutline(user: JwtUser, courseId: number, lang?: string) {
     const course = await this.prisma.course.findUnique({ where: { id: courseId }, select: { id: true, published: true } })
     if (!course) throw new NotFoundException('Course not found')
     if (user.role !== 'ADMIN' && !course.published) throw new NotFoundException('Course not found')
-    return this.prisma.lesson.findMany({ where: { courseId, ...(user.role === 'ADMIN' ? {} : { published: true }) }, select: { id: true, courseId: true, title: true, slug: true, order: true, published: true, createdAt: true, updatedAt: true }, orderBy: [{ order: 'asc' }, { id: 'asc' }] })
+    const locale = this.resolveCourseLocale(lang)
+    const rows = await this.prisma.lesson.findMany({
+      where: { courseId },
+      select: {
+        id: true, courseId: true, title: true, slug: true, stt: true, createdAt: true, updatedAt: true,
+        translations: { where: { locale: { in: [locale, 'vi'] } }, select: { locale: true, title: true, description: true } },
+      },
+      orderBy: [{ stt: 'asc' }, { id: 'asc' }],
+    })
+    return rows.map((row) => {
+      const tr = row.translations.find((x: any) => x.locale === locale) || row.translations.find((x: any) => x.locale === 'vi')
+      return { ...row, title: tr?.title || row.title, description: tr?.description || null }
+    })
   }

   async findAll(query: CourseQueryDto, user?: { sub: number; role: string } | null) {
     const courseLocale = this.resolveCourseLocale(query.lang)
     const topicLocale = courseLocale
     const where: Prisma.CourseWhereInput = {
       ...(user?.role === 'ADMIN' ? {} : { published: true }),
       ...(query.topicId ? { topicId: query.topicId } : {}),
       ...(query.search?.trim() ? { OR: [{ title: { contains: query.search.trim() } }, { slug: { contains: query.search.trim() } }] } : {}),
     }
     const page = Math.max(1, Number(query.page || 1)); const pageSize = Math.min(100, Math.max(1, Number(query.pageSize || 10)))
     const [rows, total] = await Promise.all([
       this.prisma.course.findMany({
         where,
         select: {
           ...this.baseCourseSelect,
           translations: { where: { locale: { in: [courseLocale, 'vi'] } }, select: { locale: true, title: true, shortDescription: true, description: true } },
           contentTranslations: { where: { locale: { in: [courseLocale, 'vi'] } }, select: { locale: true, objectives: true, targetAudience: true, benefits: true } },
           topic: { select: { id: true, name: true, translations: { where: { locale: { in: [topicLocale, 'vi'] } }, select: { locale: true, name: true } } } },
         },
         skip: (page - 1) * pageSize, take: pageSize, orderBy: { id: 'desc' },
       }),
       this.prisma.course.count({ where }),
     ])
     const courseIds = rows.map((r) => r.id)
@@ -224,62 +236,61 @@ export class CoursesService {
       }
     }

     const updated = await this.prisma.course.update({
       where: { id },
       data: this.buildUpdateCoursePayload({ ...normalizedDto, ...(nextThumbnail !== undefined ? { thumbnail: nextThumbnail } : {}) }),
       select: this.baseCourseSelect,
     })
     await this.syncCourseTranslations(id, normalizedDto)
     return updated
   }

   async remove(id: number) {
     const existing = await this.prisma.course.findUnique({ where: { id }, select: { id: true, thumbnail: true } })
     if (!existing) throw new NotFoundException('Course not found')

     if (existing.thumbnail) {
       await this.courseMedia.deleteThumbnailByUrl(existing.thumbnail)
     }

     return this.prisma.course.delete({ where: { id }, select: { id: true } })
   }

   async listLessons(user: { sub: number; role: string }, courseId: number) { /* kept */
     const course = await this.prisma.course.findUnique({ where: { id: courseId }, select: { id: true, published: true } }); if (!course) throw new NotFoundException('Course not found'); await this.enrollments.assertEnrolledOrAdmin(user, courseId); if (user.role !== 'ADMIN' && !course.published) throw new NotFoundException('Course not found')
-    const lessons = await this.prisma.lesson.findMany({ where: { courseId, ...(user.role === 'ADMIN' ? {} : { published: true }) }, select: { id: true, courseId: true, title: true, slug: true, order: true, published: true, createdAt: true, updatedAt: true }, orderBy: [{ order: 'asc' }, { id: 'asc' }] })
+    const lessons = await this.prisma.lesson.findMany({ where: { courseId }, select: { id: true, courseId: true, title: true, slug: true, stt: true, createdAt: true, updatedAt: true }, orderBy: [{ stt: 'asc' }, { id: 'asc' }] })
     if (user.role === 'ADMIN') return lessons.map((l) => ({ ...l, locked: false, lockReason: null, progress: null }))
     const progressRows = await this.prisma.lessonProgress.findMany({ where: { userId: user.sub, lessonId: { in: lessons.map((l) => l.id) } }, select: { lessonId: true, status: true, percent: true, lastPositionSec: true, lastOpenedAt: true, completedAt: true, updatedAt: true } })
     const progressMap = new Map(progressRows.map((p) => [p.lessonId, p])); let prevCompleted = true
     return lessons.map((lesson, idx) => { const progress = progressMap.get(lesson.id) ?? null; const locked = idx === 0 ? false : prevCompleted === false; const lockReason = locked ? 'PREV_NOT_COMPLETED' : null; prevCompleted = progress?.status === ProgressStatus.COMPLETED; return { ...lesson, locked, lockReason, progress } })
   }

   async getLessonDetail(user: { sub: number; role: string }, courseId: number, lessonId: number) { /* kept */
     const course = await this.prisma.course.findUnique({ where: { id: courseId }, select: { id: true, published: true } }); if (!course) throw new NotFoundException('Course not found'); await this.enrollments.assertEnrolledOrAdmin(user, courseId); if (user.role !== 'ADMIN' && !course.published) throw new NotFoundException('Course not found')
-    const lesson = await this.prisma.lesson.findFirst({ where: { id: lessonId, courseId }, select: { id: true, courseId: true, title: true, slug: true, content: true, videoUrl: true, order: true, published: true, createdAt: true, updatedAt: true } }); if (!lesson) throw new NotFoundException('Lesson not found')
-    if (user.role !== 'ADMIN' && !lesson.published) throw new NotFoundException('Lesson not found')
-    if (user.role !== 'ADMIN') { const orderedLessons = await this.prisma.lesson.findMany({ where: { courseId, published: true }, select: { id: true }, orderBy: [{ order: 'asc' }, { id: 'asc' }] }); const idx = orderedLessons.findIndex((l) => l.id === lessonId); if (idx < 0) throw new NotFoundException('Lesson not found'); if (idx > 0) { const prevLessonId = orderedLessons[idx - 1].id; const prevProgress = await this.prisma.lessonProgress.findUnique({ where: { userId_lessonId: { userId: user.sub, lessonId: prevLessonId } }, select: { status: true } }); if (prevProgress?.status !== ProgressStatus.COMPLETED) throw new ForbiddenException('Lesson locked') } }
+    const lesson = await this.prisma.lesson.findFirst({ where: { id: lessonId, courseId }, select: { id: true, courseId: true, title: true, slug: true, content: true, stt: true, createdAt: true, updatedAt: true } }); if (!lesson) throw new NotFoundException('Lesson not found')
+    if (user.role !== 'ADMIN') { const orderedLessons = await this.prisma.lesson.findMany({ where: { courseId }, select: { id: true }, orderBy: [{ stt: 'asc' }, { id: 'asc' }] }); const idx = orderedLessons.findIndex((l) => l.id === lessonId); if (idx < 0) throw new NotFoundException('Lesson not found'); if (idx > 0) { const prevLessonId = orderedLessons[idx - 1].id; const prevProgress = await this.prisma.lessonProgress.findUnique({ where: { userId_lessonId: { userId: user.sub, lessonId: prevLessonId } }, select: { status: true } }); if (prevProgress?.status !== ProgressStatus.COMPLETED) throw new ForbiddenException('Lesson locked') } }
     const progress = await this.prisma.lessonProgress.findUnique({ where: { userId_lessonId: { userId: user.sub, lessonId } }, select: { lessonId: true, status: true, percent: true, lastPositionSec: true, lastOpenedAt: true, completedAt: true, updatedAt: true } })
     return { ...lesson, progress: progress ?? null }
   }


   private async syncCourseTranslations(courseId: number, dto: Partial<CreateCourseDto>) {
     const locales: Array<'vi' | 'en' | 'de'> = ['vi', 'en', 'de']
     const objectivesByLocale = this.normalizeLocalizedList(dto.objectives)
     const targetAudienceByLocale = this.normalizeLocalizedList(dto.targetAudience)
     const benefitsByLocale = this.normalizeLocalizedList(dto.benefits)

     await Promise.all(locales.map(async (locale) => {
       const tr = dto.translations?.[locale]
       const title = tr?.title || (locale === 'vi' ? dto.title : undefined)

       if (title?.trim()) {
         await this.prisma.courseTranslation.upsert({
           where: { courseId_locale: { courseId, locale } },
           update: {
             title: title.trim(),
             shortDescription: tr?.shortDescription?.trim() || (locale === 'vi' ? dto.shortDescription?.trim() || null : null),
             description: tr?.description?.trim() || (locale === 'vi' ? dto.description?.trim() || null : null),
           },
           create: {
             courseId,
diff --git a/backend/ayanavitabackend/app/api/src/enrollments/enrollments.service.ts b/backend/ayanavitabackend/app/api/src/enrollments/enrollments.service.ts
index dccfd90dcfdd20ac30ddea3b7749fdd7fd11875b..92413e2ac3459f0da3f67a119e71c037081cb22b 100644
--- a/backend/ayanavitabackend/app/api/src/enrollments/enrollments.service.ts
+++ b/backend/ayanavitabackend/app/api/src/enrollments/enrollments.service.ts
@@ -127,69 +127,67 @@ export class EnrollmentsService {
           },
         },
       },
       orderBy: { enrolledAt: 'desc' },
     })
   }

   /**
    * Danh sách khóa học + progress % (completedLessons/totalLessons)
    *
    * Quy tắc:
    * - USER: chỉ tính trên lessons published=true
    * - ADMIN: tính trên tất cả lessons
    */
   async myCoursesWithProgress(user: JwtUser) {
     const userId = user.sub
     const isAdmin = user.role === 'ADMIN'
     const enrollments = await this.myCourses(userId)

     if (enrollments.length === 0) return []

     const completed = await this.prisma.lessonProgress.findMany({
       where: {
         userId,
         status: 'COMPLETED',
-        ...(isAdmin ? {} : { lesson: { published: true } }),
       },
       select: {
         lesson: { select: { courseId: true } },
       },
     })

     const completedCountByCourse = new Map<number, number>()
     for (const x of completed) {
       const courseId = x.lesson.courseId
       completedCountByCourse.set(courseId, (completedCountByCourse.get(courseId) || 0) + 1)
     }

     const courseIds = enrollments.map((e) => e.course.id)
     const totals = await this.prisma.lesson.groupBy({
       by: ['courseId'],
       where: {
         courseId: { in: courseIds },
-        ...(isAdmin ? {} : { published: true }),
       },
       _count: { _all: true },
     })
     const totalByCourse = new Map<number, number>(totals.map((t) => [t.courseId, t._count._all]))

     return enrollments.map((e) => {
       const totalLessons = totalByCourse.get(e.course.id) || 0
       const completedLessons = completedCountByCourse.get(e.course.id) || 0
       const percent = totalLessons === 0 ? 0 : Math.round((completedLessons / totalLessons) * 100)

       return {
         enrollmentId: e.id,
         enrolledAt: e.enrolledAt,
         status: e.status,
         orderId: e.orderId,
         course: e.course,
         progress: { totalLessons, completedLessons, percent },
       }
     })
   }

   async cancel(userId: number, courseId: number) {
     const enrollment = await this.prisma.enrollment.findUnique({
       where: { userId_courseId: { userId, courseId } },
       select: { id: true, status: true },
diff --git a/backend/ayanavitabackend/app/api/src/lessons/dto/create-lesson.dto.ts b/backend/ayanavitabackend/app/api/src/lessons/dto/create-lesson.dto.ts
index d8ad824a47954c3f19b76bfa829de95f367bc049..5e12349b8c67ab2d8be3cbb07bb6a96390f547aa 100644
--- a/backend/ayanavitabackend/app/api/src/lessons/dto/create-lesson.dto.ts
+++ b/backend/ayanavitabackend/app/api/src/lessons/dto/create-lesson.dto.ts
@@ -1,49 +1,45 @@
 import { Type } from 'class-transformer'
-import { IsArray, IsBoolean, IsInt, IsObject, IsOptional, IsString, Min, ValidateNested } from 'class-validator'
+import { IsArray, IsInt, IsObject, IsOptional, IsString, Min, ValidateNested } from 'class-validator'

 class TranslationDto {
   @IsString()
   title: string

   @IsOptional()
   @IsString()
   description?: string
 }

 class LessonVideoDto {
   @IsString()
   title: string
   @IsOptional() @IsString() description?: string
-  @IsOptional() @IsString() sourceUrl?: string
+  @IsString() sourceUrl: string
   @IsOptional() @IsString() mediaType?: 'VIDEO' | 'IMAGE'
   @IsOptional() @IsInt() @Min(0) durationSec?: number
-  @IsOptional() @IsInt() @Min(0) order?: number
-  @IsOptional() @IsBoolean() published?: boolean
+  @IsInt() @Min(0) stt: number
   @IsOptional() @IsObject() @ValidateNested({ each: true }) @Type(() => TranslationDto)
   translations?: Record<string, TranslationDto>
 }

 class LessonModuleDto {
   @IsString() title: string
   @IsOptional() @IsString() description?: string
-  @IsOptional() @IsInt() @Min(0) order?: number
-  @IsOptional() @IsBoolean() published?: boolean
+  @IsInt() @Min(0) stt: number
   @IsOptional() @IsObject() @ValidateNested({ each: true }) @Type(() => TranslationDto)
   translations?: Record<string, TranslationDto>
-  @IsOptional() @IsArray() @ValidateNested({ each: true }) @Type(() => LessonVideoDto)
-  videos?: LessonVideoDto[]
+  @IsArray() @ValidateNested({ each: true }) @Type(() => LessonVideoDto)
+  videos: LessonVideoDto[]
 }

 export class CreateLessonDto {
   @IsString() title!: string
   @IsString() slug!: string
   @IsOptional() @IsString() description?: string
   @IsOptional() @IsObject() @ValidateNested({ each: true }) @Type(() => TranslationDto)
   translations?: Record<string, TranslationDto>
   @IsOptional() @IsString() content?: string
-  @IsOptional() @IsString() videoUrl?: string
-  @IsOptional() @IsArray() @ValidateNested({ each: true }) @Type(() => LessonModuleDto)
-  modules?: LessonModuleDto[]
-  @IsOptional() @IsInt() @Min(0) order?: number
-  @IsOptional() @IsBoolean() published?: boolean
+  @IsArray() @ValidateNested({ each: true }) @Type(() => LessonModuleDto)
+  modules: LessonModuleDto[]
+  @IsInt() @Min(0) stt: number
 }
diff --git a/backend/ayanavitabackend/app/api/src/lessons/lessons.controller.ts b/backend/ayanavitabackend/app/api/src/lessons/lessons.controller.ts
index 5ab066914d300d8278d352c03fd5f21f502ef4d8..285490948238818a81dd7302968066adaad8395d 100644
--- a/backend/ayanavitabackend/app/api/src/lessons/lessons.controller.ts
+++ b/backend/ayanavitabackend/app/api/src/lessons/lessons.controller.ts
@@ -35,57 +35,57 @@ export class LessonsController {
   ) {
     return this.lessons.findOne(user, id)
   }

   // ADMIN: tạo lesson trong course
   @UseGuards(RolesGuard)
   @Roles('ADMIN')
   @Post('courses/:courseId/lessons')
   create(
     @Param('courseId', ParseIntPipe) courseId: number,
     @Body() dto: CreateLessonDto,
   ) {
     return this.lessons.create(courseId, dto)
   }


   @UseGuards(RolesGuard)
   @Roles('ADMIN')
   @Post('lessons/:id/modules/:moduleId/media/upload')
   @UseInterceptors(FileInterceptor('file', { storage: memoryStorage() }))
   uploadModuleMedia(
     @Param('id', ParseIntPipe) lessonId: number,
     @Param('moduleId') moduleId: string,
     @UploadedFile() file?: any,
     @Body('type') type?: string,
-    @Body('order') order?: string,
+    @Body('stt') stt?: string,
   ) {
     if (!file) return { message: 'Missing media file' }
-    const parsedOrder = Number(order)
+    const parsedStt = Number(stt)
     return this.lessons.uploadModuleMedia(
       lessonId,
       moduleId,
       type === 'image' ? 'image' : 'video',
       file,
-      Number.isFinite(parsedOrder) ? parsedOrder : undefined,
+      Number.isFinite(parsedStt) ? parsedStt : undefined,
     )
   }

   // ADMIN: update lesson
   @UseGuards(RolesGuard)
   @Roles('ADMIN')
   @Patch('lessons/:id')
   update(
     @Param('id', ParseIntPipe) id: number,
     @Body() dto: UpdateLessonDto,
   ) {
     return this.lessons.update(id, dto)
   }

   // ADMIN: delete lesson
   @UseGuards(RolesGuard)
   @Roles('ADMIN')
   @Delete('lessons/:id')
   remove(@Param('id', ParseIntPipe) id: number) {
     return this.lessons.remove(id)
   }
 }
diff --git a/backend/ayanavitabackend/app/api/src/lessons/lessons.service.ts b/backend/ayanavitabackend/app/api/src/lessons/lessons.service.ts
index 9657412a7ab4d63997d7139c24477b87be66e8b9..ecae166e0c95cfc7fba1e2fe522048dd470d62cd 100644
--- a/backend/ayanavitabackend/app/api/src/lessons/lessons.service.ts
+++ b/backend/ayanavitabackend/app/api/src/lessons/lessons.service.ts
@@ -1,124 +1,123 @@
 import { ForbiddenException, Injectable, NotFoundException } from '@nestjs/common'
 import { PrismaService } from '../prisma/prisma.service'
 import { CreateLessonDto } from './dto/create-lesson.dto'
 import { UpdateLessonDto } from './dto/update-lesson.dto'
 import { EnrollmentsService } from '../enrollments/enrollments.service'
 import { LessonsMediaService } from './lessons-media.service'
 import { JwtUser } from '../auth/decorators/current-user.decorator'
 import { LessonMediaType, ProgressStatus } from '@prisma/client'

 @Injectable()
 export class LessonsService {
   constructor(private readonly prisma: PrismaService, private readonly enrollments: EnrollmentsService, private readonly media: LessonsMediaService) {}

   async findOne(user: JwtUser, id: number) {
     const lesson = await this.prisma.lesson.findUnique({
       where: { id },
       select: {
-        id: true, courseId: true, title: true, slug: true, description: true, order: true, published: true, content: true, videoUrl: true, createdAt: true, updatedAt: true,
+        id: true, courseId: true, title: true, slug: true, description: true, stt: true, content: true, createdAt: true, updatedAt: true,
         translations: { select: { locale: true, title: true, description: true } },
-        modules: { where: user.role === 'ADMIN' ? {} : { published: true }, orderBy: [{ order: 'asc' }, { id: 'asc' }], select: {
-          id: true, title: true, description: true, order: true, published: true,
+        modules: { orderBy: [{ stt: 'asc' }, { id: 'asc' }], select: {
+          id: true, title: true, description: true, stt: true,
           translations: { select: { locale: true, title: true, description: true } },
-          videos: { where: user.role === 'ADMIN' ? {} : { published: true }, orderBy: [{ order: 'asc' }, { id: 'asc' }], select: { id: true, title: true, description: true, sourceUrl: true, hlsPlaylistKey: true, mediaType: true, durationSec: true, order: true, published: true, translations: { select: { locale: true, title: true, description: true } } } },
+          videos: { orderBy: [{ stt: 'asc' }, { id: 'asc' }], select: { id: true, title: true, description: true, sourceUrl: true, hlsPlaylistKey: true, mediaType: true, durationSec: true, stt: true, translations: { select: { locale: true, title: true, description: true } } } },
         } },
       },
     })
     if (!lesson) throw new NotFoundException('Lesson not found')
     await this.enrollments.assertEnrolledOrAdmin(user, lesson.courseId)
-    if (user.role !== 'ADMIN' && !lesson.published) throw new NotFoundException('Lesson not found')
     if (user.role !== 'ADMIN') {
-      const prev = await this.prisma.lesson.findFirst({ where: { courseId: lesson.courseId, published: true, OR: [{ order: { lt: lesson.order ?? 0 } }, { order: lesson.order ?? 0, id: { lt: lesson.id } }] }, select: { id: true }, orderBy: [{ order: 'desc' }, { id: 'desc' }] })
+      const prev = await this.prisma.lesson.findFirst({ where: { courseId: lesson.courseId, OR: [{ stt: { lt: lesson.stt ?? 0 } }, { stt: lesson.stt ?? 0, id: { lt: lesson.id } }] }, select: { id: true }, orderBy: [{ stt: 'desc' }, { id: 'desc' }] })
       if (prev) {
         const prevProgress = await this.prisma.lessonProgress.findUnique({ where: { userId_lessonId: { userId: user.sub, lessonId: prev.id } }, select: { status: true } })
         if (!prevProgress || prevProgress.status !== ProgressStatus.COMPLETED) throw new ForbiddenException('Complete previous lesson first')
       }
     }
     return lesson
   }

   async create(courseId: number, dto: CreateLessonDto) {
     return this.prisma.$transaction(async (tx) => {
-      const lesson = await tx.lesson.create({ data: { courseId, title: dto.title, slug: dto.slug, description: dto.description, content: dto.content, videoUrl: dto.videoUrl, order: dto.order, published: dto.published } as any })
+      const lesson = await tx.lesson.create({ data: { courseId, title: dto.title, slug: dto.slug, description: dto.description, content: dto.content, stt: dto.stt } as any })
       await this.upsertLessonTranslations(tx, lesson.id, dto)
       if (dto.modules?.length) {
         for (const m of dto.modules) {
-          const mod = await tx.lessonModule.create({ data: { lessonId: lesson.id, title: m.title, description: m.description, order: m.order, published: m.published } as any })
+          const mod = await tx.lessonModule.create({ data: { lessonId: lesson.id, title: m.title, description: m.description, stt: m.stt } as any })
           await this.upsertModuleTranslations(tx, mod.id, m)
           if (m.videos?.length) {
-            for (const [idx, v] of m.videos.entries()) {
-              const video = await tx.lessonVideo.create({ data: { moduleId: mod.id, title: v.title, description: v.description, sourceUrl: v.sourceUrl, mediaType: v.mediaType === 'IMAGE' ? LessonMediaType.IMAGE : LessonMediaType.VIDEO, durationSec: v.durationSec ?? 0, order: v.order ?? idx, published: v.published ?? true } as any })
+            for (const v of m.videos) {
+              const video = await tx.lessonVideo.create({ data: { moduleId: mod.id, title: v.title, description: v.description, sourceUrl: v.sourceUrl, mediaType: v.mediaType === 'IMAGE' ? LessonMediaType.IMAGE : LessonMediaType.VIDEO, durationSec: v.durationSec ?? 0, stt: v.stt } as any })
               await this.upsertVideoTranslations(tx, video.id, v)
             }
           }
         }
       }
       return lesson
     })
   }

-  async uploadModuleMedia(lessonId: number, moduleId: string, type: 'video' | 'image', file: { buffer: Buffer; originalname?: string }, order?: number) {
+  async uploadModuleMedia(lessonId: number, moduleId: string, type: 'video' | 'image', file: { buffer: Buffer; originalname?: string }, stt?: number) {
     const lesson = await this.prisma.lesson.findUnique({ where: { id: lessonId }, select: { id: true } })
     if (!lesson) throw new NotFoundException('Lesson not found')

     const module = await this.prisma.lessonModule.findFirst({ where: { id: Number(moduleId), lessonId }, select: { id: true } })
     if (!module) throw new NotFoundException('Module not found')

-    const resolvedOrder = Number.isFinite(order) ? Number(order) : 0
+    const resolvedStt = Number.isFinite(stt) ? Number(stt) : 0

     if (type === 'image') {
       const uploaded = await this.media.convertImageToWebpAndUpload(file, lessonId, moduleId)
-      const existing = await this.prisma.lessonVideo.findFirst({ where: { moduleId: module.id, order: resolvedOrder }, orderBy: { id: 'asc' }, select: { id: true } })
+      const existing = await this.prisma.lessonVideo.findFirst({ where: { moduleId: module.id, stt: resolvedStt }, orderBy: { id: 'asc' }, select: { id: true } })
       const video = existing
         ? await this.prisma.lessonVideo.update({ where: { id: existing.id }, data: { mediaType: LessonMediaType.IMAGE, sourceUrl: uploaded.sourceUrl, hlsPlaylistKey: null, published: true } })
-        : await this.prisma.lessonVideo.create({ data: { moduleId: module.id, title: `image-${resolvedOrder}`, description: null, mediaType: LessonMediaType.IMAGE, sourceUrl: uploaded.sourceUrl, durationSec: 0, order: resolvedOrder, published: true } })
+        : await this.prisma.lessonVideo.create({ data: { moduleId: module.id, title: `image-${resolvedStt}`, description: null, mediaType: LessonMediaType.IMAGE, sourceUrl: uploaded.sourceUrl, durationSec: 0, stt: resolvedStt, published: true } })
       return { ...uploaded, videoId: video.id }
     }

     const uploaded = await this.media.transcodeToHlsAndUpload(file, lessonId, moduleId)
-    const existing = await this.prisma.lessonVideo.findFirst({ where: { moduleId: module.id, order: resolvedOrder }, orderBy: { id: 'asc' }, select: { id: true } })
+    const existing = await this.prisma.lessonVideo.findFirst({ where: { moduleId: module.id, stt: resolvedStt }, orderBy: { id: 'asc' }, select: { id: true } })
     const video = existing
       ? await this.prisma.lessonVideo.update({ where: { id: existing.id }, data: { mediaType: LessonMediaType.VIDEO, sourceUrl: uploaded.playlistKey, hlsPlaylistKey: uploaded.playlistKey, published: true } })
-      : await this.prisma.lessonVideo.create({ data: { moduleId: module.id, title: `video-${resolvedOrder}`, description: null, mediaType: LessonMediaType.VIDEO, sourceUrl: uploaded.playlistKey, hlsPlaylistKey: uploaded.playlistKey, durationSec: 0, order: resolvedOrder, published: true } })
+      : await this.prisma.lessonVideo.create({ data: { moduleId: module.id, title: `video-${resolvedStt}`, description: null, mediaType: LessonMediaType.VIDEO, sourceUrl: uploaded.playlistKey, hlsPlaylistKey: uploaded.playlistKey, durationSec: 0, stt: resolvedStt, published: true } })
     return { ...uploaded, videoId: video.id }
   }

   async update(id: number, dto: UpdateLessonDto) {
     return this.prisma.$transaction(async (tx) => {
-      const lesson = await tx.lesson.update({ where: { id }, data: { title: dto.title, slug: dto.slug, description: dto.description, content: dto.content, videoUrl: dto.videoUrl, order: dto.order, published: dto.published } as any })
+      const lesson = await tx.lesson.update({ where: { id }, data: { title: dto.title, slug: dto.slug, description: dto.description, content: dto.content, stt: dto.stt } as any })
       await this.upsertLessonTranslations(tx, id, dto)
       if (dto.modules) {
         await tx.lessonVideoTranslation.deleteMany({ where: { video: { module: { lessonId: id } } } as any })
         await tx.lessonModuleTranslation.deleteMany({ where: { module: { lessonId: id } } as any })
         await tx.lessonVideo.deleteMany({ where: { module: { lessonId: id } } as any })
         await tx.lessonModule.deleteMany({ where: { lessonId: id } })
         for (const m of dto.modules) {
-          const mod = await tx.lessonModule.create({ data: { lessonId: id, title: m.title, description: m.description, order: m.order, published: m.published } as any })
+          const mod = await tx.lessonModule.create({ data: { lessonId: id, title: m.title, description: m.description, stt: m.stt } as any })
           await this.upsertModuleTranslations(tx, mod.id, m)
-          for (const [idx, v] of (m.videos || []).entries()) {
-            const video = await tx.lessonVideo.create({ data: { moduleId: mod.id, title: v.title, description: v.description, sourceUrl: v.sourceUrl, mediaType: v.mediaType === 'IMAGE' ? LessonMediaType.IMAGE : LessonMediaType.VIDEO, durationSec: v.durationSec ?? 0, order: v.order ?? idx, published: v.published ?? true } as any })
+          for (const v of (m.videos || [])) {
+            const video = await tx.lessonVideo.create({ data: { moduleId: mod.id, title: v.title, description: v.description, sourceUrl: v.sourceUrl, mediaType: v.mediaType === 'IMAGE' ? LessonMediaType.IMAGE : LessonMediaType.VIDEO, durationSec: v.durationSec ?? 0, stt: v.stt } as any })
             await this.upsertVideoTranslations(tx, video.id, v)
           }
         }
       }
       return lesson
     })
   }

   remove(id: number) { return this.prisma.lesson.delete({ where: { id } }) }

   private async upsertLessonTranslations(tx: any, lessonId: number, dto: any) {
     for (const locale of ['vi', 'en', 'de']) {
       const tr = dto.translations?.[locale]
       const title = tr?.title || (locale === 'vi' ? dto.title : undefined)
       if (!title) continue
       await tx.lessonTranslation.upsert({ where: { lessonId_locale: { lessonId, locale } }, update: { title, description: tr?.description || (locale === 'vi' ? dto.description : null) }, create: { lessonId, locale, title, description: tr?.description || (locale === 'vi' ? dto.description : null) } })
     }
   }
   private async upsertModuleTranslations(tx: any, moduleId: number, dto: any) {
     for (const locale of ['vi', 'en', 'de']) {
       const tr = dto.translations?.[locale]
       const title = tr?.title || (locale === 'vi' ? dto.title : undefined)
       if (!title) continue
       await tx.lessonModuleTranslation.upsert({ where: { moduleId_locale: { moduleId, locale } }, update: { title, description: tr?.description || (locale === 'vi' ? dto.description : null) }, create: { moduleId, locale, title, description: tr?.description || (locale === 'vi' ? dto.description : null) } })
     }
diff --git a/backend/ayanavitabackend/app/api/src/progress/progress.service.ts b/backend/ayanavitabackend/app/api/src/progress/progress.service.ts
index 52e4f452332b5870c278baa7066e317b245beb2f..197e8c511bc376f77dc518024ad3c8ff60b8a735 100644
--- a/backend/ayanavitabackend/app/api/src/progress/progress.service.ts
+++ b/backend/ayanavitabackend/app/api/src/progress/progress.service.ts
@@ -4,102 +4,100 @@ import { PrismaService } from '../prisma/prisma.service'
 import { EnrollmentsService } from '../enrollments/enrollments.service'
 import { UpsertProgressDto } from './dto/upsert-progress.dto'

 type JwtUser = { sub: number; role: string }

 @Injectable()
 export class ProgressService {
   constructor(
     private readonly prisma: PrismaService,
     private readonly enrollments: EnrollmentsService,
   ) {}

   private clampPercent(p?: number) {
     if (p === undefined) return undefined
     if (p < 0) return 0
     if (p > 100) return 100
     return p
   }

   private async getLessonOrThrow(lessonId: number) {
     const lesson = await this.prisma.lesson.findUnique({
       where: { id: lessonId },
       select: {
         id: true,
         courseId: true,
-        published: true,
-        order: true,
+        stt: true,
         course: { select: { published: true } },
       },
     })
     if (!lesson) throw new NotFoundException('Lesson not found')
     return lesson
   }

   /**
    * Sequential lock gate:
    * - ADMIN bypass
    * - USER: lesson i chỉ mở nếu lesson i-1 COMPLETED
    * - USER: chỉ xét lesson published=true
    */
   private async assertLessonUnlockedOrAdmin(user: JwtUser, lessonId: number, courseId: number) {
     if (user.role === 'ADMIN') return

     const orderedLessons = await this.prisma.lesson.findMany({
-      where: { courseId, published: true },
+      where: { courseId },
       select: { id: true },
-      orderBy: [{ order: 'asc' }, { id: 'asc' }],
+      orderBy: [{ stt: 'asc' }, { id: 'asc' }],
     })

     const idx = orderedLessons.findIndex((l) => l.id === lessonId)
     if (idx === -1) throw new NotFoundException('Lesson not found')

     // lesson đầu tiên luôn mở
     if (idx === 0) return

     const prevLessonId = orderedLessons[idx - 1].id
     const prevProgress = await this.prisma.lessonProgress.findUnique({
       where: { userId_lessonId: { userId: user.sub, lessonId: prevLessonId } },
       select: { status: true },
     })

     if (prevProgress?.status !== ProgressStatus.COMPLETED) {
       throw new ForbiddenException('Lesson locked')
     }
   }

   // POST /lessons/:id/progress  { percent?, lastPositionSec? }
   async upsertLessonProgress(user: JwtUser, lessonId: number, dto: UpsertProgressDto) {
     const lesson = await this.getLessonOrThrow(lessonId)

     // Gate enroll (ADMIN bypass)
     await this.enrollments.assertEnrolledOrAdmin(user, lesson.courseId)

     // USER không truy cập course/lesson unpublished (ẩn 404)
     if (user.role !== 'ADMIN') {
       if (!lesson.course.published) throw new NotFoundException('Lesson not found')
-      if (!lesson.published) throw new NotFoundException('Lesson not found')
     }

     // Gate lock (ADMIN bypass)
     await this.assertLessonUnlockedOrAdmin(user, lessonId, lesson.courseId)

     const percent = this.clampPercent(dto.percent)
     const lastPositionSec = dto.lastPositionSec
     const shouldComplete = percent !== undefined && percent >= 100

     return this.prisma.lessonProgress.upsert({
       where: { userId_lessonId: { userId: user.sub, lessonId } },

       create: {
         userId: user.sub,
         lessonId,
         status: shouldComplete ? ProgressStatus.COMPLETED : ProgressStatus.IN_PROGRESS,
         percent: percent ?? 0,
         lastPositionSec: lastPositionSec ?? 0,
         lastOpenedAt: new Date(),
         completedAt: shouldComplete ? new Date() : null,
       },

       update: {
         ...(percent !== undefined ? { percent } : {}),
         ...(lastPositionSec !== undefined ? { lastPositionSec } : {}),
@@ -116,78 +114,77 @@ export class ProgressService {
         lastPositionSec: true,
         lastOpenedAt: true,
         completedAt: true,
         updatedAt: true,
       },
     })
   }

   // POST /lessons/:id/complete
   async completeLesson(user: JwtUser, lessonId: number) {
     return this.upsertLessonProgress(user, lessonId, { percent: 100 })
   }

   // GET /me/progress
   myProgress(userId: number) {
     return this.prisma.lessonProgress.findMany({
       where: { userId },
       select: {
         lessonId: true,
         status: true,
         percent: true,
         lastPositionSec: true,
         lastOpenedAt: true,
         completedAt: true,
         updatedAt: true,
-        lesson: { select: { id: true, courseId: true, title: true, order: true, published: true } },
+        lesson: { select: { id: true, courseId: true, title: true, stt: true } },
       },
       orderBy: [{ lastOpenedAt: 'desc' }],
     })
   }

   // GET /me/courses/:courseId/progress
   // Return đúng shape cho frontend:
   // {
   //   courseId, totalLessons, completedLessons, percent,
   //   items: [{lessonId, status, seconds?, updatedAt?}]
   // }
   async getCourseProgress(user: JwtUser, courseId: number) {
     await this.enrollments.assertEnrolledOrAdmin(user, courseId)

     const lessons = await this.prisma.lesson.findMany({
       where: {
         courseId,
-        ...(user.role === 'ADMIN' ? {} : { published: true }),
       },
-      select: { id: true, order: true, published: true },
-      orderBy: [{ order: 'asc' }, { id: 'asc' }],
+      select: { id: true, stt: true },
+      orderBy: [{ stt: 'asc' }, { id: 'asc' }],
     })

     const progress = await this.prisma.lessonProgress.findMany({
       where: {
         userId: user.sub,
-        lesson: { courseId, ...(user.role === 'ADMIN' ? {} : { published: true }) },
+        lesson: { courseId },
       },
       select: {
         lessonId: true,
         status: true,
         lastPositionSec: true,
         lastOpenedAt: true,
         updatedAt: true,
       },
       orderBy: [{ lastOpenedAt: 'desc' }, { updatedAt: 'desc' }],
       take: 2000,
     })

     const progMap = new Map(progress.map((p) => [p.lessonId, p]))

     const totalLessons = lessons.length
     const completedLessons = lessons.filter((l) => progMap.get(l.id)?.status === ProgressStatus.COMPLETED).length
     const percentCourse = totalLessons === 0 ? 0 : Math.round((completedLessons / totalLessons) * 100)

     // items đúng kiểu LessonProgress[] cho FE Continue
     const items = lessons
       .map((l) => {
         const p = progMap.get(l.id)
         if (!p) return null
         return {
           lessonId: l.id,
