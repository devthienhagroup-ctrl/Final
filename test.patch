diff --git a/backend/ayanavitabackend/app/admin/src/App.tsx b/backend/ayanavitabackend/app/admin/src/App.tsx
index 37bdbecc6a3fe3ec8eb2585b5a7b4fc4a5ea281a..59edf006a935c317ea2abd1f5102b5972e79916b 100644
--- a/backend/ayanavitabackend/app/admin/src/App.tsx
+++ b/backend/ayanavitabackend/app/admin/src/App.tsx
@@ -1,38 +1,40 @@
 import React from "react";
 import { Navigate, Route, Routes } from "react-router-dom";

 import { Layout } from "./components/Layout";
 import { AuthProvider } from "./app/auth.store";
 import { RequireAuth } from "./app/guard";

 import { LoginPage } from "./pages/LoginPage";
 import { CmsPagesPage } from "./pages/CmsPagesPage";
 import { CmsEditPage } from "./pages/CmsEditPage";
 import { LeadsPage } from "./pages/LeadsPage";
 import { NotFound } from "./pages/NotFound";
+import { CatalogCrudPage } from "./pages/CatalogCrudPage";

 export default function App() {
   return (
     <AuthProvider>
       <Routes>
         <Route path="/login" element={<LoginPage />} />

         <Route
           path="/"
           element={
             <RequireAuth>
               <Layout />
             </RequireAuth>
           }
         >
           <Route index element={<Navigate to="/cms/pages" replace />} />
           <Route path="cms/pages" element={<CmsPagesPage />} />
           <Route path="cms/pages/:slug" element={<CmsEditPage />} />
           <Route path="leads" element={<LeadsPage />} />
+          <Route path="catalog" element={<CatalogCrudPage />} />
         </Route>

         <Route path="*" element={<NotFound />} />
       </Routes>
     </AuthProvider>
   );
 }
diff --git a/backend/ayanavitabackend/app/admin/src/components/Layout.tsx b/backend/ayanavitabackend/app/admin/src/components/Layout.tsx
index c87d797ef90b7e641732653c711cbd19f89f9cbf..d19a9821eb0c7b59740e4606ce0ad82b4b23cfd4 100644
--- a/backend/ayanavitabackend/app/admin/src/components/Layout.tsx
+++ b/backend/ayanavitabackend/app/admin/src/components/Layout.tsx
@@ -13,50 +13,51 @@ function NavItem({ to, label }: { to: string; label: string }) {
     </NavLink>
   );
 }

 export function Layout() {
   const { token, logout } = useAuth();
   const nav = useNavigate();

   return (
     <ToastProvider>
       <div className="topbar">
         <div className="row">
           <Link to="/" className="brand" aria-label="Home">
             <span className="dot" aria-hidden="true" />
             <div>
               <span className="g-text">AYANAVITA Admin</span>
               <div className="muted" style={{ fontSize: 12, fontWeight: 900, marginTop: 2 }}>
                 CMS â€¢ Leads â€¢ Publish
               </div>
             </div>
           </Link>

           <div className="nav">
             <NavItem to="/cms/pages" label="CMS Pages" />
             <NavItem to="/leads" label="Leads" />
+            <NavItem to="/catalog" label="Catalog" />

             <span className="pill" title="JWT token (short)">
               {token ? `${token.slice(0, 10)}â€¦` : "no-token"}
             </span>

             <button
               className="btn btn-danger"
               type="button"
               onClick={() => {
                 logout();
                 nav("/login", { replace: true });
               }}
             >
               Logout
             </button>
           </div>
         </div>
       </div>

       <div className="container">
         <Outlet />
       </div>
     </ToastProvider>
   );
 }
diff --git a/backend/ayanavitabackend/app/admin/src/pages/CatalogCrudPage.tsx b/backend/ayanavitabackend/app/admin/src/pages/CatalogCrudPage.tsx
new file mode 100644
index 0000000000000000000000000000000000000000..5ee62b2db6748d4d659223eb23d8e54c90f77ee3
--- /dev/null
+++ b/backend/ayanavitabackend/app/admin/src/pages/CatalogCrudPage.tsx
@@ -0,0 +1,106 @@
+import React, { useState } from 'react'
+import { useAuth } from '../app/auth.store'
+import { apiFetch } from '../api/client'
+
+const defaults: Record<string, string> = {
+  categories: JSON.stringify(
+    {
+      status: 'active',
+      translations: [
+        { languageCode: 'vi', name: 'ChÄƒm sÃ³c da', slug: 'cham-soc-da' },
+        { languageCode: 'en', name: 'Skincare', slug: 'skincare' },
+      ],
+    },
+    null,
+    2,
+  ),
+  products: JSON.stringify(
+    {
+      sku: 'SPA-SAMPLE-001',
+      categoryId: 1,
+      price: 489000,
+      status: 'active',
+      translations: [
+        { languageCode: 'vi', name: 'Serum Spa', slug: 'serum-spa' },
+        { languageCode: 'en', name: 'Spa Serum', slug: 'spa-serum' },
+      ],
+    },
+    null,
+    2,
+  ),
+  attributes: JSON.stringify(
+    {
+      code: 'material',
+      valueType: 'text',
+      translations: [
+        { languageCode: 'vi', displayName: 'Cháº¥t liá»‡u' },
+        { languageCode: 'en', displayName: 'Material' },
+      ],
+    },
+    null,
+    2,
+  ),
+  ingredients: JSON.stringify(
+    {
+      code: 'vitamin_c',
+      translations: [
+        { languageCode: 'vi', displayName: 'Vitamin C' },
+        { languageCode: 'en', displayName: 'Vitamin C' },
+      ],
+    },
+    null,
+    2,
+  ),
+}
+
+function Panel({ resource }: { resource: 'categories' | 'products' | 'attributes' | 'ingredients' }) {
+  const { token } = useAuth()
+  const [payload, setPayload] = useState(defaults[resource])
+  const [id, setId] = useState('')
+  const [result, setResult] = useState('')
+
+  const callApi = async (method: 'GET' | 'POST' | 'PATCH' | 'DELETE') => {
+    try {
+      const path = `/catalog/${resource}${id ? `/${id}` : ''}`
+      const body = method === 'POST' || method === 'PATCH' ? JSON.parse(payload) : undefined
+      const data = await apiFetch<any>(path, {
+        method,
+        token,
+        ...(body ? { body: JSON.stringify(body) } : {}),
+      })
+      setResult(JSON.stringify(data, null, 2))
+    } catch (error: any) {
+      setResult(error?.message || 'Request failed')
+    }
+  }
+
+  return (
+    <div className="card" style={{ marginBottom: 20 }}>
+      <h3 style={{ marginTop: 0, textTransform: 'capitalize' }}>{resource}</h3>
+      <div style={{ display: 'grid', gap: 8 }}>
+        <input className="input" placeholder="ID (for get one/patch/delete)" value={id} onChange={(e) => setId(e.target.value)} />
+        <textarea className="input" style={{ minHeight: 180, fontFamily: 'monospace' }} value={payload} onChange={(e) => setPayload(e.target.value)} />
+        <div style={{ display: 'flex', gap: 8, flexWrap: 'wrap' }}>
+          <button className="btn" onClick={() => callApi('GET')}>GET</button>
+          <button className="btn btn-primary" onClick={() => callApi('POST')}>POST</button>
+          <button className="btn" onClick={() => callApi('PATCH')}>PATCH</button>
+          <button className="btn btn-danger" onClick={() => callApi('DELETE')}>DELETE</button>
+        </div>
+        <pre style={{ whiteSpace: 'pre-wrap', margin: 0 }}>{result}</pre>
+      </div>
+    </div>
+  )
+}
+
+export function CatalogCrudPage() {
+  return (
+    <div>
+      <h2>Catalog CRUD (Simple Admin)</h2>
+      <p className="muted">Trang Ä‘Æ¡n giáº£n Ä‘á»ƒ tÆ°Æ¡ng tÃ¡c API CRUD cho category, sáº£n pháº©m, thuá»™c tÃ­nh, thÃ nh pháº§n.</p>
+      <Panel resource="categories" />
+      <Panel resource="products" />
+      <Panel resource="attributes" />
+      <Panel resource="ingredients" />
+    </div>
+  )
+}
diff --git a/backend/ayanavitabackend/app/api/prisma/migrations/20260225000100_catalog_i18n/migration.sql b/backend/ayanavitabackend/app/api/prisma/migrations/20260225000100_catalog_i18n/migration.sql
new file mode 100644
index 0000000000000000000000000000000000000000..39e1a7d257fa839f762975207c4b6c5431d6a65e
--- /dev/null
+++ b/backend/ayanavitabackend/app/api/prisma/migrations/20260225000100_catalog_i18n/migration.sql
@@ -0,0 +1,130 @@
+-- Languages
+CREATE TABLE `languages` (
+  `code` VARCHAR(10) NOT NULL,
+  `name` VARCHAR(50) NOT NULL,
+  `is_active` BOOLEAN NOT NULL DEFAULT TRUE,
+  PRIMARY KEY (`code`)
+) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
+
+INSERT INTO `languages` (`code`, `name`, `is_active`) VALUES
+  ('vi', 'Tiáº¿ng Viá»‡t', TRUE),
+  ('en', 'English', TRUE),
+  ('de', 'Deutsch', TRUE)
+ON DUPLICATE KEY UPDATE `name` = VALUES(`name`), `is_active` = VALUES(`is_active`);
+
+-- Categories + translations
+CREATE TABLE `categories` (
+  `id` BIGINT NOT NULL AUTO_INCREMENT,
+  `parent_id` BIGINT NULL,
+  `status` VARCHAR(20) NOT NULL DEFAULT 'active',
+  PRIMARY KEY (`id`),
+  CONSTRAINT `fk_category_parent` FOREIGN KEY (`parent_id`) REFERENCES `categories`(`id`) ON DELETE SET NULL
+) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
+
+CREATE TABLE `category_translations` (
+  `category_id` BIGINT NOT NULL,
+  `language_code` VARCHAR(10) NOT NULL,
+  `name` VARCHAR(255) NOT NULL,
+  `slug` VARCHAR(255) NOT NULL,
+  `description` TEXT NULL,
+  PRIMARY KEY (`category_id`, `language_code`),
+  CONSTRAINT `fk_ct_category` FOREIGN KEY (`category_id`) REFERENCES `categories`(`id`) ON DELETE CASCADE,
+  CONSTRAINT `fk_ct_language` FOREIGN KEY (`language_code`) REFERENCES `languages`(`code`) ON DELETE RESTRICT
+) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
+
+CREATE UNIQUE INDEX `uq_category_slug_per_lang` ON `category_translations`(`language_code`, `slug`);
+
+-- Products + translations
+CREATE TABLE `products` (
+  `id` BIGINT NOT NULL AUTO_INCREMENT,
+  `sku` VARCHAR(64) NOT NULL,
+  `category_id` BIGINT NULL,
+  `price` DECIMAL(18,2) NOT NULL DEFAULT 0,
+  `status` VARCHAR(20) NOT NULL DEFAULT 'active',
+  `created_at` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
+  `updated_at` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
+  PRIMARY KEY (`id`),
+  UNIQUE INDEX `products_sku_key`(`sku`),
+  CONSTRAINT `fk_product_category` FOREIGN KEY (`category_id`) REFERENCES `categories`(`id`) ON DELETE SET NULL
+) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
+
+CREATE TABLE `product_translations` (
+  `product_id` BIGINT NOT NULL,
+  `language_code` VARCHAR(10) NOT NULL,
+  `name` VARCHAR(255) NOT NULL,
+  `slug` VARCHAR(255) NOT NULL,
+  `short_description` VARCHAR(500) NULL,
+  `description` TEXT NULL,
+  PRIMARY KEY (`product_id`, `language_code`),
+  CONSTRAINT `fk_pt_product` FOREIGN KEY (`product_id`) REFERENCES `products`(`id`) ON DELETE CASCADE,
+  CONSTRAINT `fk_pt_language` FOREIGN KEY (`language_code`) REFERENCES `languages`(`code`) ON DELETE RESTRICT
+) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
+
+CREATE UNIQUE INDEX `uq_product_slug_per_lang` ON `product_translations`(`language_code`, `slug`);
+CREATE INDEX `idx_product_translation_lang` ON `product_translations`(`language_code`);
+
+-- Attributes
+CREATE TABLE `attribute_keys` (
+  `id` BIGINT NOT NULL AUTO_INCREMENT,
+  `code` VARCHAR(100) NOT NULL,
+  `value_type` VARCHAR(20) NOT NULL DEFAULT 'text',
+  `is_active` BOOLEAN NOT NULL DEFAULT TRUE,
+  PRIMARY KEY (`id`),
+  UNIQUE INDEX `attribute_keys_code_key`(`code`)
+) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
+
+CREATE TABLE `attribute_key_translations` (
+  `attribute_key_id` BIGINT NOT NULL,
+  `language_code` VARCHAR(10) NOT NULL,
+  `display_name` VARCHAR(255) NOT NULL,
+  `description` TEXT NULL,
+  PRIMARY KEY (`attribute_key_id`, `language_code`),
+  CONSTRAINT `fk_akt_key` FOREIGN KEY (`attribute_key_id`) REFERENCES `attribute_keys`(`id`) ON DELETE CASCADE,
+  CONSTRAINT `fk_akt_lang` FOREIGN KEY (`language_code`) REFERENCES `languages`(`code`) ON DELETE RESTRICT
+) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
+
+CREATE TABLE `product_attributes` (
+  `product_id` BIGINT NOT NULL,
+  `attribute_key_id` BIGINT NOT NULL,
+  `value_text` TEXT NULL,
+  `value_number` DECIMAL(18,4) NULL,
+  `value_boolean` BOOLEAN NULL,
+  `value_json` TEXT NULL,
+  PRIMARY KEY (`product_id`, `attribute_key_id`),
+  CONSTRAINT `fk_pa_product` FOREIGN KEY (`product_id`) REFERENCES `products`(`id`) ON DELETE CASCADE,
+  CONSTRAINT `fk_pa_key` FOREIGN KEY (`attribute_key_id`) REFERENCES `attribute_keys`(`id`) ON DELETE RESTRICT
+) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
+
+CREATE INDEX `idx_product_attribute_key` ON `product_attributes`(`attribute_key_id`);
+
+-- Ingredients
+CREATE TABLE `ingredient_keys` (
+  `id` BIGINT NOT NULL AUTO_INCREMENT,
+  `code` VARCHAR(100) NOT NULL,
+  `is_active` BOOLEAN NOT NULL DEFAULT TRUE,
+  PRIMARY KEY (`id`),
+  UNIQUE INDEX `ingredient_keys_code_key`(`code`)
+) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
+
+CREATE TABLE `ingredient_key_translations` (
+  `ingredient_key_id` BIGINT NOT NULL,
+  `language_code` VARCHAR(10) NOT NULL,
+  `display_name` VARCHAR(255) NOT NULL,
+  `description` TEXT NULL,
+  PRIMARY KEY (`ingredient_key_id`, `language_code`),
+  CONSTRAINT `fk_ikt_key` FOREIGN KEY (`ingredient_key_id`) REFERENCES `ingredient_keys`(`id`) ON DELETE CASCADE,
+  CONSTRAINT `fk_ikt_lang` FOREIGN KEY (`language_code`) REFERENCES `languages`(`code`) ON DELETE RESTRICT
+) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
+
+CREATE TABLE `product_ingredients` (
+  `product_id` BIGINT NOT NULL,
+  `ingredient_key_id` BIGINT NOT NULL,
+  `value` VARCHAR(255) NULL,
+  `note` TEXT NULL,
+  `sort_order` INT NOT NULL DEFAULT 0,
+  PRIMARY KEY (`product_id`, `ingredient_key_id`),
+  CONSTRAINT `fk_pi_product` FOREIGN KEY (`product_id`) REFERENCES `products`(`id`) ON DELETE CASCADE,
+  CONSTRAINT `fk_pi_key` FOREIGN KEY (`ingredient_key_id`) REFERENCES `ingredient_keys`(`id`) ON DELETE RESTRICT
+) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
+
+CREATE INDEX `idx_product_ingredient_sort` ON `product_ingredients`(`product_id`, `sort_order`);
diff --git a/backend/ayanavitabackend/app/api/prisma/schema.prisma b/backend/ayanavitabackend/app/api/prisma/schema.prisma
index bcc1cb3b239c1e20a16fd8726350a4a3905f61bd..42aee322f13c50bc41fe16151bd5a9e9809c970f 100644
--- a/backend/ayanavitabackend/app/api/prisma/schema.prisma
+++ b/backend/ayanavitabackend/app/api/prisma/schema.prisma
@@ -283,25 +283,182 @@ model MediaAsset {
   mimeType String  @db.VarChar(100)
   size     Int
   width    Int?
   height   Int?
   alt      String? @db.VarChar(255)
   tags     String? @db.Text

   createdBy Int?
   createdAt DateTime @default(now())

   user User? @relation(fields: [createdBy], references: [id], onDelete: SetNull)

   @@index([createdBy, createdAt])
 }

 model PublicLead {
   id        Int      @id @default(autoincrement())
   type      String   @db.VarChar(30) // "book" | "talk"
   payload   Json
   createdAt DateTime @default(now())

   @@index([type, createdAt])
 }


+
+
+model Language {
+  code     String  @id @db.VarChar(10)
+  name     String  @db.VarChar(50)
+  isActive Boolean @default(true) @map("is_active")
+
+  categoryTranslations     CategoryTranslation[]
+  productTranslations      ProductTranslation[]
+  attributeKeyTranslations AttributeKeyTranslation[]
+  ingredientKeyTranslations IngredientKeyTranslation[]
+
+  @@map("languages")
+}
+
+model Category {
+  id       BigInt   @id @default(autoincrement())
+  parentId BigInt?  @map("parent_id")
+  status   String   @default("active") @db.VarChar(20)
+
+  parent   Category?  @relation("CategoryParent", fields: [parentId], references: [id], onDelete: SetNull)
+  children Category[] @relation("CategoryParent")
+
+  translations CategoryTranslation[]
+  products     CatalogProduct[]
+
+  @@map("categories")
+}
+
+model CategoryTranslation {
+  categoryId   BigInt @map("category_id")
+  languageCode String @map("language_code") @db.VarChar(10)
+  name         String @db.VarChar(255)
+  slug         String @db.VarChar(255)
+  description  String? @db.Text
+
+  category Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)
+  language Language @relation(fields: [languageCode], references: [code], onDelete: Restrict)
+
+  @@id([categoryId, languageCode])
+  @@unique([languageCode, slug], map: "uq_category_slug_per_lang")
+  @@map("category_translations")
+}
+
+model CatalogProduct {
+  id         BigInt   @id @default(autoincrement())
+  sku        String   @unique @db.VarChar(64)
+  categoryId BigInt?  @map("category_id")
+  price      Decimal  @default(0) @db.Decimal(18, 2)
+  status     String   @default("active") @db.VarChar(20)
+  createdAt  DateTime @default(now()) @map("created_at")
+  updatedAt  DateTime @updatedAt @map("updated_at")
+
+  category     Category? @relation(fields: [categoryId], references: [id], onDelete: SetNull)
+  translations ProductTranslation[]
+  attributes   ProductAttribute[]
+  ingredients  ProductIngredient[]
+
+  @@map("products")
+}
+
+model ProductTranslation {
+  productId         BigInt @map("product_id")
+  languageCode      String @map("language_code") @db.VarChar(10)
+  name              String @db.VarChar(255)
+  slug              String @db.VarChar(255)
+  shortDescription  String? @map("short_description") @db.VarChar(500)
+  description       String? @db.Text
+
+  product  CatalogProduct @relation(fields: [productId], references: [id], onDelete: Cascade)
+  language Language       @relation(fields: [languageCode], references: [code], onDelete: Restrict)
+
+  @@id([productId, languageCode])
+  @@unique([languageCode, slug], map: "uq_product_slug_per_lang")
+  @@index([languageCode], map: "idx_product_translation_lang")
+  @@map("product_translations")
+}
+
+model AttributeKey {
+  id        BigInt  @id @default(autoincrement())
+  code      String  @unique @db.VarChar(100)
+  valueType String  @default("text") @map("value_type") @db.VarChar(20)
+  isActive  Boolean @default(true) @map("is_active")
+
+  translations AttributeKeyTranslation[]
+  products     ProductAttribute[]
+
+  @@map("attribute_keys")
+}
+
+model AttributeKeyTranslation {
+  attributeKeyId BigInt @map("attribute_key_id")
+  languageCode   String @map("language_code") @db.VarChar(10)
+  displayName    String @map("display_name") @db.VarChar(255)
+  description    String? @db.Text
+
+  attributeKey AttributeKey @relation(fields: [attributeKeyId], references: [id], onDelete: Cascade)
+  language     Language     @relation(fields: [languageCode], references: [code], onDelete: Restrict)
+
+  @@id([attributeKeyId, languageCode])
+  @@map("attribute_key_translations")
+}
+
+model ProductAttribute {
+  productId      BigInt @map("product_id")
+  attributeKeyId BigInt @map("attribute_key_id")
+  valueText      String? @map("value_text") @db.Text
+  valueNumber    Decimal? @map("value_number") @db.Decimal(18, 4)
+  valueBoolean   Boolean? @map("value_boolean")
+  valueJson      String? @map("value_json") @db.Text
+
+  product      CatalogProduct @relation(fields: [productId], references: [id], onDelete: Cascade)
+  attributeKey AttributeKey   @relation(fields: [attributeKeyId], references: [id], onDelete: Restrict)
+
+  @@id([productId, attributeKeyId])
+  @@index([attributeKeyId], map: "idx_product_attribute_key")
+  @@map("product_attributes")
+}
+
+model IngredientKey {
+  id       BigInt  @id @default(autoincrement())
+  code     String  @unique @db.VarChar(100)
+  isActive Boolean @default(true) @map("is_active")
+
+  translations IngredientKeyTranslation[]
+  products     ProductIngredient[]
+
+  @@map("ingredient_keys")
+}
+
+model IngredientKeyTranslation {
+  ingredientKeyId BigInt @map("ingredient_key_id")
+  languageCode    String @map("language_code") @db.VarChar(10)
+  displayName     String @map("display_name") @db.VarChar(255)
+  description     String? @db.Text
+
+  ingredientKey IngredientKey @relation(fields: [ingredientKeyId], references: [id], onDelete: Cascade)
+  language      Language      @relation(fields: [languageCode], references: [code], onDelete: Restrict)
+
+  @@id([ingredientKeyId, languageCode])
+  @@map("ingredient_key_translations")
+}
+
+model ProductIngredient {
+  productId       BigInt @map("product_id")
+  ingredientKeyId BigInt @map("ingredient_key_id")
+  value           String? @db.VarChar(255)
+  note            String? @db.Text
+  sortOrder       Int @default(0) @map("sort_order")
+
+  product       CatalogProduct @relation(fields: [productId], references: [id], onDelete: Cascade)
+  ingredientKey IngredientKey  @relation(fields: [ingredientKeyId], references: [id], onDelete: Restrict)
+
+  @@id([productId, ingredientKeyId])
+  @@index([productId, sortOrder], map: "idx_product_ingredient_sort")
+  @@map("product_ingredients")
+}
diff --git a/backend/ayanavitabackend/app/api/prisma/seed.ts b/backend/ayanavitabackend/app/api/prisma/seed.ts
index 120cd6089ea5de88e2dd9ccc7dc64f967ede0e12..cb7df4030e77e2c99ef05738bc05283043aabfee 100644
--- a/backend/ayanavitabackend/app/api/prisma/seed.ts
+++ b/backend/ayanavitabackend/app/api/prisma/seed.ts
@@ -1,60 +1,205 @@
 import { PrismaClient } from '@prisma/client'
 import * as bcrypt from 'bcrypt'

 const prisma = new PrismaClient()

 function slugify(input: string) {
   return input
     .toLowerCase()
     .trim()
     .normalize('NFD')
     .replace(/[\u0300-\u036f]/g, '')
     .replace(/[^a-z0-9]+/g, '-')
     .replace(/(^-|-$)+/g, '')
 }

+async function seedCatalog() {
+  await prisma.language.upsert({ where: { code: 'vi' }, update: { name: 'Tiáº¿ng Viá»‡t' }, create: { code: 'vi', name: 'Tiáº¿ng Viá»‡t' } })
+  await prisma.language.upsert({ where: { code: 'en' }, update: { name: 'English' }, create: { code: 'en', name: 'English' } })
+  await prisma.language.upsert({ where: { code: 'de' }, update: { name: 'Deutsch' }, create: { code: 'de', name: 'Deutsch' } })
+
+  let skincare = await prisma.category.findFirst({
+    where: { translations: { some: { languageCode: 'vi', slug: 'cham-soc-da' } } },
+  })
+
+  if (!skincare) {
+    skincare = await prisma.category.create({
+      data: {
+        status: 'active',
+        translations: {
+          create: [
+            { languageCode: 'vi', name: 'ChÄƒm sÃ³c da', slug: 'cham-soc-da', description: 'Danh má»¥c sáº£n pháº©m skincare.' },
+            { languageCode: 'en', name: 'Skincare', slug: 'skincare', description: 'Skincare product category.' },
+            { languageCode: 'de', name: 'Hautpflege', slug: 'hautpflege', description: 'Kategorie fÃ¼r Hautpflegeprodukte.' },
+          ],
+        },
+      },
+    })
+  }
+
+  const [materialKey, volumeKey] = await Promise.all([
+    prisma.attributeKey.upsert({
+      where: { code: 'material' },
+      update: {},
+      create: {
+        code: 'material',
+        valueType: 'text',
+        translations: {
+          create: [
+            { languageCode: 'vi', displayName: 'Cháº¥t liá»‡u', description: 'ThÃ nh pháº§n cháº¥t liá»‡u chÃ­nh' },
+            { languageCode: 'en', displayName: 'Material', description: 'Main material information' },
+            { languageCode: 'de', displayName: 'Material', description: 'Hauptmaterial-Information' },
+          ],
+        },
+      },
+    }),
+    prisma.attributeKey.upsert({
+      where: { code: 'volume_ml' },
+      update: {},
+      create: {
+        code: 'volume_ml',
+        valueType: 'number',
+        translations: {
+          create: [
+            { languageCode: 'vi', displayName: 'Dung tÃ­ch (ml)' },
+            { languageCode: 'en', displayName: 'Volume (ml)' },
+            { languageCode: 'de', displayName: 'Volumen (ml)' },
+          ],
+        },
+      },
+    }),
+  ])
+
+  const [vitaminCKey, aloeKey] = await Promise.all([
+    prisma.ingredientKey.upsert({
+      where: { code: 'vitamin_c' },
+      update: {},
+      create: {
+        code: 'vitamin_c',
+        translations: {
+          create: [
+            { languageCode: 'vi', displayName: 'Vitamin C' },
+            { languageCode: 'en', displayName: 'Vitamin C' },
+            { languageCode: 'de', displayName: 'Vitamin C' },
+          ],
+        },
+      },
+    }),
+    prisma.ingredientKey.upsert({
+      where: { code: 'aloe_vera' },
+      update: {},
+      create: {
+        code: 'aloe_vera',
+        translations: {
+          create: [
+            { languageCode: 'vi', displayName: 'Nha Ä‘am' },
+            { languageCode: 'en', displayName: 'Aloe Vera' },
+            { languageCode: 'de', displayName: 'Aloe Vera' },
+          ],
+        },
+      },
+    }),
+  ])
+
+  const sku = 'SPA-SERUM-001'
+  const product = await prisma.catalogProduct.upsert({
+    where: { sku },
+    update: {
+      categoryId: skincare.id,
+      price: 489000,
+      status: 'active',
+    },
+    create: {
+      sku,
+      categoryId: skincare.id,
+      price: 489000,
+      status: 'active',
+      translations: {
+        create: [
+          {
+            languageCode: 'vi',
+            name: 'Serum Spa Phá»¥c Há»“i',
+            slug: slugify('serum-spa-phuc-hoi'),
+            shortDescription: 'DÆ°á»¡ng sÃ¡ng vÃ  lÃ m dá»‹u da sau liá»‡u trÃ¬nh spa.',
+            description: 'Serum giÃ u vitamin C vÃ  nha Ä‘am, phÃ¹ há»£p dÃ¹ng háº±ng ngÃ y.',
+          },
+          {
+            languageCode: 'en',
+            name: 'Spa Recovery Serum',
+            slug: slugify('spa-recovery-serum'),
+            shortDescription: 'Brightens and calms skin after spa treatment.',
+            description: 'A daily serum with vitamin C and aloe vera.',
+          },
+          {
+            languageCode: 'de',
+            name: 'Spa Regenerationsserum',
+            slug: slugify('spa-regenerationsserum'),
+            shortDescription: 'FÃ¼r strahlende und beruhigte Haut nach Spa-Behandlung.',
+            description: 'TÃ¤gliches Serum mit Vitamin C und Aloe Vera.',
+          },
+        ],
+      },
+    },
+  })
+
+  await prisma.productAttribute.upsert({
+    where: { productId_attributeKeyId: { productId: product.id, attributeKeyId: materialKey.id } },
+    update: { valueText: 'Glass bottle' },
+    create: { productId: product.id, attributeKeyId: materialKey.id, valueText: 'Glass bottle' },
+  })
+
+  await prisma.productAttribute.upsert({
+    where: { productId_attributeKeyId: { productId: product.id, attributeKeyId: volumeKey.id } },
+    update: { valueNumber: 30 },
+    create: { productId: product.id, attributeKeyId: volumeKey.id, valueNumber: 30 },
+  })
+
+  await prisma.productIngredient.upsert({
+    where: { productId_ingredientKeyId: { productId: product.id, ingredientKeyId: vitaminCKey.id } },
+    update: { value: '10mg', sortOrder: 1 },
+    create: { productId: product.id, ingredientKeyId: vitaminCKey.id, value: '10mg', sortOrder: 1 },
+  })
+
+  await prisma.productIngredient.upsert({
+    where: { productId_ingredientKeyId: { productId: product.id, ingredientKeyId: aloeKey.id } },
+    update: { value: '5%', sortOrder: 2 },
+    create: { productId: product.id, ingredientKeyId: aloeKey.id, value: '5%', sortOrder: 2 },
+  })
+}
+
 async function main() {
-  // ðŸ” HASH PASSWORD
   const passwordHash = await bcrypt.hash('123456', 10)

-  // ðŸ‘¤ USER TEST (CHá»ˆ 1 Láº¦N â€“ PASSWORD ÄÃƒ HASH)
   const user = await prisma.user.upsert({
     where: { email: 'test@ayanavita.com' },
     update: {},
     create: {
       email: 'test@ayanavita.com',
       password: passwordHash,
       name: 'Test User',
       role: 'USER',
     },
   })

-  // ðŸ“š COURSES TEST
   const seedCourses = [
     { title: 'Course 1 - Basic', price: 99000 },
     { title: 'Course 2 - Pro', price: 199000 },
     { title: 'Course 3 - Master', price: 299000 },
-  ].map((c) => ({
-    ...c,
-    slug: slugify(c.title),
-  }))
+  ].map((c) => ({ ...c, slug: slugify(c.title) }))

-  await prisma.course.createMany({
-    data: seedCourses,
-    skipDuplicates: true,
-  })
+  await prisma.course.createMany({ data: seedCourses, skipDuplicates: true })
+  await seedCatalog()

   const courses = await prisma.course.findMany({ orderBy: { id: 'asc' } })
-
   console.log('ðŸŒ± Seed OK')
-  console.log({ userId: user.id, courses })
+  console.log({ userId: user.id, coursesCount: courses.length })
 }

 main()
   .catch((e) => {
     console.error(e)
     process.exit(1)
   })
   .finally(async () => {
     await prisma.$disconnect()
   })
diff --git a/backend/ayanavitabackend/app/api/src/app.module.ts b/backend/ayanavitabackend/app/api/src/app.module.ts
index 9f2a8b14037768f91719a92f91680b8110c06e3b..863ebd5298fd9b90488f84a937df04fdea2b935a 100644
--- a/backend/ayanavitabackend/app/api/src/app.module.ts
+++ b/backend/ayanavitabackend/app/api/src/app.module.ts
@@ -1,30 +1,32 @@
 import { Module } from '@nestjs/common'
 import { PrismaModule } from './prisma/prisma.module'
 import { UsersModule } from './users/users.module'
 import { AuthModule } from './auth/auth.module'
 import { CoursesModule } from './courses/courses.module'
 import { LessonsModule } from './lessons/lessons.module'
 import { EnrollmentsModule } from './enrollments/enrollments.module'
 import { OrdersModule } from './orders/orders.module'
 import { ProgressModule } from './progress/progress.module'
 import { CmsModule } from './cms/cms.module'
+import { CatalogModule } from './catalog/catalog.module'




 @Module({
   imports: [
     PrismaModule,
     UsersModule,
     AuthModule,
     CoursesModule,
     LessonsModule,
     EnrollmentsModule,
     ProgressModule,
     OrdersModule,
     CmsModule,
+    CatalogModule,


   ],
 })
 export class AppModule {}
diff --git a/backend/ayanavitabackend/app/api/src/catalog/attributes.controller.ts b/backend/ayanavitabackend/app/api/src/catalog/attributes.controller.ts
new file mode 100644
index 0000000000000000000000000000000000000000..1522f2212b66b2d5c6cbde8b8ec3f99ba13f30ef
--- /dev/null
+++ b/backend/ayanavitabackend/app/api/src/catalog/attributes.controller.ts
@@ -0,0 +1,33 @@
+import { Body, Controller, Delete, Get, Param, ParseIntPipe, Patch, Post } from '@nestjs/common'
+import { AttributesService } from './attributes.service'
+import { CreateAttributeKeyDto, UpdateAttributeKeyDto } from './dto/attribute.dto'
+
+@Controller('catalog/attributes')
+export class AttributesController {
+  constructor(private readonly service: AttributesService) {}
+
+  @Get()
+  findAll() {
+    return this.service.findAll()
+  }
+
+  @Get(':id')
+  findOne(@Param('id', ParseIntPipe) id: number) {
+    return this.service.findOne(id)
+  }
+
+  @Post()
+  create(@Body() dto: CreateAttributeKeyDto) {
+    return this.service.create(dto)
+  }
+
+  @Patch(':id')
+  update(@Param('id', ParseIntPipe) id: number, @Body() dto: UpdateAttributeKeyDto) {
+    return this.service.update(id, dto)
+  }
+
+  @Delete(':id')
+  remove(@Param('id', ParseIntPipe) id: number) {
+    return this.service.remove(id)
+  }
+}
diff --git a/backend/ayanavitabackend/app/api/src/catalog/attributes.service.ts b/backend/ayanavitabackend/app/api/src/catalog/attributes.service.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d521f139dae5cbce0c7c6f66d7528e8d5e431e90
--- /dev/null
+++ b/backend/ayanavitabackend/app/api/src/catalog/attributes.service.ts
@@ -0,0 +1,66 @@
+import { Injectable, NotFoundException } from '@nestjs/common'
+import { PrismaService } from '../prisma/prisma.service'
+import { CreateAttributeKeyDto, UpdateAttributeKeyDto } from './dto/attribute.dto'
+import { normalizeBigInt } from './utils'
+
+@Injectable()
+export class AttributesService {
+  constructor(private readonly prisma: PrismaService) {}
+
+  async findAll() {
+    const rows = await this.prisma.attributeKey.findMany({
+      include: { translations: true },
+      orderBy: { id: 'desc' },
+    })
+    return normalizeBigInt(rows)
+  }
+
+  async findOne(id: number) {
+    const row = await this.prisma.attributeKey.findUnique({
+      where: { id: BigInt(id) },
+      include: { translations: true },
+    })
+    if (!row) throw new NotFoundException('Attribute key not found')
+    return normalizeBigInt(row)
+  }
+
+  async create(dto: CreateAttributeKeyDto) {
+    const row = await this.prisma.attributeKey.create({
+      data: {
+        code: dto.code,
+        valueType: dto.valueType ?? 'text',
+        isActive: dto.isActive ?? true,
+        translations: { create: dto.translations },
+      },
+      include: { translations: true },
+    })
+    return normalizeBigInt(row)
+  }
+
+  async update(id: number, dto: UpdateAttributeKeyDto) {
+    await this.findOne(id)
+    const row = await this.prisma.$transaction(async (tx) => {
+      if (dto.translations) {
+        await tx.attributeKeyTranslation.deleteMany({ where: { attributeKeyId: BigInt(id) } })
+      }
+
+      return tx.attributeKey.update({
+        where: { id: BigInt(id) },
+        data: {
+          code: dto.code,
+          valueType: dto.valueType,
+          isActive: dto.isActive,
+          translations: dto.translations ? { create: dto.translations } : undefined,
+        },
+        include: { translations: true },
+      })
+    })
+    return normalizeBigInt(row)
+  }
+
+  async remove(id: number) {
+    await this.findOne(id)
+    const row = await this.prisma.attributeKey.delete({ where: { id: BigInt(id) } })
+    return normalizeBigInt(row)
+  }
+}
diff --git a/backend/ayanavitabackend/app/api/src/catalog/catalog.module.ts b/backend/ayanavitabackend/app/api/src/catalog/catalog.module.ts
new file mode 100644
index 0000000000000000000000000000000000000000..fac77235edb6798446244b604a19c9e9a9a9aeb3
--- /dev/null
+++ b/backend/ayanavitabackend/app/api/src/catalog/catalog.module.ts
@@ -0,0 +1,15 @@
+import { Module } from '@nestjs/common'
+import { CategoriesController } from './categories.controller'
+import { CategoriesService } from './categories.service'
+import { ProductsController } from './products.controller'
+import { ProductsService } from './products.service'
+import { AttributesController } from './attributes.controller'
+import { AttributesService } from './attributes.service'
+import { IngredientsController } from './ingredients.controller'
+import { IngredientsService } from './ingredients.service'
+
+@Module({
+  controllers: [CategoriesController, ProductsController, AttributesController, IngredientsController],
+  providers: [CategoriesService, ProductsService, AttributesService, IngredientsService],
+})
+export class CatalogModule {}
diff --git a/backend/ayanavitabackend/app/api/src/catalog/categories.controller.ts b/backend/ayanavitabackend/app/api/src/catalog/categories.controller.ts
new file mode 100644
index 0000000000000000000000000000000000000000..164dc15f24b97efe695d73bd1fa5f8a79a8e7c66
--- /dev/null
+++ b/backend/ayanavitabackend/app/api/src/catalog/categories.controller.ts
@@ -0,0 +1,33 @@
+import { Body, Controller, Delete, Get, Param, ParseIntPipe, Patch, Post } from '@nestjs/common'
+import { CategoriesService } from './categories.service'
+import { CreateCategoryDto, UpdateCategoryDto } from './dto/category.dto'
+
+@Controller('catalog/categories')
+export class CategoriesController {
+  constructor(private readonly service: CategoriesService) {}
+
+  @Get()
+  findAll() {
+    return this.service.findAll()
+  }
+
+  @Get(':id')
+  findOne(@Param('id', ParseIntPipe) id: number) {
+    return this.service.findOne(id)
+  }
+
+  @Post()
+  create(@Body() dto: CreateCategoryDto) {
+    return this.service.create(dto)
+  }
+
+  @Patch(':id')
+  update(@Param('id', ParseIntPipe) id: number, @Body() dto: UpdateCategoryDto) {
+    return this.service.update(id, dto)
+  }
+
+  @Delete(':id')
+  remove(@Param('id', ParseIntPipe) id: number) {
+    return this.service.remove(id)
+  }
+}
diff --git a/backend/ayanavitabackend/app/api/src/catalog/categories.service.ts b/backend/ayanavitabackend/app/api/src/catalog/categories.service.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0cd390c813a45f820a0dafe6b26ff727c2373fe6
--- /dev/null
+++ b/backend/ayanavitabackend/app/api/src/catalog/categories.service.ts
@@ -0,0 +1,66 @@
+import { Injectable, NotFoundException } from '@nestjs/common'
+import { PrismaService } from '../prisma/prisma.service'
+import { CreateCategoryDto, UpdateCategoryDto } from './dto/category.dto'
+import { normalizeBigInt } from './utils'
+
+@Injectable()
+export class CategoriesService {
+  constructor(private readonly prisma: PrismaService) {}
+
+  async findAll() {
+    const rows = await this.prisma.category.findMany({
+      include: { translations: true },
+      orderBy: { id: 'desc' },
+    })
+    return normalizeBigInt(rows)
+  }
+
+  async findOne(id: number) {
+    const row = await this.prisma.category.findUnique({
+      where: { id: BigInt(id) },
+      include: { translations: true },
+    })
+    if (!row) throw new NotFoundException('Category not found')
+    return normalizeBigInt(row)
+  }
+
+  async create(dto: CreateCategoryDto) {
+    const row = await this.prisma.category.create({
+      data: {
+        parentId: dto.parentId ? BigInt(dto.parentId) : null,
+        status: dto.status ?? 'active',
+        translations: { create: dto.translations },
+      },
+      include: { translations: true },
+    })
+    return normalizeBigInt(row)
+  }
+
+  async update(id: number, dto: UpdateCategoryDto) {
+    await this.findOne(id)
+
+    const row = await this.prisma.$transaction(async (tx) => {
+      if (dto.translations) {
+        await tx.categoryTranslation.deleteMany({ where: { categoryId: BigInt(id) } })
+      }
+
+      return tx.category.update({
+        where: { id: BigInt(id) },
+        data: {
+          parentId: dto.parentId === undefined ? undefined : dto.parentId === null ? null : BigInt(dto.parentId),
+          status: dto.status,
+          translations: dto.translations ? { create: dto.translations } : undefined,
+        },
+        include: { translations: true },
+      })
+    })
+
+    return normalizeBigInt(row)
+  }
+
+  async remove(id: number) {
+    await this.findOne(id)
+    const row = await this.prisma.category.delete({ where: { id: BigInt(id) } })
+    return normalizeBigInt(row)
+  }
+}
diff --git a/backend/ayanavitabackend/app/api/src/catalog/dto/attribute.dto.ts b/backend/ayanavitabackend/app/api/src/catalog/dto/attribute.dto.ts
new file mode 100644
index 0000000000000000000000000000000000000000..10fa6eec337f4c77044a308285fbb5b8dbabd6df
--- /dev/null
+++ b/backend/ayanavitabackend/app/api/src/catalog/dto/attribute.dto.ts
@@ -0,0 +1,69 @@
+import { Type } from 'class-transformer'
+import {
+  IsArray,
+  IsBoolean,
+  IsNotEmpty,
+  IsOptional,
+  IsString,
+  MaxLength,
+  ValidateNested,
+} from 'class-validator'
+
+export class AttributeTranslationDto {
+  @IsString()
+  @MaxLength(10)
+  languageCode!: string
+
+  @IsString()
+  @IsNotEmpty()
+  @MaxLength(255)
+  displayName!: string
+
+  @IsOptional()
+  @IsString()
+  description?: string
+}
+
+export class CreateAttributeKeyDto {
+  @IsString()
+  @MaxLength(100)
+  code!: string
+
+  @IsOptional()
+  @IsString()
+  @MaxLength(20)
+  valueType?: string
+
+  @IsOptional()
+  @Type(() => Boolean)
+  @IsBoolean()
+  isActive?: boolean
+
+  @IsArray()
+  @ValidateNested({ each: true })
+  @Type(() => AttributeTranslationDto)
+  translations!: AttributeTranslationDto[]
+}
+
+export class UpdateAttributeKeyDto {
+  @IsOptional()
+  @IsString()
+  @MaxLength(100)
+  code?: string
+
+  @IsOptional()
+  @IsString()
+  @MaxLength(20)
+  valueType?: string
+
+  @IsOptional()
+  @Type(() => Boolean)
+  @IsBoolean()
+  isActive?: boolean
+
+  @IsOptional()
+  @IsArray()
+  @ValidateNested({ each: true })
+  @Type(() => AttributeTranslationDto)
+  translations?: AttributeTranslationDto[]
+}
diff --git a/backend/ayanavitabackend/app/api/src/catalog/dto/category.dto.ts b/backend/ayanavitabackend/app/api/src/catalog/dto/category.dto.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9528e35dc75ed4a8dd2f02774e8aac7d8eae79c4
--- /dev/null
+++ b/backend/ayanavitabackend/app/api/src/catalog/dto/category.dto.ts
@@ -0,0 +1,65 @@
+import { Type } from 'class-transformer'
+import {
+  IsArray,
+  IsInt,
+  IsNotEmpty,
+  IsOptional,
+  IsString,
+  MaxLength,
+  ValidateNested,
+} from 'class-validator'
+
+export class CategoryTranslationDto {
+  @IsString()
+  @MaxLength(10)
+  languageCode!: string
+
+  @IsString()
+  @IsNotEmpty()
+  @MaxLength(255)
+  name!: string
+
+  @IsString()
+  @IsNotEmpty()
+  @MaxLength(255)
+  slug!: string
+
+  @IsOptional()
+  @IsString()
+  description?: string
+}
+
+export class CreateCategoryDto {
+  @IsOptional()
+  @Type(() => Number)
+  @IsInt()
+  parentId?: number
+
+  @IsOptional()
+  @IsString()
+  @MaxLength(20)
+  status?: string
+
+  @IsArray()
+  @ValidateNested({ each: true })
+  @Type(() => CategoryTranslationDto)
+  translations!: CategoryTranslationDto[]
+}
+
+export class UpdateCategoryDto {
+  @IsOptional()
+  @Type(() => Number)
+  @IsInt()
+  parentId?: number | null
+
+  @IsOptional()
+  @IsString()
+  @MaxLength(20)
+  status?: string
+
+  @IsOptional()
+  @IsArray()
+  @ValidateNested({ each: true })
+  @Type(() => CategoryTranslationDto)
+  translations?: CategoryTranslationDto[]
+}
diff --git a/backend/ayanavitabackend/app/api/src/catalog/dto/ingredient.dto.ts b/backend/ayanavitabackend/app/api/src/catalog/dto/ingredient.dto.ts
new file mode 100644
index 0000000000000000000000000000000000000000..71f075ff6a70c6dea1c426bcafc2e6e0d90a8382
--- /dev/null
+++ b/backend/ayanavitabackend/app/api/src/catalog/dto/ingredient.dto.ts
@@ -0,0 +1,59 @@
+import { Type } from 'class-transformer'
+import {
+  IsArray,
+  IsBoolean,
+  IsNotEmpty,
+  IsOptional,
+  IsString,
+  MaxLength,
+  ValidateNested,
+} from 'class-validator'
+
+export class IngredientTranslationDto {
+  @IsString()
+  @MaxLength(10)
+  languageCode!: string
+
+  @IsString()
+  @IsNotEmpty()
+  @MaxLength(255)
+  displayName!: string
+
+  @IsOptional()
+  @IsString()
+  description?: string
+}
+
+export class CreateIngredientKeyDto {
+  @IsString()
+  @MaxLength(100)
+  code!: string
+
+  @IsOptional()
+  @Type(() => Boolean)
+  @IsBoolean()
+  isActive?: boolean
+
+  @IsArray()
+  @ValidateNested({ each: true })
+  @Type(() => IngredientTranslationDto)
+  translations!: IngredientTranslationDto[]
+}
+
+export class UpdateIngredientKeyDto {
+  @IsOptional()
+  @IsString()
+  @MaxLength(100)
+  code?: string
+
+  @IsOptional()
+  @Type(() => Boolean)
+  @IsBoolean()
+  isActive?: boolean
+
+  @IsOptional()
+  @IsArray()
+  @ValidateNested({ each: true })
+  @Type(() => IngredientTranslationDto)
+  translations?: IngredientTranslationDto[]
+}
diff --git a/backend/ayanavitabackend/app/api/src/catalog/dto/product-metadata.dto.ts b/backend/ayanavitabackend/app/api/src/catalog/dto/product-metadata.dto.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a0e0c68c30dce34a3f73c638aec275b9e3b35193
--- /dev/null
+++ b/backend/ayanavitabackend/app/api/src/catalog/dto/product-metadata.dto.ts
@@ -0,0 +1,58 @@
+import { Type } from 'class-transformer'
+import { IsArray, IsBoolean, IsInt, IsOptional, IsString, ValidateNested } from 'class-validator'
+
+export class ProductAttributeValueDto {
+  @Type(() => Number)
+  @IsInt()
+  attributeKeyId!: number
+
+  @IsOptional()
+  @IsString()
+  valueText?: string
+
+  @IsOptional()
+  @Type(() => Number)
+  valueNumber?: number
+
+  @IsOptional()
+  @Type(() => Boolean)
+  @IsBoolean()
+  valueBoolean?: boolean
+
+  @IsOptional()
+  @IsString()
+  valueJson?: string
+}
+
+export class ProductIngredientValueDto {
+  @Type(() => Number)
+  @IsInt()
+  ingredientKeyId!: number
+
+  @IsOptional()
+  @IsString()
+  value?: string
+
+  @IsOptional()
+  @IsString()
+  note?: string
+
+  @IsOptional()
+  @Type(() => Number)
+  @IsInt()
+  sortOrder?: number
+}
+
+export class UpsertProductAttributesDto {
+  @IsArray()
+  @ValidateNested({ each: true })
+  @Type(() => ProductAttributeValueDto)
+  items!: ProductAttributeValueDto[]
+}
+
+export class UpsertProductIngredientsDto {
+  @IsArray()
+  @ValidateNested({ each: true })
+  @Type(() => ProductIngredientValueDto)
+  items!: ProductIngredientValueDto[]
+}
diff --git a/backend/ayanavitabackend/app/api/src/catalog/dto/product.dto.ts b/backend/ayanavitabackend/app/api/src/catalog/dto/product.dto.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c08c96e133163aa3ab7c2acaef65ba9d9c0b5fae
--- /dev/null
+++ b/backend/ayanavitabackend/app/api/src/catalog/dto/product.dto.ts
@@ -0,0 +1,89 @@
+import { Type } from 'class-transformer'
+import {
+  IsArray,
+  IsInt,
+  IsNotEmpty,
+  IsNumber,
+  IsOptional,
+  IsString,
+  MaxLength,
+  ValidateNested,
+} from 'class-validator'
+
+export class ProductTranslationDto {
+  @IsString()
+  @MaxLength(10)
+  languageCode!: string
+
+  @IsString()
+  @IsNotEmpty()
+  @MaxLength(255)
+  name!: string
+
+  @IsString()
+  @IsNotEmpty()
+  @MaxLength(255)
+  slug!: string
+
+  @IsOptional()
+  @IsString()
+  @MaxLength(500)
+  shortDescription?: string
+
+  @IsOptional()
+  @IsString()
+  description?: string
+}
+
+export class CreateProductDto {
+  @IsString()
+  @MaxLength(64)
+  sku!: string
+
+  @IsOptional()
+  @Type(() => Number)
+  @IsInt()
+  categoryId?: number
+
+  @Type(() => Number)
+  @IsNumber()
+  price!: number
+
+  @IsOptional()
+  @IsString()
+  @MaxLength(20)
+  status?: string
+
+  @IsArray()
+  @ValidateNested({ each: true })
+  @Type(() => ProductTranslationDto)
+  translations!: ProductTranslationDto[]
+}
+
+export class UpdateProductDto {
+  @IsOptional()
+  @IsString()
+  @MaxLength(64)
+  sku?: string
+
+  @IsOptional()
+  @Type(() => Number)
+  @IsInt()
+  categoryId?: number | null
+
+  @IsOptional()
+  @Type(() => Number)
+  @IsNumber()
+  price?: number
+
+  @IsOptional()
+  @IsString()
+  @MaxLength(20)
+  status?: string
+
+  @IsOptional()
+  @IsArray()
+  @ValidateNested({ each: true })
+  @Type(() => ProductTranslationDto)
+  translations?: ProductTranslationDto[]
+}
diff --git a/backend/ayanavitabackend/app/api/src/catalog/ingredients.controller.ts b/backend/ayanavitabackend/app/api/src/catalog/ingredients.controller.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7be617f1d946091bfab577c7986b6987ed3a6e82
--- /dev/null
+++ b/backend/ayanavitabackend/app/api/src/catalog/ingredients.controller.ts
@@ -0,0 +1,33 @@
+import { Body, Controller, Delete, Get, Param, ParseIntPipe, Patch, Post } from '@nestjs/common'
+import { IngredientsService } from './ingredients.service'
+import { CreateIngredientKeyDto, UpdateIngredientKeyDto } from './dto/ingredient.dto'
+
+@Controller('catalog/ingredients')
+export class IngredientsController {
+  constructor(private readonly service: IngredientsService) {}
+
+  @Get()
+  findAll() {
+    return this.service.findAll()
+  }
+
+  @Get(':id')
+  findOne(@Param('id', ParseIntPipe) id: number) {
+    return this.service.findOne(id)
+  }
+
+  @Post()
+  create(@Body() dto: CreateIngredientKeyDto) {
+    return this.service.create(dto)
+  }
+
+  @Patch(':id')
+  update(@Param('id', ParseIntPipe) id: number, @Body() dto: UpdateIngredientKeyDto) {
+    return this.service.update(id, dto)
+  }
+
+  @Delete(':id')
+  remove(@Param('id', ParseIntPipe) id: number) {
+    return this.service.remove(id)
+  }
+}
diff --git a/backend/ayanavitabackend/app/api/src/catalog/ingredients.service.ts b/backend/ayanavitabackend/app/api/src/catalog/ingredients.service.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dbcc180b2fea2532ccfce479b96f22b7730168c4
--- /dev/null
+++ b/backend/ayanavitabackend/app/api/src/catalog/ingredients.service.ts
@@ -0,0 +1,64 @@
+import { Injectable, NotFoundException } from '@nestjs/common'
+import { PrismaService } from '../prisma/prisma.service'
+import { CreateIngredientKeyDto, UpdateIngredientKeyDto } from './dto/ingredient.dto'
+import { normalizeBigInt } from './utils'
+
+@Injectable()
+export class IngredientsService {
+  constructor(private readonly prisma: PrismaService) {}
+
+  async findAll() {
+    const rows = await this.prisma.ingredientKey.findMany({
+      include: { translations: true },
+      orderBy: { id: 'desc' },
+    })
+    return normalizeBigInt(rows)
+  }
+
+  async findOne(id: number) {
+    const row = await this.prisma.ingredientKey.findUnique({
+      where: { id: BigInt(id) },
+      include: { translations: true },
+    })
+    if (!row) throw new NotFoundException('Ingredient key not found')
+    return normalizeBigInt(row)
+  }
+
+  async create(dto: CreateIngredientKeyDto) {
+    const row = await this.prisma.ingredientKey.create({
+      data: {
+        code: dto.code,
+        isActive: dto.isActive ?? true,
+        translations: { create: dto.translations },
+      },
+      include: { translations: true },
+    })
+    return normalizeBigInt(row)
+  }
+
+  async update(id: number, dto: UpdateIngredientKeyDto) {
+    await this.findOne(id)
+    const row = await this.prisma.$transaction(async (tx) => {
+      if (dto.translations) {
+        await tx.ingredientKeyTranslation.deleteMany({ where: { ingredientKeyId: BigInt(id) } })
+      }
+
+      return tx.ingredientKey.update({
+        where: { id: BigInt(id) },
+        data: {
+          code: dto.code,
+          isActive: dto.isActive,
+          translations: dto.translations ? { create: dto.translations } : undefined,
+        },
+        include: { translations: true },
+      })
+    })
+    return normalizeBigInt(row)
+  }
+
+  async remove(id: number) {
+    await this.findOne(id)
+    const row = await this.prisma.ingredientKey.delete({ where: { id: BigInt(id) } })
+    return normalizeBigInt(row)
+  }
+}
diff --git a/backend/ayanavitabackend/app/api/src/catalog/products.controller.ts b/backend/ayanavitabackend/app/api/src/catalog/products.controller.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9c5084c1907dbba872e487fb207c61bcf34fc791
--- /dev/null
+++ b/backend/ayanavitabackend/app/api/src/catalog/products.controller.ts
@@ -0,0 +1,52 @@
+import { Body, Controller, Delete, Get, Param, ParseIntPipe, Patch, Post } from '@nestjs/common'
+import { ProductsService } from './products.service'
+import { CreateProductDto, UpdateProductDto } from './dto/product.dto'
+import { UpsertProductAttributesDto, UpsertProductIngredientsDto } from './dto/product-metadata.dto'
+
+@Controller('catalog/products')
+export class ProductsController {
+  constructor(private readonly service: ProductsService) {}
+
+  @Get()
+  findAll() {
+    return this.service.findAll()
+  }
+
+  @Get(':id')
+  findOne(@Param('id', ParseIntPipe) id: number) {
+    return this.service.findOne(id)
+  }
+
+  @Post()
+  create(@Body() dto: CreateProductDto) {
+    return this.service.create(dto)
+  }
+
+  @Patch(':id')
+  update(@Param('id', ParseIntPipe) id: number, @Body() dto: UpdateProductDto) {
+    return this.service.update(id, dto)
+  }
+
+
+  @Patch(':id/attributes')
+  replaceAttributes(
+    @Param('id', ParseIntPipe) id: number,
+    @Body() dto: UpsertProductAttributesDto,
+  ) {
+    return this.service.replaceAttributes(id, dto)
+  }
+
+  @Patch(':id/ingredients')
+  replaceIngredients(
+    @Param('id', ParseIntPipe) id: number,
+    @Body() dto: UpsertProductIngredientsDto,
+  ) {
+    return this.service.replaceIngredients(id, dto)
+  }
+
+
+  @Delete(':id')
+  remove(@Param('id', ParseIntPipe) id: number) {
+    return this.service.remove(id)
+  }
+}
diff --git a/backend/ayanavitabackend/app/api/src/catalog/products.service.ts b/backend/ayanavitabackend/app/api/src/catalog/products.service.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2f99c029b1578dcdb243d5e1582c72d10bc270aa
--- /dev/null
+++ b/backend/ayanavitabackend/app/api/src/catalog/products.service.ts
@@ -0,0 +1,110 @@
+import { Injectable, NotFoundException } from '@nestjs/common'
+import { PrismaService } from '../prisma/prisma.service'
+import { CreateProductDto, UpdateProductDto } from './dto/product.dto'
+import { UpsertProductAttributesDto, UpsertProductIngredientsDto } from './dto/product-metadata.dto'
+import { normalizeBigInt } from './utils'
+
+@Injectable()
+export class ProductsService {
+  constructor(private readonly prisma: PrismaService) {}
+
+  async findAll() {
+    const rows = await this.prisma.catalogProduct.findMany({
+      include: { translations: true, category: true },
+      orderBy: { id: 'desc' },
+    })
+    return normalizeBigInt(rows)
+  }
+
+  async findOne(id: number) {
+    const row = await this.prisma.catalogProduct.findUnique({
+      where: { id: BigInt(id) },
+      include: { translations: true, category: true, attributes: true, ingredients: true },
+    })
+    if (!row) throw new NotFoundException('Product not found')
+    return normalizeBigInt(row)
+  }
+
+  async create(dto: CreateProductDto) {
+    const row = await this.prisma.catalogProduct.create({
+      data: {
+        sku: dto.sku,
+        categoryId: dto.categoryId ? BigInt(dto.categoryId) : null,
+        price: dto.price,
+        status: dto.status ?? 'active',
+        translations: { create: dto.translations },
+      },
+      include: { translations: true, category: true },
+    })
+    return normalizeBigInt(row)
+  }
+
+  async update(id: number, dto: UpdateProductDto) {
+    await this.findOne(id)
+    const row = await this.prisma.$transaction(async (tx) => {
+      if (dto.translations) {
+        await tx.productTranslation.deleteMany({ where: { productId: BigInt(id) } })
+      }
+
+      return tx.catalogProduct.update({
+        where: { id: BigInt(id) },
+        data: {
+          sku: dto.sku,
+          categoryId: dto.categoryId === undefined ? undefined : dto.categoryId === null ? null : BigInt(dto.categoryId),
+          price: dto.price,
+          status: dto.status,
+          translations: dto.translations ? { create: dto.translations } : undefined,
+        },
+        include: { translations: true, category: true },
+      })
+    })
+    return normalizeBigInt(row)
+  }
+
+  async replaceAttributes(id: number, dto: UpsertProductAttributesDto) {
+    await this.findOne(id)
+    const rows = await this.prisma.$transaction(async (tx) => {
+      await tx.productAttribute.deleteMany({ where: { productId: BigInt(id) } })
+      if (dto.items.length) {
+        await tx.productAttribute.createMany({
+          data: dto.items.map((item) => ({
+            productId: BigInt(id),
+            attributeKeyId: BigInt(item.attributeKeyId),
+            valueText: item.valueText,
+            valueNumber: item.valueNumber,
+            valueBoolean: item.valueBoolean,
+            valueJson: item.valueJson,
+          })),
+        })
+      }
+      return tx.productAttribute.findMany({ where: { productId: BigInt(id) } })
+    })
+    return normalizeBigInt(rows)
+  }
+
+  async replaceIngredients(id: number, dto: UpsertProductIngredientsDto) {
+    await this.findOne(id)
+    const rows = await this.prisma.$transaction(async (tx) => {
+      await tx.productIngredient.deleteMany({ where: { productId: BigInt(id) } })
+      if (dto.items.length) {
+        await tx.productIngredient.createMany({
+          data: dto.items.map((item) => ({
+            productId: BigInt(id),
+            ingredientKeyId: BigInt(item.ingredientKeyId),
+            value: item.value,
+            note: item.note,
+            sortOrder: item.sortOrder ?? 0,
+          })),
+        })
+      }
+      return tx.productIngredient.findMany({ where: { productId: BigInt(id) }, orderBy: { sortOrder: 'asc' } })
+    })
+    return normalizeBigInt(rows)
+  }
+
+  async remove(id: number) {
+    await this.findOne(id)
+    const row = await this.prisma.catalogProduct.delete({ where: { id: BigInt(id) } })
+    return normalizeBigInt(row)
+  }
+}
diff --git a/backend/ayanavitabackend/app/api/src/catalog/utils.ts b/backend/ayanavitabackend/app/api/src/catalog/utils.ts
new file mode 100644
index 0000000000000000000000000000000000000000..1eb646e3dd34633859c5f95aff3f270fd9eda9a9
--- /dev/null
+++ b/backend/ayanavitabackend/app/api/src/catalog/utils.ts
@@ -0,0 +1,7 @@
+export function normalizeBigInt<T>(value: T): T {
+  return JSON.parse(
+    JSON.stringify(value, (_, currentValue) =>
+      typeof currentValue === 'bigint' ? currentValue.toString() : currentValue,
+    ),
+  ) as T
+}
