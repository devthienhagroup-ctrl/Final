diff --git a/backend/ayanavitabackend/app/api/prisma/migrations/202603300001_add_rbac_core/migration.sql b/backend/ayanavitabackend/app/api/prisma/migrations/202603300001_add_rbac_core/migration.sql
new file mode 100644
index 0000000000000000000000000000000000000000..e4ff9a54bca3ce0fb6f61d26219d95c78b001532
--- /dev/null
+++ b/backend/ayanavitabackend/app/api/prisma/migrations/202603300001_add_rbac_core/migration.sql
@@ -0,0 +1,44 @@
+-- RBAC core tables + User.roleId relation
+
+CREATE TABLE `Role` (
+  `id` INT NOT NULL AUTO_INCREMENT,
+  `code` VARCHAR(50) NOT NULL,
+  `scopeType` ENUM('OWN', 'BRANCH', 'COURSE', 'GLOBAL') NOT NULL,
+  `description` VARCHAR(255) NULL,
+  `createdAt` DATETIME(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),
+  `updatedAt` DATETIME(3) NOT NULL,
+  UNIQUE INDEX `Role_code_key`(`code`),
+  PRIMARY KEY (`id`)
+) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
+
+CREATE TABLE `Permission` (
+  `id` INT NOT NULL AUTO_INCREMENT,
+  `code` VARCHAR(120) NOT NULL,
+  `resource` VARCHAR(80) NOT NULL,
+  `action` VARCHAR(80) NOT NULL,
+  `createdAt` DATETIME(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),
+  `updatedAt` DATETIME(3) NOT NULL,
+  UNIQUE INDEX `Permission_code_key`(`code`),
+  PRIMARY KEY (`id`)
+) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
+
+CREATE TABLE `RolePermission` (
+  `roleId` INT NOT NULL,
+  `permissionId` INT NOT NULL,
+  INDEX `RolePermission_permissionId_idx`(`permissionId`),
+  PRIMARY KEY (`roleId`, `permissionId`)
+) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
+
+ALTER TABLE `User`
+  ADD COLUMN `roleId` INT NULL,
+  ADD INDEX `User_roleId_idx`(`roleId`);
+
+ALTER TABLE `RolePermission`
+  ADD CONSTRAINT `RolePermission_roleId_fkey`
+  FOREIGN KEY (`roleId`) REFERENCES `Role`(`id`) ON DELETE CASCADE ON UPDATE CASCADE,
+  ADD CONSTRAINT `RolePermission_permissionId_fkey`
+  FOREIGN KEY (`permissionId`) REFERENCES `Permission`(`id`) ON DELETE CASCADE ON UPDATE CASCADE;
+
+ALTER TABLE `User`
+  ADD CONSTRAINT `User_roleId_fkey`
+  FOREIGN KEY (`roleId`) REFERENCES `Role`(`id`) ON DELETE SET NULL ON UPDATE CASCADE;
diff --git a/backend/ayanavitabackend/app/api/prisma/schema.prisma b/backend/ayanavitabackend/app/api/prisma/schema.prisma
index 160f49961c0e81e4131ca7790e28350e7686672f..b134e67fa3e4abab40aed87cd9d7912fd2790341 100644
--- a/backend/ayanavitabackend/app/api/prisma/schema.prisma
+++ b/backend/ayanavitabackend/app/api/prisma/schema.prisma
@@ -1,69 +1,73 @@
 generator client {
   provider = "prisma-client-js"
 }

 datasource db {
   provider          = "mysql"
   url               = env("DATABASE_URL")
   shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
 }

 model User {
   id                 Int      @id @default(autoincrement())
   email              String   @unique
   password           String
   name               String?
   phone              String?
   birthDate          DateTime?
   gender             Gender?
   address            String?  @db.VarChar(500)
-  role               Role     @default(USER)
+  role               UserRole @default(USER)
+  roleId             Int?
+  roleRef            RbacRole? @relation("UserRbacRole", fields: [roleId], references: [id], onDelete: SetNull)
   isActive           Boolean  @default(true)
   hashedRefreshToken String?  @db.Text
   createdAt          DateTime @default(now())
   updatedAt          DateTime @updatedAt

   // ‚úÖ ADD
   enrollments    Enrollment[]
   courseAccesses CourseAccess[]
   lessonProgress LessonProgress[]
   lessonVideoProgress LessonVideoProgress[]
   orders         Order[] // <‚Äî opposite for Order.user
   productOrders  ProductOrder[]
   carts          Cart[]

   courseReviews CourseReview[]
   // ‚úÖ CMS (optional relations)
   cmsSectionVersions CmsSectionVersion[]
   mediaAssets        MediaAsset[]
   serviceReviews     ServiceReview[]
   reviews            Review[]
   specialistProfile  Specialist?
   reviewHelpfulVotes ReviewHelpful[]
   blogPosts          BlogPost[]
   blogSaves          BlogSavedPost[]
+
+  @@index([roleId])
 }

 model Branch {
   id          Int                @id @default(autoincrement())
   code        String             @unique @db.VarChar(32)
   name        String             @db.VarChar(255)
   address     String             @db.VarChar(255)
   phone       String?            @db.VarChar(30)
   isActive    Boolean            @default(true)
   createdAt   DateTime           @default(now())
   updatedAt   DateTime           @updatedAt
   services    BranchService[]
   specialists Specialist[]
   appointments Appointment[]
   translations BranchTranslation[]
   reviews      Review[]
 }

 model ServiceCategory {
   id        Int      @id @default(autoincrement())
   name      String   @unique @db.VarChar(255)
   createdAt DateTime @default(now())
   updatedAt DateTime @updatedAt
   services  Service[]
   translations ServiceCategoryTranslation[]
@@ -625,51 +629,92 @@ enum ProgressStatus {
 enum LessonMediaType {
   VIDEO
   IMAGE
 }

 enum SpecialistLevel {
   JUNIOR
   SENIOR
   EXPERT
   THERAPIST
 }

 enum AppointmentStatus {
   PENDING
   CONFIRMED
   DONE
   CANCELED
 }

 enum Gender {
   MALE
   FEMALE
   OTHER
 }

-enum Role {
+
+enum ScopeType {
+  OWN
+  BRANCH
+  COURSE
+  GLOBAL
+}
+
+model RbacRole {
+  id          Int              @id @default(autoincrement())
+  code        String           @unique @db.VarChar(50)
+  scopeType   ScopeType
+  description String?          @db.VarChar(255)
+  users       User[]           @relation("UserRbacRole")
+  permissions RolePermission[]
+  createdAt   DateTime         @default(now())
+  updatedAt   DateTime         @updatedAt
+
+  @@map("Role")
+}
+
+model Permission {
+  id          Int              @id @default(autoincrement())
+  code        String           @unique @db.VarChar(120)
+  resource    String           @db.VarChar(80)
+  action      String           @db.VarChar(80)
+  roles       RolePermission[]
+  createdAt   DateTime         @default(now())
+  updatedAt   DateTime         @updatedAt
+}
+
+model RolePermission {
+  roleId       Int
+  permissionId Int
+  role         RbacRole   @relation(fields: [roleId], references: [id], onDelete: Cascade)
+  permission   Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)
+
+  @@id([roleId, permissionId])
+  @@index([permissionId])
+}
+
+enum UserRole {
   ADMIN
   MANAGER
   STAFF
   USER
 }


 enum EnrollmentStatus {
   ACTIVE
   CANCELED
 }

 enum CourseAccessStatus {
   ACTIVE
   CANCELED
 }

 enum OrderStatus {
   PENDING
   PAID
   CANCELED
   EXPIRED
 }

 model Order {
diff --git a/backend/ayanavitabackend/app/api/prisma/seed.ts b/backend/ayanavitabackend/app/api/prisma/seed.ts
index 24c45ac83c2cf975954b94d0904e0534b03a441a..38da0dec5accb82db815e65287bd929b4091419a 100644
--- a/backend/ayanavitabackend/app/api/prisma/seed.ts
+++ b/backend/ayanavitabackend/app/api/prisma/seed.ts
@@ -145,53 +145,172 @@ async function seedCatalog() {
   await prisma.productAttribute.upsert({
     where: { productId_attributeKeyId: { productId: product.id, attributeKeyId: materialKey.id } },
     update: { valueText: 'Glass bottle' },
     create: { productId: product.id, attributeKeyId: materialKey.id, valueText: 'Glass bottle' },
   })

   await prisma.productAttribute.upsert({
     where: { productId_attributeKeyId: { productId: product.id, attributeKeyId: volumeKey.id } },
     update: { valueNumber: 30 },
     create: { productId: product.id, attributeKeyId: volumeKey.id, valueNumber: 30 },
   })

   await prisma.productIngredient.upsert({
     where: { productId_ingredientKeyId: { productId: product.id, ingredientKeyId: vitaminCKey.id } },
     update: { value: '10mg', sortOrder: 1 },
     create: { productId: product.id, ingredientKeyId: vitaminCKey.id, value: '10mg', sortOrder: 1 },
   })

   await prisma.productIngredient.upsert({
     where: { productId_ingredientKeyId: { productId: product.id, ingredientKeyId: aloeKey.id } },
     update: { value: '5%', sortOrder: 2 },
     create: { productId: product.id, ingredientKeyId: aloeKey.id, value: '5%', sortOrder: 2 },
   })
 }

+
+
+type RoleSeed = {
+  code: string
+  scopeType: 'OWN' | 'BRANCH' | 'COURSE' | 'GLOBAL'
+  description: string
+  permissions: string[]
+}
+
+const ROLE_SEEDS: RoleSeed[] = [
+  {
+    code: 'USER',
+    scopeType: 'OWN',
+    description: 'Kh√°ch h√†ng / h·ªçc vi√™n',
+    permissions: [
+      'booking.read','booking.write','cart.manage','orders.read','payments.read','courses.read','my_courses.read','enroll.read','enroll.write','support.read','support.write',
+    ],
+  },
+  {
+    code: 'STAFF',
+    scopeType: 'BRANCH',
+    description: 'Nh√¢n s·ª± chi nh√°nh',
+    permissions: ['spa_services.read','spa_services.write','appointments.read','appointments.write','appointments.approve','booking.read','booking.approve','products.read','orders.read','support.read','support.write'],
+  },
+  {
+    code: 'BRANCH_MANAGER',
+    scopeType: 'BRANCH',
+    description: 'Qu·∫£n l√Ω chi nh√°nh',
+    permissions: ['spa_services.manage','spa_services.write','spa_services.read','appointments.manage','appointments.write','appointments.read','appointments.approve','booking.manage','booking.approve','booking.read','products.write','products.read','orders.read','orders.export','packages.manage','packages.write','packages.read','support.manage','support.read','support.write','role.read'],
+  },
+  {
+    code: 'LECTURER',
+    scopeType: 'COURSE',
+    description: 'Gi·∫£ng vi√™n',
+    permissions: ['courses.read','courses.write','courses.publish','my_courses.read','enroll.read','support.read','support.write','cms.read'],
+  },
+  {
+    code: 'SUPPORT',
+    scopeType: 'GLOBAL',
+    description: 'CSKH to√†n h·ªá th·ªëng (h·∫°n ch·∫ø)',
+    permissions: ['support.read','support.write','support.manage','orders.read','booking.read','appointments.read','courses.read','my_courses.read'],
+  },
+  {
+    code: 'OPS',
+    scopeType: 'GLOBAL',
+    description: 'V·∫≠n h√†nh to√†n h·ªá th·ªëng',
+    permissions: ['orders.read','orders.manage','orders.export','booking.read','booking.approve','booking.manage','appointments.read','appointments.manage','packages.read','packages.write','packages.manage','products.read','products.write','cms.read','cms.write','role.read'],
+  },
+  {
+    code: 'FINANCE',
+    scopeType: 'GLOBAL',
+    description: 'T√†i ch√≠nh',
+    permissions: ['payments.read','payments.manage','payments.export','payments.approve','payments.refund','orders.read','orders.export','orders.refund','packages.read','role.read'],
+  },
+  {
+    code: 'ADMIN',
+    scopeType: 'GLOBAL',
+    description: 'Qu·∫£n tr·ªã h·ªá th·ªëng',
+    permissions: ['role.read','role.manage'],
+  },
+]
+
+function toPermissionMeta(code: string) {
+  const [resource, action] = code.split('.')
+  return { code, resource: resource ?? 'unknown', action: action ?? 'manage' }
+}
+
+async function seedRbac() {
+  const permissionCodes = Array.from(new Set(ROLE_SEEDS.flatMap((r) => r.permissions)))
+
+  for (const code of permissionCodes) {
+    const meta = toPermissionMeta(code)
+    await prisma.permission.upsert({
+      where: { code: meta.code },
+      update: { resource: meta.resource, action: meta.action },
+      create: meta,
+    })
+  }
+
+  const permissionRows = await prisma.permission.findMany({ where: { code: { in: permissionCodes } } })
+  const permissionByCode = new Map(permissionRows.map((p) => [p.code, p.id]))
+
+  for (const roleSeed of ROLE_SEEDS) {
+    const role = await prisma.rbacRole.upsert({
+      where: { code: roleSeed.code },
+      update: { scopeType: roleSeed.scopeType, description: roleSeed.description },
+      create: { code: roleSeed.code, scopeType: roleSeed.scopeType, description: roleSeed.description },
+    })
+
+    const permissionIds = roleSeed.permissions.map((code) => permissionByCode.get(code)).filter((id): id is number => Boolean(id))
+
+    await prisma.rolePermission.deleteMany({ where: { roleId: role.id } })
+    if (permissionIds.length > 0) {
+      await prisma.rolePermission.createMany({
+        data: permissionIds.map((permissionId) => ({ roleId: role.id, permissionId })),
+        skipDuplicates: true,
+      })
+    }
+  }
+
+  const roleRows = await prisma.rbacRole.findMany({ select: { id: true, code: true } })
+  const roleByCode = new Map(roleRows.map((r) => [r.code, r.id]))
+
+  const adminRoleId = roleByCode.get('ADMIN')
+  const userRoleId = roleByCode.get('USER')
+  const staffRoleId = roleByCode.get('STAFF')
+
+  if (adminRoleId) {
+    await prisma.user.updateMany({ where: { role: 'ADMIN' }, data: { roleId: adminRoleId } })
+  }
+  if (staffRoleId) {
+    await prisma.user.updateMany({ where: { role: 'STAFF', roleId: null }, data: { roleId: staffRoleId } })
+  }
+  if (userRoleId) {
+    await prisma.user.updateMany({ where: { role: 'USER', roleId: null }, data: { roleId: userRoleId } })
+  }
+}
 async function main() {
   const passwordHash = await bcrypt.hash('123456', 10)

+  await seedRbac()
+
   const user = await prisma.user.upsert({
     where: { email: 'test@ayanavita.com' },
     update: {},
     create: {
       email: 'test@ayanavita.com',
       password: passwordHash,
       name: 'Test User',
       role: 'USER',
     },
   })
   const branchSeeds = [
     { code: 'HCM_Q1', name: 'AYANAVITA ‚Ä¢ Qu·∫≠n 1 (HCM)', address: '12 Nguy·ªÖn Hu·ªá, Qu·∫≠n 1, TP.HCM', phone: '0900000001' },
     { code: 'HN_CG', name: 'AYANAVITA ‚Ä¢ C·∫ßu Gi·∫•y (HN)', address: '88 Tr·∫ßn Th√°i T√¥ng, C·∫ßu Gi·∫•y, H√† N·ªôi', phone: '0900000002' },
     { code: 'DN_HC', name: 'AYANAVITA ‚Ä¢ H·∫£i Ch√¢u (ƒêN)', address: '25 B·∫°ch ƒê·∫±ng, H·∫£i Ch√¢u, ƒê√† N·∫µng', phone: '0900000003' },
   ]

   const serviceSeeds = [
     {
       name: 'ChƒÉm s√≥c da chuy√™n s√¢u üëè',
       categoryName: 'ChƒÉm s√≥c da',
       goals: ['restore', 'bright'],
       suitableFor: ['Da x·ªân m√†u', 'Da thi·∫øu ·∫©m'],
       durationMin: 75,
       price: 590000,
       ratingAvg: 4.9,
diff --git a/backend/ayanavitabackend/app/api/src/app.module.ts b/backend/ayanavitabackend/app/api/src/app.module.ts
index e275bfd0baeaca3687752bc761e72598e1323a16..225ca453c68aad71fa3fd98650fba99806569bbb 100644
--- a/backend/ayanavitabackend/app/api/src/app.module.ts
+++ b/backend/ayanavitabackend/app/api/src/app.module.ts
@@ -1,48 +1,50 @@
 import { Module } from '@nestjs/common';

 import { PrismaModule } from './prisma/prisma.module';

 import { AuthModule } from './auth/auth.module';
 import { UsersModule } from './users/users.module';

 import { CoursesModule } from './courses/courses.module';
 import { CourseTopicsModule } from './course-topics/course-topics.module';
 import { LessonsModule } from './lessons/lessons.module';
 import { EnrollmentsModule } from './enrollments/enrollments.module';
 import { ProgressModule } from './progress/progress.module';

 import { OrdersModule } from './orders/orders.module';
 import { BookingModule } from './booking/booking.module';

 import { CmsModule } from './cms/cms.module';
 import { CatalogModule } from './catalog/catalog.module';
 import { CartModule } from './cart/cart.module';
 import { ProductOrdersModule } from './product-orders/product-orders.module';
 import { ReviewsModule } from './reviews/reviews.module';
 import { BlogModule } from './blog/blog.module';
+import { RbacModule } from './rbac/rbac.module';

 @Module({
   imports: [
     PrismaModule,

     UsersModule,
     AuthModule,

     CoursesModule,
     CourseTopicsModule,
     LessonsModule,
     EnrollmentsModule,
     ProgressModule,

     OrdersModule,
     BookingModule,

     CmsModule,
     CatalogModule,
     CartModule,
     ProductOrdersModule,
     ReviewsModule,
     BlogModule,
+    RbacModule,
   ],
 })
 export class AppModule {}
\ No newline at end of file
diff --git a/backend/ayanavitabackend/app/api/src/auth/auth.service.ts b/backend/ayanavitabackend/app/api/src/auth/auth.service.ts
index bcab8cddb85f7110b08a352257901589bca3504b..9d9e84ef72f321a6d0dfd0ef5e7215d7aa3183c8 100644
--- a/backend/ayanavitabackend/app/api/src/auth/auth.service.ts
+++ b/backend/ayanavitabackend/app/api/src/auth/auth.service.ts
@@ -1,120 +1,128 @@
 import { ForbiddenException, Injectable, Logger, UnauthorizedException } from '@nestjs/common'
 import { JwtPayload, verify } from 'jsonwebtoken'
 import { JwtService } from '@nestjs/jwt'
 import * as bcrypt from 'bcrypt'
 import * as tls from 'tls'
 import { PrismaService } from '../prisma/prisma.service'
 import { RegisterDto } from '../users/dto/register.dto'
 import { LoginDto } from '../users/dto/login.dto'
 import { SendOtpDto } from './dto/send-otp.dto'
 import { RegisterNewDto } from './dto/register-new.dto'
 import { UpdateProfileDto } from './dto/update-profile.dto'
 import { ChangePasswordDto } from './dto/change-password.dto'
 import { ForgotPasswordDto } from './dto/forgot-password.dto'
 import { CheckPasswordDto } from './dto/check-password.dto'
 import { VerifyOtpDto } from './dto/verify-otp.dto'

-type AuthJwtPayload = { sub: number; email: string; role: string }
+type AuthJwtPayload = { sub: number; email: string; role: string; scopeType?: string | null; permissions: string[] }

 @Injectable()
 export class AuthService {
   private readonly logger = new Logger(AuthService.name)

   constructor(
     private readonly prisma: PrismaService,
     private readonly jwt: JwtService,
   ) {}

   async register(dto: RegisterDto) {
     const exists = await this.prisma.user.findUnique({ where: { email: dto.email } })
     if (exists) throw new ForbiddenException('Email ƒë√£ t·ªìn t·∫°i, vui l√≤ng d√πng email kh√°c/ ho·∫∑c ƒëƒÉng nh·∫≠p !')

     const passwordHash = await bcrypt.hash(dto.password, 10)

     const user = await this.prisma.user.create({
       data: {
         email: dto.email,
         password: passwordHash,
         name: dto.name,
         role: 'USER',
       },
       select: { id: true, email: true, name: true, role: true, birthDate: true, gender: true, address: true },
     })

-    const tokens = await this.issueTokens(user.id, user.email, user.role)
+    const role = user.roleRef?.code ?? user.role
+    const scopeType = user.roleRef?.scopeType ?? null
+    const permissions = user.roleRef?.permissions.map((rp) => rp.permission.code) ?? []
+
+    const tokens = await this.issueTokens(user.id, user.email, role, scopeType, permissions)
     await this.setRefreshTokenHash(user.id, tokens.refreshToken)

     return { user, ...tokens }
   }

   async sendOtp(dto: SendOtpDto) {
     const email = dto.email.trim().toLowerCase()
     const exists = await this.prisma.user.findUnique({ where: { email } })
     if (exists) throw new ForbiddenException('Email ƒë√£ t·ªìn t·∫°i, vui l√≤ng d√πng email kh√°c/ ho·∫∑c ƒëƒÉng nh·∫≠p !')

     await this.issueOtp(email, 'x√°c nh·∫≠n ƒëƒÉng k√Ω AYANAVITA')
     return { success: true, expiresInSeconds: 300 }
   }

   async registerNew(dto: RegisterNewDto) {
     if (!dto.acceptedPolicy) throw new ForbiddenException('B·∫°n ph·∫£i ch·∫•p nh·∫≠n ch√≠nh s√°ch')

     const email = dto.email.trim().toLowerCase()
     const exists = await this.prisma.user.findUnique({ where: { email } })
     if (exists) throw new ForbiddenException('Email ƒë√£ t·ªìn t·∫°i, vui l√≤ng d√πng email kh√°c/ ho·∫∑c ƒëƒÉng nh·∫≠p !')

     const otpRow = await this.prisma.registrationOtp.findUnique({ where: { email } })
     if (!otpRow || otpRow.usedAt || otpRow.code !== dto.otp) {
       throw new ForbiddenException('OTP kh√¥ng h·ª£p l·ªá')
     }
     if (otpRow.expiresAt.getTime() < Date.now()) {
       throw new ForbiddenException('OTP ƒë√£ h·∫øt h·∫°n')
     }

     const passwordHash = await bcrypt.hash(dto.password, 10)

     const user = await this.prisma.user.create({
       data: {
         email,
         password: passwordHash,
         name: dto.name,
         phone: dto.phone,
         role: 'USER',
         birthDate: dto.birthDate ? new Date(dto.birthDate) : undefined,
         gender: dto.gender,
         address: dto.address,
       },
       select: { id: true, email: true, name: true, role: true, phone: true, birthDate: true, gender: true, address: true },
     })

     await this.prisma.registrationOtp.update({
       where: { email },
       data: { usedAt: new Date() },
     })

-    const tokens = await this.issueTokens(user.id, user.email, user.role)
+    const role = user.roleRef?.code ?? user.role
+    const scopeType = user.roleRef?.scopeType ?? null
+    const permissions = user.roleRef?.permissions.map((rp) => rp.permission.code) ?? []
+
+    const tokens = await this.issueTokens(user.id, user.email, role, scopeType, permissions)
     await this.setRefreshTokenHash(user.id, tokens.refreshToken)

     return { user, ...tokens }
   }

   async getProfile(userId: number) {
     const user = await this.prisma.user.findUnique({
       where: { id: userId },
       select: {
         id: true,
         email: true,
         name: true,
         phone: true,
         role: true,
         birthDate: true,
         gender: true,
         address: true,
         createdAt: true,
         updatedAt: true,
       },
     })

     if (!user) throw new UnauthorizedException('User not found')
     return {
       ...user,
@@ -244,82 +252,98 @@ export class AuthService {
     }

     const otpRow = await this.prisma.registrationOtp.findUnique({ where: { email } })
     if (!otpRow || otpRow.usedAt || otpRow.code !== dto.otp) {
       throw new ForbiddenException('OTP kh√¥ng h·ª£p l·ªá')
     }
     if (otpRow.expiresAt.getTime() < Date.now()) {
       throw new ForbiddenException('OTP ƒë√£ h·∫øt h·∫°n')
     }

     const newPasswordHash = await bcrypt.hash(dto.newPassword, 10)
     await this.prisma.user.update({
       where: { id: user.id },
       data: { password: newPasswordHash },
     })

     await this.prisma.registrationOtp.update({
       where: { email },
       data: { usedAt: new Date() },
     })

     return { success: true, message: 'ƒê·∫∑t l·∫°i m·∫≠t kh·∫©u th√†nh c√¥ng.' }
   }

   async login(dto: LoginDto) {
-    const user = await this.prisma.user.findUnique({ where: { email: dto.email } })
+    const user = await this.prisma.user.findUnique({
+      where: { email: dto.email },
+      include: { roleRef: { include: { permissions: { include: { permission: true } } } } },
+    })
     if (!user) throw new UnauthorizedException('Invalid credentials')

     const ok = await bcrypt.compare(dto.password, user.password)
     if (!ok) throw new UnauthorizedException('Invalid credentials')

-    const tokens = await this.issueTokens(user.id, user.email, user.role)
+    const role = user.roleRef?.code ?? user.role
+    const scopeType = user.roleRef?.scopeType ?? null
+    const permissions = user.roleRef?.permissions.map((rp) => rp.permission.code) ?? []
+
+    const tokens = await this.issueTokens(user.id, user.email, role, scopeType, permissions)
     await this.setRefreshTokenHash(user.id, tokens.refreshToken)

     return {
       user: {
         id: user.id,
         email: user.email,
         name: user.name,
-        role: user.role,
+        role,
+        scopeType,
+        permissions,
         phone: user.phone,
         birthDate: user.birthDate,
         gender: user.gender,
         address: user.address,
       },
       ...tokens,
     }
   }

   async refreshTokens(userId: number, refreshToken: string) {
-    const user = await this.prisma.user.findUnique({ where: { id: userId } })
+    const user = await this.prisma.user.findUnique({
+      where: { id: userId },
+      include: { roleRef: { include: { permissions: { include: { permission: true } } } } },
+    })
     if (!user || !user.hashedRefreshToken) throw new ForbiddenException('Access denied')

     const ok = await bcrypt.compare(refreshToken, user.hashedRefreshToken)
     if (!ok) throw new ForbiddenException('Access denied')

-    const tokens = await this.issueTokens(user.id, user.email, user.role)
+    const role = user.roleRef?.code ?? user.role
+    const scopeType = user.roleRef?.scopeType ?? null
+    const permissions = user.roleRef?.permissions.map((rp) => rp.permission.code) ?? []
+
+    const tokens = await this.issueTokens(user.id, user.email, role, scopeType, permissions)
     await this.setRefreshTokenHash(user.id, tokens.refreshToken)

     return tokens
   }

   async logout(userId: number) {
     await this.prisma.user.update({
       where: { id: userId },
       data: { hashedRefreshToken: null },
     })
     return { success: true }
   }

   private async issueOtp(email: string, purpose: string) {
     const otp = String(Math.floor(100000 + Math.random() * 900000))
     const expiresAt = new Date(Date.now() + 5 * 60 * 1000)

     await this.prisma.registrationOtp.upsert({
       where: { email },
       update: { code: otp, expiresAt, usedAt: null },
       create: { email, code: otp, expiresAt },
     })

     void this.sendOtpMail(email, otp, purpose).catch((error) => {
       this.logger.error(`Kh√¥ng g·ª≠i ƒë∆∞·ª£c email OTP t·ªõi ${email}`, error?.stack ?? String(error))
@@ -457,49 +481,49 @@ export class AuthService {
         `--${boundary}`,
         'Content-Type: text/plain; charset=UTF-8',
         '',
         body,
         '',
         `--${boundary}`,
         'Content-Type: text/html; charset=UTF-8',
         '',
         html ?? body,
         '',
         `--${boundary}--`,
         '.',
       ].join('\r\n')
       socket.write(`${message}\r\n`)
       const dataResponse = await readSmtpResponse(socket)
       if (!dataResponse.startsWith('250')) {
         throw new Error(`SMTP send failed: ${dataResponse}`)
       }

       await sendCommand(socket, 'QUIT', [221])
     } finally {
       socket.end()
     }
   }

-  private issueTokens(userId: number, email: string, role: string) {
-    const payload: AuthJwtPayload = { sub: userId, email, role }
+  private issueTokens(userId: number, email: string, role: string, scopeType: string | null, permissions: string[]) {
+    const payload: AuthJwtPayload = { sub: userId, email, role, scopeType, permissions }

     const accessToken = this.jwt.sign(payload, {
       secret: process.env.JWT_ACCESS_SECRET,
       expiresIn: 15 * 60,
     })

     const refreshToken = this.jwt.sign(payload, {
       secret: process.env.JWT_REFRESH_SECRET,
       expiresIn: 7 * 24 * 60 * 60,
     })

     return { accessToken, refreshToken }
   }

   private async setRefreshTokenHash(userId: number, refreshToken: string) {
     const hash = await bcrypt.hash(refreshToken, 10)
     await this.prisma.user.update({
       where: { id: userId },
       data: { hashedRefreshToken: hash },
     })
   }
 }
diff --git a/backend/ayanavitabackend/app/api/src/auth/decorators/current-user.decorator.ts b/backend/ayanavitabackend/app/api/src/auth/decorators/current-user.decorator.ts
index bd2f4d82f9f70b39022155be32677099c979a179..ce12acf84ae9db1fb6ee4c54ac134230ba314e6c 100644
--- a/backend/ayanavitabackend/app/api/src/auth/decorators/current-user.decorator.ts
+++ b/backend/ayanavitabackend/app/api/src/auth/decorators/current-user.decorator.ts
@@ -1,10 +1,10 @@
 import { createParamDecorator, ExecutionContext } from '@nestjs/common'

-export type JwtUser = { sub: number; email?: string; role: string; iat?: number; exp?: number }
+export type JwtUser = { sub: number; email?: string; role: string; scopeType?: string | null; permissions?: string[]; iat?: number; exp?: number }

 export const CurrentUser = createParamDecorator(
   (_data: unknown, ctx: ExecutionContext) => {
     const req = ctx.switchToHttp().getRequest()
     return req.user as JwtUser
   },
 )
diff --git a/backend/ayanavitabackend/app/api/src/auth/decorators/permissions.decorator.ts b/backend/ayanavitabackend/app/api/src/auth/decorators/permissions.decorator.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2165a81e53994db8efc7c286942fbb9ec7d5a0bb
--- /dev/null
+++ b/backend/ayanavitabackend/app/api/src/auth/decorators/permissions.decorator.ts
@@ -0,0 +1,4 @@
+import { SetMetadata } from '@nestjs/common'
+
+export const PERMISSIONS_KEY = 'permissions'
+export const Permissions = (...permissions: string[]) => SetMetadata(PERMISSIONS_KEY, permissions)
diff --git a/backend/ayanavitabackend/app/api/src/auth/guards/permission.guard.ts b/backend/ayanavitabackend/app/api/src/auth/guards/permission.guard.ts
new file mode 100644
index 0000000000000000000000000000000000000000..50050a020264c10dd95d558190abc187b1919e3a
--- /dev/null
+++ b/backend/ayanavitabackend/app/api/src/auth/guards/permission.guard.ts
@@ -0,0 +1,27 @@
+import { CanActivate, ExecutionContext, Injectable } from '@nestjs/common'
+import { Reflector } from '@nestjs/core'
+import { PERMISSIONS_KEY } from '../decorators/permissions.decorator'
+
+type RequestUser = {
+  permissions?: string[]
+}
+
+@Injectable()
+export class PermissionGuard implements CanActivate {
+  constructor(private readonly reflector: Reflector) {}
+
+  canActivate(context: ExecutionContext): boolean {
+    const required = this.reflector.getAllAndOverride<string[]>(PERMISSIONS_KEY, [
+      context.getHandler(),
+      context.getClass(),
+    ])
+
+    if (!required || required.length === 0) return true
+
+    const req = context.switchToHttp().getRequest()
+    const user = req.user as RequestUser | undefined
+    const current = new Set(user?.permissions ?? [])
+
+    return required.every((perm) => current.has(perm))
+  }
+}
diff --git a/backend/ayanavitabackend/app/api/src/auth/jwt.strategy.ts b/backend/ayanavitabackend/app/api/src/auth/jwt.strategy.ts
index 7e7845301a0b7559c991a620271eae0466892d89..52edef67367a26fcac8e774543ba362f2e0e874c 100644
--- a/backend/ayanavitabackend/app/api/src/auth/jwt.strategy.ts
+++ b/backend/ayanavitabackend/app/api/src/auth/jwt.strategy.ts
@@ -1,23 +1,25 @@
 import { Injectable } from "@nestjs/common";
 import { PassportStrategy } from "@nestjs/passport";
 import { ExtractJwt, Strategy } from "passport-jwt";

 @Injectable()
 export class JwtStrategy extends PassportStrategy(Strategy) {
   constructor() {
     super({
       jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
       ignoreExpiration: false,
       secretOrKey: process.env.JWT_SECRET || "dev_secret_change_me",
     });
   }

   async validate(payload: any) {
     // payload hi·ªán t·∫°i c·ªßa b·∫°n: { sub, email, role, iat, exp }
     return {
       sub: payload.sub,
       email: payload.email,
       role: payload.role,
+      scopeType: payload.scopeType ?? null,
+      permissions: payload.permissions ?? [],
     };
   }
 }
diff --git a/backend/ayanavitabackend/app/api/src/booking/booking.service.ts b/backend/ayanavitabackend/app/api/src/booking/booking.service.ts
index 241b20e2e4d7ced019bd32b08856c60f53cd24e6..e03294f0c66af52358b25240d11bee17a869afaf 100644
--- a/backend/ayanavitabackend/app/api/src/booking/booking.service.ts
+++ b/backend/ayanavitabackend/app/api/src/booking/booking.service.ts
@@ -1,27 +1,27 @@
 import { BadRequestException, ForbiddenException, Injectable, Logger, NotFoundException } from '@nestjs/common'
-import { Prisma, Role } from '@prisma/client'
+import { Prisma, UserRole } from '@prisma/client'
 import * as bcrypt from 'bcrypt'
 import { promises as fs } from 'fs'
 import { createHash, createHmac, randomBytes } from 'crypto'
 import { extname, join } from 'path'
 import * as tls from 'tls'
 import { PrismaService } from '../prisma/prisma.service'
 import type { JwtUser } from '../auth/decorators/current-user.decorator'
 import { CreateAppointmentDto } from './dto/create-appointment.dto'
 import { AppointmentStatsQueryDto } from './dto/booking-query.dto'
 import {
   BranchResponseDto,
   ServiceCatalogItemDto,
   ServiceCategoryResponseDto,
   ServiceListResponseDto,
   ServiceDetailResponseDto,
   ServiceResponseDto,
   ServiceReviewResponseDto,
   SpecialistResponseDto,
   TempImageResponseDto,
 } from './dto/booking-response.dto'

 @Injectable()
 export class BookingService {
   private readonly logger = new Logger(BookingService.name)

@@ -563,53 +563,53 @@ export class BookingService {
         service: { select: { id: true, name: true, durationMin: true, price: true } },
         specialist: { select: { id: true, name: true, level: true } },
       },
       orderBy: { appointmentAt: 'desc' },
     })
   }

   private parseDateWindow(date: string) {
     const dayStart = new Date(`${date}T00:00:00`)
     const dayEnd = new Date(`${date}T23:59:59.999`)
     if (Number.isNaN(dayStart.getTime()) || Number.isNaN(dayEnd.getTime())) {
       throw new BadRequestException('Invalid date format, expected yyyy-mm-dd')
     }
     return { dayStart, dayEnd }
   }

   private toTimeLabel(date: Date) {
     return `${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}`
   }

   private overlaps(startA: Date, endA: Date, startB: Date, endB: Date) {
     return startA < endB && endA > startB
   }

   private async resolveAppointmentScope(user: JwtUser): Promise<Prisma.AppointmentWhereInput> {
-    if (user.role === Role.ADMIN) return {}
+    if (user.role === UserRole.ADMIN) return {}

-    if (user.role === Role.STAFF) {
+    if (user.role === UserRole.STAFF) {
       const specialist = await this.prisma.specialist.findFirst({
         where: { userId: user.sub, isActive: true },
         select: { id: true },
       })
       if (!specialist) {
         throw new ForbiddenException('Specialist profile is not active')
       }
       return { specialistId: specialist.id }
     }

     throw new ForbiddenException('B·∫°n kh√¥ng c√≥ quy·ªÅn xem l·ªãch h·∫πn')
   }

   private async validateSpecialistForAppointment(params: {
     specialistId: number
     branchId: number
     serviceId: number
     appointmentAt: Date
     serviceDurationMin: number
     ignoreAppointmentId?: number
   }) {
     const specialist = await this.prisma.specialist.findUnique({
       where: { id: params.specialistId },
       select: { id: true, name: true, branchId: true, isActive: true, user: { select: { email: true } } },
     })
@@ -824,64 +824,64 @@ export class BookingService {
           bookedCount: {
             increment: 1,
           },
         },
       })

       return appointment
     })

     return created
   }

   async updateAppointment(id: number, data: any, user: JwtUser) {
     const appointment = await this.prisma.appointment.findUnique({
       where: { id },
       include: {
         branch: { select: { name: true } },
         service: { select: { name: true, durationMin: true } },
         specialist: { select: { id: true, name: true } },
       },
     })
     if (!appointment) throw new NotFoundException('Appointment not found')

     const payload: Prisma.AppointmentUpdateInput = {}

-    if (user.role === Role.STAFF) {
+    if (user.role === UserRole.STAFF) {
       const specialist = await this.prisma.specialist.findFirst({ where: { userId: user.sub, isActive: true }, select: { id: true } })
       if (!specialist || appointment.specialistId !== specialist.id) {
         throw new ForbiddenException('B·∫°n ch·ªâ c√≥ th·ªÉ c·∫≠p nh·∫≠t l·ªãch h·∫πn ƒë∆∞·ª£c ph√¢n c√¥ng')
       }
       const nextStatus = String(data.status || '').toUpperCase()
       if (!['DONE', 'CANCELED'].includes(nextStatus)) {
         throw new BadRequestException('Staff only can set status DONE or CANCELED')
       }
       payload.status = nextStatus as any
       return this.prisma.appointment.update({ where: { id }, data: payload })
     }

-    if (user.role !== Role.ADMIN) {
+    if (user.role !== UserRole.ADMIN) {
       throw new ForbiddenException('B·∫°n kh√¥ng c√≥ quy·ªÅn c·∫≠p nh·∫≠t l·ªãch h·∫πn')
     }

     if (data.status !== undefined) {
       const nextStatus = String(data.status || '').toUpperCase()
       if (!['PENDING', 'CONFIRMED', 'DONE', 'CANCELED'].includes(nextStatus)) {
         throw new BadRequestException('Invalid appointment status')
       }
       payload.status = nextStatus as any
     }

     if (data.specialistId !== undefined) {
       const specialistId = data.specialistId === null || data.specialistId === '' ? null : Number(data.specialistId)
       if (specialistId !== null && (!Number.isInteger(specialistId) || specialistId < 1)) {
         throw new BadRequestException('specialistId must be a positive integer or null')
       }

       if (specialistId) {
         const specialist = await this.validateSpecialistForAppointment({
           specialistId,
           branchId: appointment.branchId,
           serviceId: appointment.serviceId,
           appointmentAt: appointment.appointmentAt,
           serviceDurationMin: appointment.service.durationMin,
           ignoreAppointmentId: appointment.id,
@@ -1119,51 +1119,51 @@ export class BookingService {
       }
     }

     await this.prisma.branch.delete({ where: { id } })
     return { ok: true, softDeleted: false }
   }

   async createSpecialist(data: any) {
     const branchId = Number(data.branchId)
     if (!Number.isInteger(branchId) || branchId < 1) {
       throw new BadRequestException('branchId is required')
     }
     const email = String(data.email || '').trim().toLowerCase()
     if (!email) {
       throw new BadRequestException('email is required')
     }
     const password = this.generatePassword()
     const passwordHash = await bcrypt.hash(password, 10)
     const serviceIds = this.toPositiveIntArray(data.serviceIds)

     const created = await this.prisma.$transaction(async (tx) => {
       const user = await tx.user.create({
         data: {
           email,
           password: passwordHash,
-          role: Role.STAFF,
+          role: UserRole.STAFF,
             name: String(data.name || '').trim() || null,
         },
       })

       const specialist = await tx.specialist.create({
         data: {
             name: String(data.name || '').trim(),
           level: data.level,
           bio: data.bio,
           branchId,
           userId: user.id,
         },
       })

       await this.upsertSpecialistTranslations(tx, specialist.id, data.translations)

       if (serviceIds.length > 0) {
         await tx.specialistBranchService.createMany({
           data: serviceIds.map((serviceId) => ({ specialistId: specialist.id, branchId, serviceId })),
           skipDuplicates: true,
         })
       }

       return specialist
     })
@@ -1183,51 +1183,51 @@ export class BookingService {

     const payload: Record<string, unknown> = {}
     let branchId = specialist.branchId
     if (data.branchId !== undefined) {
       const parsedBranchId = Number(data.branchId)
       if (!Number.isInteger(parsedBranchId) || parsedBranchId < 1) {
         throw new BadRequestException('branchId is invalid')
       }
       branchId = parsedBranchId
       payload.branchId = branchId
     }

     if (data.name !== undefined) payload.name = String(data.name || '').trim()
     if (data.level !== undefined) payload.level = data.level
     if (data.bio !== undefined) payload.bio = data.bio

     const email = data.email !== undefined ? String(data.email || '').trim().toLowerCase() : specialist.user.email
     const serviceIds = this.toPositiveIntArray(data.serviceIds)
     const shouldResetPassword = data.email !== undefined && email !== specialist.user.email

     if (!email) throw new BadRequestException('email is required')

     return this.prisma.$transaction(async (tx) => {
       const userData: Record<string, unknown> = {
         email,
-        role: Role.STAFF,
+        role: UserRole.STAFF,
       }
       if (data.name !== undefined) {
         userData.name = String(data.name || '').trim() || null
       }

       let plainPassword: string | null = null
       if (shouldResetPassword) {
         plainPassword = this.generatePassword()
         userData.password = await bcrypt.hash(plainPassword, 10)
       }

       await tx.user.update({ where: { id: specialist.userId }, data: userData })

       const updated = await tx.specialist.update({ where: { id }, data: payload })
       await this.upsertSpecialistTranslations(tx, id, data.translations)

       await tx.specialistBranchService.deleteMany({ where: { specialistId: id } })
       await this.upsertSpecialistTranslations(tx, specialist.id, data.translations)

       if (serviceIds.length > 0) {
         await tx.specialistBranchService.createMany({
           data: serviceIds.map((serviceId) => ({ specialistId: id, branchId, serviceId })),
           skipDuplicates: true,
         })
       }
diff --git a/backend/ayanavitabackend/app/api/src/cms/admin/cms-admin.controller.ts b/backend/ayanavitabackend/app/api/src/cms/admin/cms-admin.controller.ts
index e745ccb7013d0a1e8854106294b314744e49ca90..9aa7a70e21fa02e58df84fb04d111d10d77abc0b 100644
--- a/backend/ayanavitabackend/app/api/src/cms/admin/cms-admin.controller.ts
+++ b/backend/ayanavitabackend/app/api/src/cms/admin/cms-admin.controller.ts
@@ -1,39 +1,39 @@
 import { Body, Controller, Delete, Get, Param, Post, Put, Query, UploadedFile, UseGuards, UseInterceptors } from "@nestjs/common";
 import { SaveDraftDto } from "./dto/save-draft.dto";
 import { RestoreDto } from "./dto/restore.dto";
 import { RolesGuard } from "../../auth/roles.guard";
 import { Roles } from "../../auth/roles.decorator";
 import { CmsAdminService } from "./cms-admin.service";
-import { Role } from "@prisma/client";
+import { UserRole } from "@prisma/client";
 import { AccessTokenGuard } from "../../auth/guards/access-token.guard";
 import { FileInterceptor } from "@nestjs/platform-express";
 import { ImageUploadService } from "../../services/ImageUploadService";

 @Controller("admin/cms")
 @UseGuards(AccessTokenGuard, RolesGuard)
-@Roles(Role.ADMIN) // ho·∫∑c @Roles("ADMIN")
+@Roles(UserRole.ADMIN) // ho·∫∑c @Roles("ADMIN")
 export class CmsAdminController {
   constructor(
     private readonly svc: CmsAdminService,
     private readonly imageUploadService: ImageUploadService,
   ) {}

   @Get("pages")
   listPages() {
     return this.svc.listPages();
   }

   @Get("pages/:slug")
   page(@Param("slug") slug: string) {
     return this.svc.getPageBySlug(slug);
   }

   @Put("sections/:id/draft")
   saveDraft(
     @Param("id") id: string,
     @Query("locale") locale: string,
     @Body() dto: SaveDraftDto,
   ) {
     // userId: n·∫øu b·∫°n c√≥ current-user decorator th√¨ truy·ªÅn v√†o ·ªü ƒë√¢y
     return this.svc.saveDraft(Number(id), locale, dto.draftData, dto.note, undefined);
   }
diff --git a/backend/ayanavitabackend/app/api/src/enrollments/enrollments.service.ts b/backend/ayanavitabackend/app/api/src/enrollments/enrollments.service.ts
index 1490686b854c28374cd11bb7a9787d2f1a95d4d1..c1b6a53e6bd5e9842935300cc884866000719f1a 100644
--- a/backend/ayanavitabackend/app/api/src/enrollments/enrollments.service.ts
+++ b/backend/ayanavitabackend/app/api/src/enrollments/enrollments.service.ts
@@ -1,30 +1,30 @@
 import { ForbiddenException, Injectable, NotFoundException } from '@nestjs/common'
-import { CourseAccessStatus, Prisma, Role } from '@prisma/client'
+import { CourseAccessStatus, Prisma, UserRole } from '@prisma/client'
 import { PrismaService } from '../prisma/prisma.service'

-type JwtUser = { sub: number; role: Role | string }
+type JwtUser = { sub: number; role: UserRole | string }

 @Injectable()
 export class EnrollmentsService {
   constructor(private readonly prisma: PrismaService) {}

   private resolveLocale(lang?: string) {
     const normalized = (lang || 'vi').toLowerCase()
     if (normalized === 'en' || normalized === 'de') return normalized
     return 'vi'
   }

   async myEnrollments(userId: number, status?: CourseAccessStatus | 'ALL') {
     const where: Prisma.CourseAccessWhereInput = {
       userId,
       ...(status && status !== 'ALL' ? { status } : {}),
     }

     return this.prisma.courseAccess.findMany({
       where,
       select: {
         id: true,
         userId: true,
         courseId: true,
         status: true,
         grantedAt: true,
diff --git a/backend/ayanavitabackend/app/api/src/rbac/dto/assign-permissions.dto.ts b/backend/ayanavitabackend/app/api/src/rbac/dto/assign-permissions.dto.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2c2b959a144f7ca508797ab3523509af292d2753
--- /dev/null
+++ b/backend/ayanavitabackend/app/api/src/rbac/dto/assign-permissions.dto.ts
@@ -0,0 +1,8 @@
+import { ArrayNotEmpty, IsArray, IsInt } from 'class-validator'
+
+export class AssignPermissionsDto {
+  @IsArray()
+  @ArrayNotEmpty()
+  @IsInt({ each: true })
+  permissionIds!: number[]
+}
diff --git a/backend/ayanavitabackend/app/api/src/rbac/dto/create-permission.dto.ts b/backend/ayanavitabackend/app/api/src/rbac/dto/create-permission.dto.ts
new file mode 100644
index 0000000000000000000000000000000000000000..64d2cd11f910ec776ce1201c4c7111ebea465d76
--- /dev/null
+++ b/backend/ayanavitabackend/app/api/src/rbac/dto/create-permission.dto.ts
@@ -0,0 +1,15 @@
+import { IsString, MaxLength } from 'class-validator'
+
+export class CreatePermissionDto {
+  @IsString()
+  @MaxLength(120)
+  code!: string
+
+  @IsString()
+  @MaxLength(80)
+  resource!: string
+
+  @IsString()
+  @MaxLength(80)
+  action!: string
+}
diff --git a/backend/ayanavitabackend/app/api/src/rbac/dto/create-role.dto.ts b/backend/ayanavitabackend/app/api/src/rbac/dto/create-role.dto.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4b9ddf77cedd16987e950ba569200b142216d72
--- /dev/null
+++ b/backend/ayanavitabackend/app/api/src/rbac/dto/create-role.dto.ts
@@ -0,0 +1,22 @@
+import { IsEnum, IsOptional, IsString, MaxLength } from 'class-validator'
+
+export enum ScopeTypeDto {
+  OWN = 'OWN',
+  BRANCH = 'BRANCH',
+  COURSE = 'COURSE',
+  GLOBAL = 'GLOBAL',
+}
+
+export class CreateRoleDto {
+  @IsString()
+  @MaxLength(50)
+  code!: string
+
+  @IsEnum(ScopeTypeDto)
+  scopeType!: ScopeTypeDto
+
+  @IsOptional()
+  @IsString()
+  @MaxLength(255)
+  description?: string
+}
diff --git a/backend/ayanavitabackend/app/api/src/rbac/dto/update-permission.dto.ts b/backend/ayanavitabackend/app/api/src/rbac/dto/update-permission.dto.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3a3e4e0b592115b89d95d17e3b4c5e361b699dd1
--- /dev/null
+++ b/backend/ayanavitabackend/app/api/src/rbac/dto/update-permission.dto.ts
@@ -0,0 +1,4 @@
+import { PartialType } from '@nestjs/mapped-types'
+import { CreatePermissionDto } from './create-permission.dto'
+
+export class UpdatePermissionDto extends PartialType(CreatePermissionDto) {}
diff --git a/backend/ayanavitabackend/app/api/src/rbac/dto/update-role.dto.ts b/backend/ayanavitabackend/app/api/src/rbac/dto/update-role.dto.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4072a3338d19278963a2e7f597e40db82a26728c
--- /dev/null
+++ b/backend/ayanavitabackend/app/api/src/rbac/dto/update-role.dto.ts
@@ -0,0 +1,4 @@
+import { PartialType } from '@nestjs/mapped-types'
+import { CreateRoleDto } from './create-role.dto'
+
+export class UpdateRoleDto extends PartialType(CreateRoleDto) {}
diff --git a/backend/ayanavitabackend/app/api/src/rbac/rbac.controller.ts b/backend/ayanavitabackend/app/api/src/rbac/rbac.controller.ts
new file mode 100644
index 0000000000000000000000000000000000000000..448557e0501b6401b3079604a3dc080baab05b3e
--- /dev/null
+++ b/backend/ayanavitabackend/app/api/src/rbac/rbac.controller.ts
@@ -0,0 +1,70 @@
+import { Body, Controller, Delete, Get, Param, ParseIntPipe, Post, Put, UseGuards } from '@nestjs/common'
+import { AccessTokenGuard } from '../auth/guards/access-token.guard'
+import { Permissions } from '../auth/decorators/permissions.decorator'
+import { PermissionGuard } from '../auth/guards/permission.guard'
+import { AssignPermissionsDto } from './dto/assign-permissions.dto'
+import { CreatePermissionDto } from './dto/create-permission.dto'
+import { CreateRoleDto } from './dto/create-role.dto'
+import { UpdatePermissionDto } from './dto/update-permission.dto'
+import { UpdateRoleDto } from './dto/update-role.dto'
+import { RbacService } from './rbac.service'
+
+@UseGuards(AccessTokenGuard, PermissionGuard)
+@Controller()
+export class RbacController {
+  constructor(private readonly rbac: RbacService) {}
+
+  @Post('roles')
+  @Permissions('role.manage')
+  createRole(@Body() dto: CreateRoleDto) {
+    return this.rbac.createRole(dto)
+  }
+
+  @Get('roles')
+  @Permissions('role.read')
+  getRoles() {
+    return this.rbac.findAllRoles()
+  }
+
+  @Put('roles/:id')
+  @Permissions('role.manage')
+  updateRole(@Param('id', ParseIntPipe) id: number, @Body() dto: UpdateRoleDto) {
+    return this.rbac.updateRole(id, dto)
+  }
+
+  @Delete('roles/:id')
+  @Permissions('role.manage')
+  deleteRole(@Param('id', ParseIntPipe) id: number) {
+    return this.rbac.deleteRole(id)
+  }
+
+  @Post('permissions')
+  @Permissions('role.manage')
+  createPermission(@Body() dto: CreatePermissionDto) {
+    return this.rbac.createPermission(dto)
+  }
+
+  @Get('permissions')
+  @Permissions('role.read')
+  getPermissions() {
+    return this.rbac.findAllPermissions()
+  }
+
+  @Put('permissions/:id')
+  @Permissions('role.manage')
+  updatePermission(@Param('id', ParseIntPipe) id: number, @Body() dto: UpdatePermissionDto) {
+    return this.rbac.updatePermission(id, dto)
+  }
+
+  @Delete('permissions/:id')
+  @Permissions('role.manage')
+  deletePermission(@Param('id', ParseIntPipe) id: number) {
+    return this.rbac.deletePermission(id)
+  }
+
+  @Post('roles/:roleId/permissions')
+  @Permissions('role.manage')
+  assignPermissions(@Param('roleId', ParseIntPipe) roleId: number, @Body() dto: AssignPermissionsDto) {
+    return this.rbac.assignPermissionsToRole(roleId, dto)
+  }
+}
diff --git a/backend/ayanavitabackend/app/api/src/rbac/rbac.module.ts b/backend/ayanavitabackend/app/api/src/rbac/rbac.module.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ec845daacee3ef7cd0a2128e5d643e51e64a52b9
--- /dev/null
+++ b/backend/ayanavitabackend/app/api/src/rbac/rbac.module.ts
@@ -0,0 +1,11 @@
+import { Module } from '@nestjs/common'
+import { RbacController } from './rbac.controller'
+import { RbacService } from './rbac.service'
+import { PermissionGuard } from '../auth/guards/permission.guard'
+
+@Module({
+  controllers: [RbacController],
+  providers: [RbacService, PermissionGuard],
+  exports: [RbacService],
+})
+export class RbacModule {}
diff --git a/backend/ayanavitabackend/app/api/src/rbac/rbac.service.ts b/backend/ayanavitabackend/app/api/src/rbac/rbac.service.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d36759abda4cac39b7d9ea3843c24c9477efba18
--- /dev/null
+++ b/backend/ayanavitabackend/app/api/src/rbac/rbac.service.ts
@@ -0,0 +1,110 @@
+import { Injectable, NotFoundException } from '@nestjs/common'
+import { PrismaService } from '../prisma/prisma.service'
+import { AssignPermissionsDto } from './dto/assign-permissions.dto'
+import { CreatePermissionDto } from './dto/create-permission.dto'
+import { CreateRoleDto } from './dto/create-role.dto'
+import { UpdatePermissionDto } from './dto/update-permission.dto'
+import { UpdateRoleDto } from './dto/update-role.dto'
+
+@Injectable()
+export class RbacService {
+  constructor(private readonly prisma: PrismaService) {}
+
+  createRole(dto: CreateRoleDto) {
+    return this.prisma.rbacRole.create({ data: dto })
+  }
+
+  findAllRoles() {
+    return this.prisma.rbacRole.findMany({
+      include: {
+        permissions: { include: { permission: true } },
+      },
+      orderBy: { id: 'asc' },
+    })
+  }
+
+  async updateRole(id: number, dto: UpdateRoleDto) {
+    await this.ensureRole(id)
+    return this.prisma.rbacRole.update({ where: { id }, data: dto })
+  }
+
+  async deleteRole(id: number) {
+    await this.ensureRole(id)
+    return this.prisma.rbacRole.delete({ where: { id } })
+  }
+
+  createPermission(dto: CreatePermissionDto) {
+    return this.prisma.permission.create({ data: dto })
+  }
+
+  findAllPermissions() {
+    return this.prisma.permission.findMany({ orderBy: { id: 'asc' } })
+  }
+
+  async updatePermission(id: number, dto: UpdatePermissionDto) {
+    await this.ensurePermission(id)
+    return this.prisma.permission.update({ where: { id }, data: dto })
+  }
+
+  async deletePermission(id: number) {
+    await this.ensurePermission(id)
+    return this.prisma.permission.delete({ where: { id } })
+  }
+
+  async assignPermissionsToRole(roleId: number, dto: AssignPermissionsDto) {
+    await this.ensureRole(roleId)
+
+    const found = await this.prisma.permission.findMany({
+      where: { id: { in: dto.permissionIds } },
+      select: { id: true },
+    })
+
+    if (found.length !== dto.permissionIds.length) {
+      throw new NotFoundException('M·ªôt ho·∫∑c nhi·ªÅu permission kh√¥ng t·ªìn t·∫°i')
+    }
+
+    await this.prisma.$transaction([
+      this.prisma.rolePermission.deleteMany({ where: { roleId } }),
+      this.prisma.rolePermission.createMany({
+        data: [...new Set(dto.permissionIds)].map((permissionId) => ({ roleId, permissionId })),
+      }),
+    ])
+
+    return this.prisma.rbacRole.findUnique({
+      where: { id: roleId },
+      include: { permissions: { include: { permission: true } } },
+    })
+  }
+
+  async getUserPermissions(userId: number) {
+    const user = await this.prisma.user.findUnique({
+      where: { id: userId },
+      include: {
+        roleRef: {
+          include: {
+            permissions: { include: { permission: true } },
+          },
+        },
+      },
+    })
+
+    if (!user) throw new NotFoundException('User not found')
+
+    return {
+      id: user.id,
+      role: user.roleRef?.code ?? null,
+      scopeType: user.roleRef?.scopeType ?? null,
+      permissions: user.roleRef?.permissions.map((rp) => rp.permission.code) ?? [],
+    }
+  }
+
+  private async ensureRole(id: number) {
+    const role = await this.prisma.rbacRole.findUnique({ where: { id }, select: { id: true } })
+    if (!role) throw new NotFoundException('Role not found')
+  }
+
+  private async ensurePermission(id: number) {
+    const permission = await this.prisma.permission.findUnique({ where: { id }, select: { id: true } })
+    if (!permission) throw new NotFoundException('Permission not found')
+  }
+}
diff --git a/backend/ayanavitabackend/app/api/src/users/dto/assign-role.dto.ts b/backend/ayanavitabackend/app/api/src/users/dto/assign-role.dto.ts
new file mode 100644
index 0000000000000000000000000000000000000000..bd69355fbf01dc211adafda72a94697866b69b3d
--- /dev/null
+++ b/backend/ayanavitabackend/app/api/src/users/dto/assign-role.dto.ts
@@ -0,0 +1,6 @@
+import { IsInt } from 'class-validator'
+
+export class AssignRoleDto {
+  @IsInt()
+  roleId!: number
+}
diff --git a/backend/ayanavitabackend/app/api/src/users/users.controller.ts b/backend/ayanavitabackend/app/api/src/users/users.controller.ts
index 4a891cd26f7c62040aaf26dbc5b595ddcedf3152..9d244adb127bbc4e77a950611d7f7f39cf198265 100644
--- a/backend/ayanavitabackend/app/api/src/users/users.controller.ts
+++ b/backend/ayanavitabackend/app/api/src/users/users.controller.ts
@@ -1,17 +1,28 @@
-import { Controller, Get, UseGuards } from '@nestjs/common'
+import { Body, Controller, Get, Param, ParseIntPipe, Put, UseGuards } from '@nestjs/common'
 import { UsersService } from './users.service'
 import { AccessTokenGuard } from '../auth/guards/access-token.guard'
 import { RolesGuard } from '../auth/guards/roles.guard'
 import { Roles } from '../auth/decorators/roles.decorator'
+import { AssignRoleDto } from './dto/assign-role.dto'

 @Controller('users')
 export class UsersController {
   constructor(private readonly users: UsersService) {}

   @UseGuards(AccessTokenGuard, RolesGuard)
   @Roles('ADMIN')
   @Get()
   findAll() {
     return this.users.findAll()
   }
+
+  @UseGuards(AccessTokenGuard, RolesGuard)
+  @Roles('ADMIN')
+  @Put(':id/role')
+  assignRole(
+    @Param('id', ParseIntPipe) id: number,
+    @Body() dto: AssignRoleDto,
+  ) {
+    return this.users.assignRole(id, dto.roleId)
+  }
 }
diff --git a/backend/ayanavitabackend/app/api/src/users/users.service.ts b/backend/ayanavitabackend/app/api/src/users/users.service.ts
index bf8ad6296670757e1e619738ccd60b4b3ee5c6f2..61aca5be0e7649b764e987accd9801d47cf6f8f6 100644
--- a/backend/ayanavitabackend/app/api/src/users/users.service.ts
+++ b/backend/ayanavitabackend/app/api/src/users/users.service.ts
@@ -1,22 +1,44 @@
-import { Injectable } from '@nestjs/common'
+import { Injectable, NotFoundException } from '@nestjs/common'
 import { PrismaService } from '../prisma/prisma.service'

 @Injectable()
 export class UsersService {
   constructor(private readonly prisma: PrismaService) {}
-

   findAll() {
     return this.prisma.user.findMany({
       select: {
         id: true,
         email: true,
         name: true,
         role: true,
+        roleId: true,
+        roleRef: { select: { code: true, scopeType: true } },
         createdAt: true,
         updatedAt: true,
       },
       orderBy: { id: 'asc' },
     })
   }
+
+  async assignRole(userId: number, roleId: number) {
+    const [user, role] = await Promise.all([
+      this.prisma.user.findUnique({ where: { id: userId }, select: { id: true } }),
+      this.prisma.rbacRole.findUnique({ where: { id: roleId }, select: { id: true, code: true, scopeType: true } }),
+    ])
+
+    if (!user) throw new NotFoundException('User not found')
+    if (!role) throw new NotFoundException('Role not found')
+
+    return this.prisma.user.update({
+      where: { id: userId },
+      data: { roleId },
+      select: {
+        id: true,
+        email: true,
+        roleId: true,
+        roleRef: { select: { id: true, code: true, scopeType: true } },
+      },
+    })
+  }
 }
diff --git a/beay/src/app/api.ts b/beay/src/app/api.ts
index 22c990abd1d545a60863edc3a32de022b6cc3504..6e52f7b1c38deac25f59e0916625f3e78809e317 100644
--- a/beay/src/app/api.ts
+++ b/beay/src/app/api.ts
@@ -1,32 +1,48 @@
 const API_BASE = (import.meta.env.VITE_API_BASE || "http://localhost:8090").replace(/\/+$/, "");
+const TOKEN_KEY = "aya_admin_token";

 function joinUrl(path: string) {
   const cleanPath = path.startsWith("/") ? path : `/${path}`;
   return `${API_BASE}${cleanPath}`;
 }

+async function request<T>(path: string, init: RequestInit = {}): Promise<T> {
+  const token = localStorage.getItem(TOKEN_KEY) || "";
+  const headers = new Headers(init.headers);
+  if (!headers.has("Content-Type") && init.body) headers.set("Content-Type", "application/json");
+  if (token) headers.set("Authorization", `Bearer ${token}`);
+
+  const response = await fetch(joinUrl(path), { ...init, headers, credentials: "include" });
+  const text = await response.text();
+  if (!response.ok) throw new Error(text || `HTTP ${response.status}`);
+  return text ? (JSON.parse(text) as T) : ({} as T);
+}
+
 type LoginResponse = {
   accessToken: string;
 };

 export async function login(email: string, password: string): Promise<LoginResponse> {
-  const response = await fetch(joinUrl("/auth/login"), {
+  return request<LoginResponse>("/auth/login", {
     method: "POST",
-    headers: {
-      "Content-Type": "application/json",
-    },
     body: JSON.stringify({ email, password }),
-    credentials: "include",
   });
+}

-  const text = await response.text();
-  if (!response.ok) {
-    throw new Error(text || "Login failed");
-  }
+export type ApiRole = { id: number; code: string; scopeType: "OWN" | "BRANCH" | "COURSE" | "GLOBAL"; description?: string | null };
+export type ApiPermission = { id: number; code: string; resource: string; action: string };
+export type ApiUser = { id: number; email: string; roleId: number | null; roleRef?: { id: number; code: string; scopeType: string } | null };

-  if (!text) {
-    throw new Error("Empty response from server");
-  }
+export const getRoles = () => request<ApiRole[]>("/roles");
+export const createRole = (payload: Omit<ApiRole, "id">) => request<ApiRole>("/roles", { method: "POST", body: JSON.stringify(payload) });
+export const updateRole = (id: number, payload: Partial<Omit<ApiRole, "id">>) => request<ApiRole>(`/roles/${id}`, { method: "PUT", body: JSON.stringify(payload) });
+export const deleteRole = (id: number) => request<void>(`/roles/${id}`, { method: "DELETE" });

-  return JSON.parse(text) as LoginResponse;
-}
+export const getPermissions = () => request<ApiPermission[]>("/permissions");
+export const createPermission = (payload: Omit<ApiPermission, "id">) => request<ApiPermission>("/permissions", { method: "POST", body: JSON.stringify(payload) });
+export const updatePermission = (id: number, payload: Partial<Omit<ApiPermission, "id">>) => request<ApiPermission>(`/permissions/${id}`, { method: "PUT", body: JSON.stringify(payload) });
+export const deletePermission = (id: number) => request<void>(`/permissions/${id}`, { method: "DELETE" });
+
+export const assignPermissionsToRole = (roleId: number, permissionIds: number[]) => request(`/roles/${roleId}/permissions`, { method: "POST", body: JSON.stringify({ permissionIds }) });
+export const getUsers = () => request<ApiUser[]>("/users");
+export const assignRoleToUser = (userId: number, roleId: number) => request(`/users/${userId}/role`, { method: "PUT", body: JSON.stringify({ roleId }) });
diff --git a/beay/src/pages/admin/AdminRbacPage.tsx b/beay/src/pages/admin/AdminRbacPage.tsx
index f608eed58f7b31c227db3a7ce96eb05618da9548..6abb8a3616d39d35205eaae15fff0b3f10c7fdc3 100644
--- a/beay/src/pages/admin/AdminRbacPage.tsx
+++ b/beay/src/pages/admin/AdminRbacPage.tsx
@@ -1,548 +1,216 @@
-// src/pages/admin/AdminRbacPage.tsx
-import { useMemo, useState } from "react";
+import { useEffect, useMemo, useState } from "react";
 import { useToast } from "../../ui/toast";
+import {
+  assignPermissionsToRole,
+  assignRoleToUser,
+  createRole as apiCreateRole,
+  deleteRole as apiDeleteRole,
+  getPermissions,
+  getRoles,
+  getUsers,
+  updateRole as apiUpdateRole,
+} from "../../app/api";

 import { MODULES, PERMS, DEFAULT_ROLES, ACTIONS } from "./rbac/rbac.catalog";
-import type {
-  Assignment,
-  AuditItem,
-  Role,
-  RolePermMap,
-  TestScope,
-} from "./rbac/rbac.model";
+import type { Assignment, AuditItem, Role, RolePermMap, TestScope } from "./rbac/rbac.model";
 import { presetMap, type PresetKey } from "./rbac/rbac.presets";
-import {
-  loadAssignments,
-  loadAudit,
-  loadRolePerms,
-  loadRoles,
-  nowISO,
-  saveAssignments,
-  saveAudit,
-  saveRolePerms,
-  saveRoles,
-} from "./rbac/rbac.storage";
-import { addCadence, fmtDate, parseDate } from "./rbac/rbac.date";
+import { nowISO } from "./rbac/rbac.storage";

 import { RbacHeader } from "./rbac/ui/RbacHeader";
 import { RolesPanel } from "./rbac/ui/RolesPanel";
 import { PermissionsMatrix } from "./rbac/ui/PermissionsMatrix";
 import { AssignmentsPanel } from "./rbac/ui/AssignmentsPanel";
 import { AuditPanel } from "./rbac/ui/AuditPanel";
 import { TestAccessDrawer } from "./rbac/ui/TestAccessDrawer";

-/** helpers */
-function omitKey<T extends Record<string, unknown>>(obj: T, key: string): T {
-  const copy: Record<string, unknown> = { ...obj };
-  delete copy[key];
-  return copy as T;
-}
-
-function isRecord(v: unknown): v is Record<string, unknown> {
-  return typeof v === "object" && v !== null;
-}
-function isRoleArray(v: unknown): v is Role[] {
-  return Array.isArray(v) && v.every((x) => isRecord(x) && typeof x.key === "string");
-}
-function isRolePermMap(v: unknown): v is RolePermMap {
-  if (!isRecord(v)) return false;
-  for (const k of Object.keys(v)) {
-    const arr = (v as Record<string, unknown>)[k];
-    if (!Array.isArray(arr) || !arr.every((x) => typeof x === "string")) return false;
-  }
-  return true;
-}
-function isAssignmentArray(v: unknown): v is Assignment[] {
-  return (
-    Array.isArray(v) &&
-    v.every(
-      (x) =>
-        isRecord(x) &&
-        typeof x.id === "number" &&
-        typeof x.user === "string" &&
-        typeof x.role === "string" &&
-        isRecord(x.scope) &&
-        typeof x.scope.type === "string" &&
-        isRecord(x.cadence) &&
-        typeof x.cadence.unit === "string" &&
-        typeof x.cadence.value === "number" &&
-        typeof x.startAt === "string" &&
-        typeof x.expiresAt === "string"
-    )
-  );
-}
-
 export function AdminRbacPage() {
   const { toast } = useToast();
-
-  const [roles, setRoles] = useState<Role[]>(() => loadRoles());
-  const [rolePerms, setRolePerms] = useState<RolePermMap>(() =>
-    loadRolePerms(loadRoles().map((r) => r.key))
-  );
-  const [assignments, setAssignments] = useState<Assignment[]>(() =>
-    loadAssignments()
-  );
-  const [audit, setAudit] = useState<AuditItem[]>(() => loadAudit());
+  const [loading, setLoading] = useState(true);
+  const [roles, setRoles] = useState<Role[]>([]);
+  const [roleIdMap, setRoleIdMap] = useState<Record<string, number>>({});
+  const [permCodeToId, setPermCodeToId] = useState<Record<string, number>>({});
+  const [rolePerms, setRolePerms] = useState<RolePermMap>({});
+  const [assignments, setAssignments] = useState<Assignment[]>([]);
+  const [audit, setAudit] = useState<AuditItem[]>([]);

   const [activeRole, setActiveRole] = useState<string>("ADMIN");
   const [roleSearch, setRoleSearch] = useState("");
   const [moduleFilter, setModuleFilter] = useState<string>("ALL");
-
-  // Drawer test access
   const [testOpen, setTestOpen] = useState(false);
-  const [testKey, setTestKey] = useState(0); // remount to reset form
+  const [testKey, setTestKey] = useState(0);

-  const activePermSet = useMemo(
-    () => new Set(rolePerms[activeRole] ?? []),
-    [rolePerms, activeRole]
-  );
+  useEffect(() => {
+    void loadData();
+  }, []);

+  async function loadData() {
+    setLoading(true);
+    try {
+      const [rolesRaw, permsRaw, usersRaw] = await Promise.all([getRoles(), getPermissions(), getUsers()]);
+      const roleRows = rolesRaw as Array<{ id: number; code: string; scopeType: Role["scope"]; description?: string; permissions?: Array<{ permission: { code: string } }> }>;
+      const nextRoles: Role[] = roleRows.map((r) => ({ key: r.code, name: r.code, desc: r.description || "", scope: r.scopeType, tier: "custom" }));
+      const rolePermMap: RolePermMap = {};
+      const nextRoleIdMap: Record<string, number> = {};
+      roleRows.forEach((r) => {
+        nextRoleIdMap[r.code] = r.id;
+        rolePermMap[r.code] = (r.permissions || []).map((x) => x.permission.code);
+      });
+      const nextPermCodeToId: Record<string, number> = {};
+      permsRaw.forEach((p) => {
+        nextPermCodeToId[p.code] = p.id;
+      });
+      const nextAssignments: Assignment[] = usersRaw
+        .filter((u) => u.roleRef?.code)
+        .map((u) => ({
+          id: u.id,
+          user: u.email,
+          role: u.roleRef!.code,
+          scope: { type: (u.roleRef!.scopeType as Assignment["scope"]["type"]) || "OWN", id: null },
+          cadence: { unit: "year", value: 10 },
+          startAt: "2025-01-01",
+          expiresAt: "2099-12-31",
+        }));
+
+      setRoles(nextRoles.length ? nextRoles : [...DEFAULT_ROLES] as unknown as Role[]);
+      setRoleIdMap(nextRoleIdMap);
+      setPermCodeToId(nextPermCodeToId);
+      setRolePerms(rolePermMap);
+      setAssignments(nextAssignments);
+    } catch (e) {
+      toast("L·ªói t·∫£i RBAC", e instanceof Error ? e.message : "Unknown error");
+    } finally {
+      setLoading(false);
+    }
+  }
+
+  const activePermSet = useMemo(() => new Set(rolePerms[activeRole] ?? []), [rolePerms, activeRole]);
   const visibleRoles = useMemo(() => {
     const kw = roleSearch.trim().toLowerCase();
-    return roles.filter(
-      (r) =>
-        !kw ||
-        (r.key + " " + r.name + " " + r.desc).toLowerCase().includes(kw)
-    );
+    return roles.filter((r) => !kw || (r.key + " " + r.name + " " + r.desc).toLowerCase().includes(kw));
   }, [roles, roleSearch]);
-
-  const filteredPerms = useMemo(() => {
-    return moduleFilter === "ALL"
-      ? PERMS
-      : PERMS.filter((p) => p.module === moduleFilter);
-  }, [moduleFilter]);
+  const filteredPerms = useMemo(() => (moduleFilter === "ALL" ? PERMS : PERMS.filter((p) => p.module === moduleFilter)), [moduleFilter]);

   function pushAudit(type: AuditItem["type"], msg: string) {
-    const item: AuditItem = { at: nowISO(), type, msg };
-    const next = [item, ...audit].slice(0, 200);
-    setAudit(next);
-    saveAudit(next);
-  }
-
-  function ensureRoleKeyExists(key: string) {
-    setRolePerms((prev) => {
-      if (prev[key]) return prev;
-      const next = { ...prev, [key]: [] };
-      saveRolePerms(next);
-      return next;
-    });
-  }
-
-  // ===== Role actions =====
-  function createRole() {
-    const key = (prompt("Nh·∫≠p key role (VD: MANAGER):", "MANAGER") || "")
-      .trim()
-      .toUpperCase();
-    if (!key) return;
-    if (roles.some((r) => r.key === key)) {
-      toast("Tr√πng role", "Role ƒë√£ t·ªìn t·∫°i.");
-      return;
-    }
-
-    const name = prompt("T√™n hi·ªÉn th·ªã:", key) || key;
-    const desc = prompt("M√¥ t·∫£:", "Vai tr√≤ m·ªõi") || "Vai tr√≤ m·ªõi";
-    const scope = (prompt("Scope (OWN/BRANCH/COURSE/GLOBAL):", "GLOBAL") ||
-      "GLOBAL") as Role["scope"];
-    const tier = (prompt("Tier (basic/staff/admin/root/custom):", "custom") ||
-      "custom") as Role["tier"];
-
-    const nextRoles: Role[] = [...roles, { key, name, desc, scope, tier }];
-    setRoles(nextRoles);
-    saveRoles(nextRoles);
-
-    const nextPerms: RolePermMap = { ...rolePerms, [key]: [] };
-    setRolePerms(nextPerms);
-    saveRolePerms(nextPerms);
-
-    setActiveRole(key);
-    pushAudit("ROLE", `T·∫°o role ${key}`);
-    toast("ƒê√£ t·∫°o role", key);
-  }
-
-  function editRole(key: string) {
-    const r = roles.find((x) => x.key === key);
-    if (!r) return;
-
-    const name = prompt("T√™n role:", r.name) ?? r.name;
-    const desc = prompt("M√¥ t·∫£ role:", r.desc) ?? r.desc;
-    const scope = (prompt("Scope (OWN/BRANCH/COURSE/GLOBAL):", r.scope) ??
-      r.scope) as Role["scope"];
-    const tier = (prompt("Tier (basic/staff/admin/root/custom):", r.tier) ??
-      r.tier) as Role["tier"];
-
-    const next = roles.map((x) =>
-      x.key === key ? { ...x, name, desc, scope, tier } : x
-    );
-    setRoles(next);
-    saveRoles(next);
+    setAudit((prev) => [{ at: nowISO(), type, msg }, ...prev].slice(0, 200));
+  }
+
+  async function createRole() {
+    const code = (prompt("Nh·∫≠p key role", "MANAGER") || "").trim().toUpperCase();
+    if (!code) return;
+    const scopeType = ((prompt("Scope", "GLOBAL") || "GLOBAL") as Role["scope"]);
+    const description = prompt("M√¥ t·∫£", "") || "";
+    await apiCreateRole({ code, scopeType, description });
+    pushAudit("ROLE", `T·∫°o role ${code}`);
+    await loadData();
+  }
+
+  async function editRole(key: string) {
+    const roleId = roleIdMap[key];
+    if (!roleId) return;
+    const row = roles.find((r) => r.key === key);
+    if (!row) return;
+    const description = prompt("M√¥ t·∫£", row.desc) ?? row.desc;
+    const scopeType = (prompt("Scope", row.scope) ?? row.scope) as Role["scope"];
+    await apiUpdateRole(roleId, { description, scopeType });
     pushAudit("ROLE", `S·ª≠a role ${key}`);
+    await loadData();
   }

-  function deleteRole(key: string) {
-    const systemKeys = new Set(DEFAULT_ROLES.map((r) => r.key));
-    if (systemKeys.has(key)) {
-      toast("Kh√¥ng xo√° ƒë∆∞·ª£c", "Role h·ªá th·ªëng v1 kh√¥ng cho xo√°.");
-      return;
-    }
-    if (!confirm("Xo√° role " + key + " ?")) return;
-
-    const nextRoles = roles.filter((r) => r.key !== key);
-    setRoles(nextRoles);
-    saveRoles(nextRoles);
-
-    const nextPerms = omitKey(rolePerms as Record<string, unknown>, key) as RolePermMap;
-    setRolePerms(nextPerms);
-    saveRolePerms(nextPerms);
-
-    const nextAssign = assignments.filter((a) => a.role !== key);
-    setAssignments(nextAssign);
-    saveAssignments(nextAssign);
-
-    if (activeRole === key) setActiveRole("ADMIN");
+  async function deleteRole(key: string) {
+    const roleId = roleIdMap[key];
+    if (!roleId || !confirm(`Xo√° role ${key}?`)) return;
+    await apiDeleteRole(roleId);
     pushAudit("ROLE", `Xo√° role ${key}`);
+    await loadData();
+  }
+
+  async function syncRolePerms(nextCodes: string[]) {
+    const roleId = roleIdMap[activeRole];
+    if (!roleId) return;
+    const ids = nextCodes.map((code) => permCodeToId[code]).filter(Boolean);
+    await assignPermissionsToRole(roleId, ids);
+    setRolePerms((prev) => ({ ...prev, [activeRole]: nextCodes }));
   }

-  // ===== Perm toggle =====
-  function togglePerm(permKey: string, checked: boolean) {
+  async function togglePerm(permKey: string, checked: boolean) {
     const cur = new Set(rolePerms[activeRole] ?? []);
     if (checked) cur.add(permKey);
     else cur.delete(permKey);
-
-    const next: RolePermMap = { ...rolePerms, [activeRole]: Array.from(cur) };
-    setRolePerms(next);
-    saveRolePerms(next);
-
+    const nextCodes = Array.from(cur);
+    await syncRolePerms(nextCodes);
     pushAudit("PERM", `${activeRole} ${checked ? "+" : "-"} ${permKey}`);
   }

-  function applyPresetToActive(preset: PresetKey) {
-    const p = presetMap();
-    const set = p[preset];
-    const next: RolePermMap = { ...rolePerms, [activeRole]: Array.from(set) };
-    setRolePerms(next);
-    saveRolePerms(next);
+  async function applyPresetToActive(preset: PresetKey) {
+    const set = Array.from(presetMap()[preset]);
+    await syncRolePerms(set);
     pushAudit("PERM", `√Åp preset ${preset} cho ${activeRole}`);
-    toast("√Åp preset", `${preset} ‚Üí ${activeRole}`);
   }

-  function allPerms() {
-    const next: RolePermMap = { ...rolePerms, [activeRole]: PERMS.map((x) => x.key) };
-    setRolePerms(next);
-    saveRolePerms(next);
-    pushAudit("PERM", `${activeRole} b·∫≠t ALL`);
-    toast("All permissions", "ƒê√£ b·∫≠t to√†n quy·ªÅn cho " + activeRole);
-  }
-
-  function nonePerms() {
-    const next: RolePermMap = { ...rolePerms, [activeRole]: [] };
-    setRolePerms(next);
-    saveRolePerms(next);
-    pushAudit("PERM", `${activeRole} t·∫Øt ALL`);
-    toast("Clear permissions", "ƒê√£ t·∫Øt h·∫øt quy·ªÅn cho " + activeRole);
-  }
+  async function allPerms() { await syncRolePerms(PERMS.map((x) => x.key)); }
+  async function nonePerms() { await syncRolePerms([]); }

-  // ===== Assignments =====
-  function addAssignment() {
-    const email = prompt("Nh·∫≠p email user:", "new.user@ayanavita.vn");
-    if (!email) return;
-
-    const role = prompt(
-      "Role key (USER/STAFF/BRANCH_MANAGER/LECTURER/SUPPORT/OPS/FINANCE/ADMIN):",
-      "USER"
-    );
-    if (!role) return;
-
-    if (!roles.some((r) => r.key === role)) {
-      toast("Role kh√¥ng t·ªìn t·∫°i", "H√£y t·∫°o role tr∆∞·ªõc.");
+  async function addAssignment() {
+    const email = prompt("Nh·∫≠p email user", "") || "";
+    const role = prompt("Nh·∫≠p role key", "USER") || "USER";
+    const roleId = roleIdMap[role];
+    if (!email || !roleId) return;
+    const user = assignments.find((a) => a.user === email);
+    if (!user) {
+      toast("Kh√¥ng t√¨m th·∫•y user", "H√£y t·∫°o user tr∆∞·ªõc.");
       return;
     }
-    ensureRoleKeyExists(role);
-
-    const roleScope = roles.find((r) => r.key === role)?.scope ?? "OWN";
-    const scopeType = (prompt("Scope type (OWN/BRANCH/COURSE/GLOBAL):", roleScope) ||
-      roleScope) as Assignment["scope"]["type"];
-    const scopeId =
-      scopeType === "BRANCH" || scopeType === "COURSE"
-        ? prompt("Scope id (VD branchId/courseId):", "1") || "1"
-        : null;
-
-    const unit = (prompt("Chu k·ª≥ unit (day/week/month/year):", "month") ||
-      "month") as Assignment["cadence"]["unit"];
-    const value = Number(prompt("Chu k·ª≥ value:", "1") || "1");
-    const startAt = prompt("Ng√†y b·∫Øt ƒë·∫ßu (YYYY-MM-DD):", fmtDate(new Date())) || fmtDate(new Date());
-    const expiresAt = fmtDate(addCadence(parseDate(startAt), unit, value));
-
-    const id = assignments.length ? Math.max(...assignments.map((x) => x.id)) + 1 : 1;
-    const next: Assignment = {
-      id,
-      user: email,
-      role,
-      scope: { type: scopeType, id: scopeId },
-      cadence: { unit, value },
-      startAt,
-      expiresAt,
-    };
-
-    const list = [next, ...assignments];
-    setAssignments(list);
-    saveAssignments(list);
-    pushAudit("ASSIGN", `G√°n ${role} cho ${email} (${scopeType}${scopeId ? ":" + scopeId : ""})`);
-    toast("ƒê√£ g√°n role", `${email} ‚Üí ${role} (h·∫øt h·∫°n: ${expiresAt})`);
+    await assignRoleToUser(user.id, roleId);
+    pushAudit("ASSIGN", `G√°n ${role} cho ${email}`);
+    await loadData();
   }

-  function clearAssignments() {
-    if (!confirm("Xo√° to√†n b·ªô assignments?")) return;
-    setAssignments([]);
-    saveAssignments([]);
-    pushAudit("ASSIGN", "Xo√° to√†n b·ªô assignments");
-    toast("ƒê√£ xo√°", "Assignments ƒë√£ b·ªã xo√° h·∫øt.");
+  async function deleteAssignment(id: number) {
+    await assignRoleToUser(id, roleIdMap.USER);
+    pushAudit("ASSIGN", `Reset role user #${id}`);
+    await loadData();
   }

-  function deleteAssignment(id: number) {
-    const list = assignments.filter((x) => x.id !== id);
-    setAssignments(list);
-    saveAssignments(list);
-    pushAudit("ASSIGN", "Xo√° assignment #" + id);
-  }
-
-  function renewAssignment(id: number) {
-    const a = assignments.find((x) => x.id === id);
-    if (!a) return;
-
-    const start = parseDate(a.startAt);
-    const ex = addCadence(start, a.cadence.unit, a.cadence.value);
-    const expiresAt = fmtDate(ex);
-
-    const list = assignments.map((x) => (x.id === id ? { ...x, expiresAt } : x));
-    setAssignments(list);
-    saveAssignments(list);
-
-    pushAudit("ASSIGN", `Gia h·∫°n ${a.role} cho ${a.user} ƒë·∫øn ${expiresAt}`);
-    toast("Gia h·∫°n", `${a.user} ‚Ä¢ ${a.role} ‚Üí ${expiresAt}`);
-  }
-
-  // ===== Save / Export / Import =====
-  function saveAll() {
-    saveRoles(roles);
-    saveRolePerms(rolePerms);
-    saveAssignments(assignments);
-    pushAudit("SYSTEM", "L∆∞u c·∫•u h√¨nh RBAC");
-    toast("ƒê√£ l∆∞u", "C·∫•u h√¨nh ƒë∆∞·ª£c l∆∞u localStorage.");
-    // API note: POST /admin/rbac/snapshot (roles, rolePerms, assignments)
-  }
-
-  function exportJson() {
-    const payload = {
-      version: "ayanavita-rbac-v1",
-      exportedAt: nowISO(),
-      roles,
-      rolePerms,
-      assignments,
-      modules: MODULES,
-      actions: ACTIONS,
-    };
-
-    const blob = new Blob([JSON.stringify(payload, null, 2)], {
-      type: "application/json;charset=utf-8",
-    });
-    const a = document.createElement("a");
-    a.href = URL.createObjectURL(blob);
-    a.download = "ayanavita-rbac-v1.json";
-    a.click();
-    URL.revokeObjectURL(a.href);
-    toast("Export JSON", "ƒê√£ t·∫£i c·∫•u h√¨nh RBAC.");
-  }
-
-  async function importJsonFile(file: File) {
-    try {
-      const txt = await file.text();
-      const parsed: unknown = JSON.parse(txt);
-
-      if (!isRecord(parsed)) throw new Error("invalid");
+  function renewAssignment() { toast("Info", "Assignment ƒëang ƒë·ªìng b·ªô theo role hi·ªán t·∫°i."); }
+  function clearAssignments() { toast("Info", "Kh√¥ng h·ªó tr·ª£ xo√° h√†ng lo·∫°t tr√™n API."); }
+  function saveAll() { toast("ƒê√£ l∆∞u", "M·ªçi thay ƒë·ªïi ƒë√£ ƒë·ªìng b·ªô API."); }
+  function exportJson() { toast("Info", "S·ª≠ d·ª•ng API backend ƒë·ªÉ export."); }
+  async function importJsonFile() { toast("Info", "S·ª≠ d·ª•ng API backend ƒë·ªÉ import."); }
+  function clearAudit() { setAudit([]); }

-      const nextRoles = isRoleArray(parsed.roles) ? parsed.roles : roles;
-      const nextPerms = isRolePermMap(parsed.rolePerms) ? parsed.rolePerms : rolePerms;
-      const nextAssign = isAssignmentArray(parsed.assignments) ? parsed.assignments : assignments;
-
-      setRoles(nextRoles);
-      setRolePerms(nextPerms);
-      setAssignments(nextAssign);
-
-      saveRoles(nextRoles);
-      saveRolePerms(nextPerms);
-      saveAssignments(nextAssign);
-
-      if (!nextRoles.some((r) => r.key === activeRole)) setActiveRole("ADMIN");
-
-      pushAudit("SYSTEM", "Import JSON RBAC");
-      toast("Import OK", "ƒê√£ n·∫°p c·∫•u h√¨nh t·ª´ file.");
-    } catch {
-      toast("Import l·ªói", "File JSON kh√¥ng h·ª£p l·ªá.");
-    }
-  }
-
-  function clearAudit() {
-    setAudit([]);
-    saveAudit([]);
-    toast("ƒê√£ xo√° log", "Audit log ƒë√£ ƒë∆∞·ª£c d·ªçn s·∫°ch.");
-  }
-
-  // ===== Test access =====
   function isRoleActiveForUser(email: string, roleKey: string) {
-    if (roleKey === "ADMIN") return true;
-    const today = new Date();
-    const list = assignments.filter((a) => a.user === email && a.role === roleKey);
-    if (!list.length) return false;
-    return list.some((a) => parseDate(a.expiresAt) >= today);
-  }
-
-  function can(roleKey: string, permKey: string) {
-    if (roleKey === "ADMIN") return true;
-    return new Set(rolePerms[roleKey] ?? []).has(permKey);
+    return assignments.some((a) => a.user === email && a.role === roleKey);
   }
+  function can(roleKey: string, permKey: string) { return new Set(rolePerms[roleKey] ?? []).has(permKey); }

-  function runTestAccess(params: {
-    email: string;
-    role: string;
-    module: string;
-    action: string;
-    resource: string;
-    scope: TestScope;
-  }) {
+  function runTestAccess(params: { email: string; role: string; module: string; action: string; resource: string; scope: TestScope; }) {
     const permKey = `${params.module}.${params.action}`;
     const active = isRoleActiveForUser(params.email, params.role);
     const allowed = active && can(params.role, permKey);
-
-    pushAudit(
-      "TEST",
-      `${params.email} (${params.role}) ‚Üí ${permKey} = ${allowed ? "ALLOW" : "DENY"}`
-    );
-
-    return {
-      permKey,
-      active,
-      allowed,
-      reason: !active ? "ROLE EXPIRED/NOT ASSIGNED" : allowed ? "OK" : "NO PERMISSION",
-    };
+    return { permKey, active, allowed, reason: allowed ? "OK" : "DENY" };
   }

-  // ===== UI =====
-  const checkpointText =
-    "Roles: USER, STAFF, BRANCH_MANAGER, LECTURER, SUPPORT, OPS, FINANCE, ADMIN ‚Ä¢ Role expiry theo day/week/month/year ‚Ä¢ Preset quy·ªÅn theo ƒë√∫ng b·∫£ng ƒë√£ duy·ªát.";
+  if (loading) return <div className="p-6">ƒêang t·∫£i RBAC...</div>;

   return (
     <div className="soft text-slate-900 min-h-screen">
       <RbacHeader
-        onTest={() => {
-          setTestKey((k) => k + 1);
-          setTestOpen(true);
-        }}
-        onImport={async () => {
-          const input = document.createElement("input");
-          input.type = "file";
-          input.accept = "application/json";
-          input.onchange = async () => {
-            const f = input.files?.[0];
-            if (f) await importJsonFile(f);
-          };
-          input.click();
-        }}
+        onTest={() => { setTestKey((k) => k + 1); setTestOpen(true); }}
+        onImport={async () => { await importJsonFile(); }}
         onExport={exportJson}
         onSave={saveAll}
       />
-
       <main className="px-4 md:px-8 py-6 space-y-6">
-        <section className="card p-6">
-          <div className="flex items-start justify-between gap-4 flex-col md:flex-row">
-            <div>
-              <div className="text-xs font-extrabold text-slate-500">Checkpoint</div>
-              <div className="text-lg font-extrabold">ƒê√£ ch·ªët b·∫£ng role v1</div>
-              <div className="mt-1 text-sm text-slate-600">{checkpointText}</div>
-            </div>
-            <div className="flex items-center gap-2">
-              <span className="chip">
-                <i className="fa-solid fa-shield-halved text-indigo-600 mr-1" />
-                RBAC
-              </span>
-              <span className="chip">
-                <i className="fa-solid fa-clock text-amber-600 mr-1" />
-                Expiry
-              </span>
-              <span className="chip">
-                <i className="fa-solid fa-scroll text-emerald-600 mr-1" />
-                Audit
-              </span>
-            </div>
-          </div>
-        </section>
-
         <section className="grid gap-4 lg:grid-cols-3">
-          <RolesPanel
-            roles={visibleRoles}
-            activeRole={activeRole}
-            onSelectRole={(k) => setActiveRole(k)}
-            search={roleSearch}
-            onSearch={setRoleSearch}
-            onNewRole={createRole}
-            onEditRole={editRole}
-            onDeleteRole={deleteRole}
-            onJumpRole={(k) => setActiveRole(k)}
-          />
-
-          <PermissionsMatrix
-            activeRole={activeRole}
-            moduleFilter={moduleFilter}
-            onChangeModuleFilter={setModuleFilter}
-            presetSelectOptions={[
-              { value: "KEEP", label: "Preset: (kh√¥ng ƒë·ªïi)" },
-              { value: "STRICT", label: "Preset: Nghi√™m ng·∫∑t" },
-              { value: "USER", label: "Preset: USER" },
-              { value: "STAFF", label: "Preset: STAFF" },
-              { value: "BRANCH_MANAGER", label: "Preset: BRANCH_MANAGER" },
-              { value: "LECTURER", label: "Preset: LECTURER" },
-              { value: "SUPPORT", label: "Preset: SUPPORT" },
-              { value: "OPS", label: "Preset: OPS" },
-              { value: "FINANCE", label: "Preset: FINANCE" },
-              { value: "ADMIN", label: "Preset: ADMIN" },
-            ]}
-            onApplyPreset={(v) => {
-              if (v === "KEEP") return;
-              applyPresetToActive(v as PresetKey);
-            }}
-            onAll={allPerms}
-            onNone={nonePerms}
-            perms={filteredPerms}
-            activePermSet={activePermSet}
-            onTogglePerm={togglePerm}
-            roles={roles}
-          />
+          <RolesPanel roles={visibleRoles} activeRole={activeRole} onSelectRole={setActiveRole} search={roleSearch} onSearch={setRoleSearch} onNewRole={createRole} onEditRole={editRole} onDeleteRole={deleteRole} onJumpRole={setActiveRole} />
+          <PermissionsMatrix activeRole={activeRole} moduleFilter={moduleFilter} onChangeModuleFilter={setModuleFilter} presetSelectOptions={[{ value: "KEEP", label: "Preset: (kh√¥ng ƒë·ªïi)" }, { value: "STRICT", label: "Preset: Nghi√™m ng·∫∑t" }, { value: "USER", label: "Preset: USER" }, { value: "STAFF", label: "Preset: STAFF" }, { value: "BRANCH_MANAGER", label: "Preset: BRANCH_MANAGER" }, { value: "LECTURER", label: "Preset: LECTURER" }, { value: "SUPPORT", label: "Preset: SUPPORT" }, { value: "OPS", label: "Preset: OPS" }, { value: "FINANCE", label: "Preset: FINANCE" }, { value: "ADMIN", label: "Preset: ADMIN" }]} onApplyPreset={(v) => { if (v !== "KEEP") void applyPresetToActive(v as PresetKey); }} onAll={() => void allPerms()} onNone={() => void nonePerms()} perms={filteredPerms} activePermSet={activePermSet} onTogglePerm={(k, c) => void togglePerm(k, c)} roles={roles} />
         </section>
-
         <section className="grid gap-4 lg:grid-cols-3">
-          <AssignmentsPanel
-            assignments={assignments}
-            onAdd={addAssignment}
-            onClear={clearAssignments}
-            onRenew={renewAssignment}
-            onDelete={deleteAssignment}
-          />
+          <AssignmentsPanel assignments={assignments} onAdd={() => void addAssignment()} onClear={clearAssignments} onRenew={renewAssignment} onDelete={(id) => void deleteAssignment(id)} />
           <AuditPanel audit={audit} onClear={clearAudit} />
         </section>
-
-        <footer className="py-6 text-center text-sm text-slate-500">
-          ¬© 2025 AYANAVITA ‚Ä¢ RBAC v1 (React)
-        </footer>
       </main>
-
-      <TestAccessDrawer
-        key={testKey}
-        open={testOpen}
-        onClose={() => setTestOpen(false)}
-        roles={roles}
-        modules={MODULES}
-        actions={ACTIONS}
-        onRun={(input) => runTestAccess(input)}
-      />
+      <TestAccessDrawer key={testKey} open={testOpen} onClose={() => setTestOpen(false)} roles={roles} modules={[...MODULES]} actions={[...ACTIONS]} onRun={(input) => runTestAccess(input)} />
     </div>
   );
-}
\ No newline at end of file
+}
