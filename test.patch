diff --git a/ayanavita-fontend/src/api/enrollments.api.ts b/ayanavita-fontend/src/api/enrollments.api.ts
index 042ca04828d9592b82dc97304af643b7b0946559..47d1a67453f8ac6a611a0cb0c6236388e1b06157 100644
--- a/ayanavita-fontend/src/api/enrollments.api.ts
+++ b/ayanavita-fontend/src/api/enrollments.api.ts
@@ -1,43 +1,44 @@
 // src/api/enrollments.api.ts
 import { get, post } from "./http";

 export type EnrollmentStatus = "ACTIVE" | "CANCELLED" | "PENDING";

 export type MyCourse = {
   id: number; // enrollment id
   courseId: number;
   status: EnrollmentStatus;
   course: {
     id: number;
     title: string;
     thumbnail: string | null;
     price: number;
   };
 };

 export const enrollmentsApi = {
   /**
    * GET /me/courses
    * Trả danh sách khóa học user đã enroll (kèm status).
    */
-  myCourses() {
-    return get<MyCourse[]>("/me/courses", { auth: true });
+  myCourses(lang?: string) {
+    const query = lang ? `?lang=${encodeURIComponent(lang)}` : "";
+    return get<MyCourse[]>(`/me/courses${query}`, { auth: true });
   },

   /**
    * POST /courses/:id/cancel
    * Hủy enrollment (thường chuyển CANCELLED).
    */
   cancel(courseId: number) {
     return post<{ ok: boolean }>(`/courses/${courseId}/cancel`, {}, { auth: true });
   },

   /**
    * POST /courses/:id/order
    * Nếu backend của bạn endpoint này tạo order, nên ưu tiên gọi ordersApi.create(courseId)
    * để lấy đủ thông tin order (id, code, totals...). Hàm này giữ lại để backward-compatible.
    */
   order(courseId: number) {
     return post<{ ok: boolean }>(`/courses/${courseId}/order`, {}, { auth: true });
   },
 };
diff --git a/ayanavita-fontend/src/pages/MyCoursesPage.tsx b/ayanavita-fontend/src/pages/MyCoursesPage.tsx
index c744c06e73e25c2a81f5ddd71315e9f11f04ffb7..0368c95c5fcaab136d6cdcbcabd449c4975e8735 100644
--- a/ayanavita-fontend/src/pages/MyCoursesPage.tsx
+++ b/ayanavita-fontend/src/pages/MyCoursesPage.tsx
@@ -82,71 +82,71 @@ function ProgressBar({ percent, label }: { percent: number; label: string }) {
           <span className="student-progress-value">{p.toFixed(0)}%</span>
         </div>
         <div className="student-progress-track">
           <div className="student-progress-fill" style={{ width: `${p}%` }} />
         </div>
       </div>
   );
 }

 export function MyCoursesPage() {
   const nav = useNavigate();
   const { lang, setLang, theme, setTheme } = useStudentViewPrefs();
   const t = i18n[lang];

   const [items, setItems] = useState<MyCourse[]>([]);
   const [loading, setLoading] = useState(true);
   const [err, setErr] = useState<string | null>(null);
   const [info, setInfo] = useState<string | null>(null);
   const [progressMap, setProgressMap] = useState<Record<number, CourseProgressRes>>({});

   async function load() {
     setLoading(true);
     setErr(null);
     setInfo(null);
     try {
-      const data = await enrollmentsApi.myCourses();
+      const data = await enrollmentsApi.myCourses(lang);
       setItems(data);

       const activeCourseIds = data.filter((d) => d.status === "ACTIVE").map((d) => d.courseId);
       const results = await Promise.allSettled(
           activeCourseIds.map(async (cid) => ({ cid, p: await progressApi.courseProgress(cid) }))
       );

       const next: Record<number, CourseProgressRes> = {};
       for (const r of results) if (r.status === "fulfilled") next[r.value.cid] = r.value.p;
       setProgressMap(next);
     } catch (e: any) {
       setErr(e?.message || "Load my courses failed");
     } finally {
       setLoading(false);
     }
   }

   useEffect(() => {
     load();
-  }, []);
+  }, [lang]);

   async function onCancel(courseId: number) {
     setErr(null);
     setInfo(null);
     try {
       await enrollmentsApi.cancel(courseId);
       setInfo(`Course #${courseId} cancelled.`);
       await load();
     } catch (e: any) {
       setErr(e?.message || "Cancel failed");
     }
   }

   async function onContinue(courseId: number) {
     setErr(null);
     setInfo(null);
     try {
       const lessons = await coursesApi.lessons(courseId);
       if (!lessons || lessons.length === 0) {
         setInfo("Course has no lesson yet.");
         return;
       }

       const lessonId = sortLessons(lessons)[0]?.id;
       if (!lessonId) return;
@@ -221,42 +221,50 @@ export function MyCoursesPage() {
                       <span className="student-meta-label">{t.price}:</span>
                       <span className="student-meta-value">
                     {enr.course.price.toLocaleString("vi-VN")}đ
                   </span>
                     </div>

                     {enr.status === "ACTIVE" && prog && (
                         <>
                           <ProgressBar percent={percent} label={t.progress} />
                           <div className="student-mini">
                             {t.completed}: {prog.completedLessons}/{prog.totalLessons}
                           </div>
                         </>
                     )}

                     <div className="student-card-actions">
                       <button
                           type="button"
                           className="student-btn student-btn-primary"
                           onClick={() => onContinue(enr.courseId)}
                           disabled={enr.status !== "ACTIVE"}
                       >
                         {t.continue}
                       </button>

+                      <button
+                          type="button"
+                          className="student-btn student-btn-ghost"
+                          onClick={() => nav(`/courses/${enr.courseId}`)}
+                      >
+                        {t.detail}
+                      </button>
+
                       <button
                           type="button"
                           className="student-btn student-btn-danger"
                           onClick={() => onCancel(enr.courseId)}
                           disabled={enr.status !== "ACTIVE" && enr.status !== "PENDING"}
                       >
                         {t.cancel}
                       </button>
                     </div>
                   </div>
               );
             })}
           </div>
         </div>
       </div>
   );
 }
\ No newline at end of file
diff --git a/backend/ayanavitabackend/app/api/src/enrollments/enrollments.controller.ts b/backend/ayanavitabackend/app/api/src/enrollments/enrollments.controller.ts
index 5e0172abcf59544ae0749a9e0e95252a151b50ac..2bceb1f55681c26cf9a5dcdf03d101f5e864c725 100644
--- a/backend/ayanavitabackend/app/api/src/enrollments/enrollments.controller.ts
+++ b/backend/ayanavitabackend/app/api/src/enrollments/enrollments.controller.ts
@@ -1,42 +1,42 @@
 import { Controller, Get, Param, ParseIntPipe, Post, Query, UseGuards } from '@nestjs/common'
 import { AccessTokenGuard } from '../auth/guards/access-token.guard'
 import { CurrentUser, JwtUser } from '../auth/decorators/current-user.decorator'
 import { EnrollmentsService } from './enrollments.service'
 import { CourseAccessStatus } from '@prisma/client'

 @UseGuards(AccessTokenGuard)
 @Controller()
 export class EnrollmentsController {
   constructor(private readonly enrollments: EnrollmentsService) {}

   /**
    * Danh sách khóa học đã mua + progress
    */
   @Get('me/courses')
-  myCourses(@CurrentUser() user: JwtUser) {
-    return this.enrollments.myCoursesWithProgress(user)
+  myCourses(@CurrentUser() user: JwtUser, @Query('lang') lang?: string) {
+    return this.enrollments.myCoursesWithProgress(user, lang)
   }
   // route mới: GET /me/enrollments?status=ACTIVE|CANCELED|ALL
   @Get('me/enrollments')
   myEnrollments(
     @CurrentUser() user: JwtUser,
     @Query('status') status?: 'ACTIVE' | 'CANCELED' | 'ALL',
   ) {
     // default ACTIVE nếu không truyền
     const normalized = (status ?? 'ACTIVE').toUpperCase() as 'ACTIVE' | 'CANCELED' | 'ALL'

     if (!['ACTIVE', 'CANCELED', 'ALL'].includes(normalized)) {
       // tránh 400 quá phức tạp, trả về mặc định ACTIVE
       return this.enrollments.myEnrollments(user.sub, CourseAccessStatus.ACTIVE)
     }

     if (normalized === 'ALL') return this.enrollments.myEnrollments(user.sub, 'ALL')
     return this.enrollments.myEnrollments(user.sub, normalized as CourseAccessStatus)
   }


   /**
    * Hủy enrollment (soft cancel)
    */
   @Post('courses/:id/cancel')
   cancel(
diff --git a/backend/ayanavitabackend/app/api/src/enrollments/enrollments.service.ts b/backend/ayanavitabackend/app/api/src/enrollments/enrollments.service.ts
index d8cf90995483dc766228bd6983604eb6f0694a31..1490686b854c28374cd11bb7a9787d2f1a95d4d1 100644
--- a/backend/ayanavitabackend/app/api/src/enrollments/enrollments.service.ts
+++ b/backend/ayanavitabackend/app/api/src/enrollments/enrollments.service.ts
@@ -1,153 +1,180 @@
 import { ForbiddenException, Injectable, NotFoundException } from '@nestjs/common'
 import { CourseAccessStatus, Prisma, Role } from '@prisma/client'
 import { PrismaService } from '../prisma/prisma.service'

 type JwtUser = { sub: number; role: Role | string }

 @Injectable()
 export class EnrollmentsService {
   constructor(private readonly prisma: PrismaService) {}

+  private resolveLocale(lang?: string) {
+    const normalized = (lang || 'vi').toLowerCase()
+    if (normalized === 'en' || normalized === 'de') return normalized
+    return 'vi'
+  }
+
   async myEnrollments(userId: number, status?: CourseAccessStatus | 'ALL') {
     const where: Prisma.CourseAccessWhereInput = {
       userId,
       ...(status && status !== 'ALL' ? { status } : {}),
     }

     return this.prisma.courseAccess.findMany({
       where,
       select: {
         id: true,
         userId: true,
         courseId: true,
         status: true,
         grantedAt: true,
         createdAt: true,
         updatedAt: true,
         course: {
           select: {
             id: true,
             title: true,
             slug: true,
             description: true,
             thumbnail: true,
             price: true,
             published: true,
             _count: { select: { lessons: true } },
           },
         },
       },
       orderBy: [{ updatedAt: 'desc' }, { id: 'desc' }],
     })
   }

   async grantAccess(userId: number, courseId: number) {
     const course = await this.prisma.course.findUnique({ where: { id: courseId }, select: { id: true } })
     if (!course) throw new NotFoundException('Course not found')

     return this.prisma.courseAccess.upsert({
       where: { userId_courseId: { userId, courseId } },
       update: { status: CourseAccessStatus.ACTIVE, grantedAt: new Date() },
       create: { userId, courseId, status: CourseAccessStatus.ACTIVE },
       select: { id: true, userId: true, courseId: true, status: true, grantedAt: true, updatedAt: true },
     })
   }

-  myCourses(userId: number) {
+  myCourses(userId: number, lang?: string) {
+    const locale = this.resolveLocale(lang)
+
     return this.prisma.courseAccess.findMany({
       where: { userId, status: CourseAccessStatus.ACTIVE },
       select: {
         id: true,
         courseId: true,
         status: true,
         grantedAt: true,
         course: {
           select: {
             id: true,
             title: true,
+            translations: {
+              where: { locale: { in: [locale, 'vi'] } },
+              select: {
+                locale: true,
+                title: true,
+                description: true,
+              },
+            },
             slug: true,
             description: true,
             thumbnail: true,
             price: true,
             published: true,
             createdAt: true,
             updatedAt: true,
             _count: { select: { lessons: true } },
           },
         },
       },
       orderBy: { grantedAt: 'desc' },
     })
   }

-  async myCoursesWithProgress(user: JwtUser) {
+  async myCoursesWithProgress(user: JwtUser, lang?: string) {
     const userId = user.sub
     const isAdmin = user.role === 'ADMIN'
-    const accesses = await this.myCourses(userId)
+    const locale = this.resolveLocale(lang)
+    const accesses = await this.myCourses(userId, locale)

     if (accesses.length === 0) return []

     const completed = await this.prisma.lessonProgress.findMany({
       where: {
         userId,
         status: 'COMPLETED',
         ...(isAdmin ? {} : { lesson: { published: true } }),
       },
       select: {
         lesson: { select: { courseId: true } },
       },
     })

     const completedCountByCourse = new Map<number, number>()
     for (const x of completed) {
       const courseId = x.lesson.courseId
       completedCountByCourse.set(courseId, (completedCountByCourse.get(courseId) || 0) + 1)
     }

     const courseIds = accesses.map((e) => e.course.id)
     const totals = await this.prisma.lesson.groupBy({
       by: ['courseId'],
       where: {
         courseId: { in: courseIds },
         ...(isAdmin ? {} : { published: true }),
       },
       _count: { _all: true },
     })
     const totalByCourse = new Map<number, number>(totals.map((t) => [t.courseId, t._count._all]))

     return accesses.map((e) => {
       const totalLessons = totalByCourse.get(e.course.id) || 0
       const completedLessons = completedCountByCourse.get(e.course.id) || 0
       const percent = totalLessons === 0 ? 0 : Math.round((completedLessons / totalLessons) * 100)

       return {
         id: e.id,
         courseId: e.courseId,
         status: e.status,
         grantedAt: e.grantedAt,
-        course: e.course,
+        course: {
+          ...e.course,
+          title:
+            (e.course as any).translations?.find((item: any) => item.locale === locale)?.title ||
+            (e.course as any).translations?.find((item: any) => item.locale === 'vi')?.title ||
+            e.course.title,
+          description:
+            (e.course as any).translations?.find((item: any) => item.locale === locale)?.description ||
+            (e.course as any).translations?.find((item: any) => item.locale === 'vi')?.description ||
+            e.course.description,
+        },
         progress: { totalLessons, completedLessons, percent },
       }
     })
   }

   async cancel(userId: number, courseId: number) {
     const access = await this.prisma.courseAccess.findUnique({
       where: { userId_courseId: { userId, courseId } },
       select: { id: true, status: true },
     })
     if (!access) throw new NotFoundException('Course access not found')

     return this.prisma.courseAccess.update({
       where: { userId_courseId: { userId, courseId } },
       data: { status: CourseAccessStatus.CANCELED },
       select: { id: true, status: true, updatedAt: true },
     })
   }

   async assertEnrolledOrAdmin(user: JwtUser, courseId: number) {
     if (user.role === 'ADMIN') return

     const e = await this.prisma.courseAccess.findUnique({
       where: { userId_courseId: { userId: user.sub, courseId } },
       select: { status: true },
diff --git a/backend/ayanavitabackend/app/api/src/progress/progress.service.ts b/backend/ayanavitabackend/app/api/src/progress/progress.service.ts
index 050bcb98e4dff7cd0fcbf540ab01a2546f42a00c..3bb418900d2535ec163c4f99bdf1ee4463d692d9 100644
--- a/backend/ayanavitabackend/app/api/src/progress/progress.service.ts
+++ b/backend/ayanavitabackend/app/api/src/progress/progress.service.ts
@@ -56,52 +56,56 @@ export class ProgressService {

     if (prevProgress?.status !== ProgressStatus.COMPLETED) {
       throw new ForbiddenException('Lesson locked')
     }
   }

   private async recalculateLessonProgress(userId: number, lessonId: number) {
     const lessonVideos = await this.prisma.lessonVideo.findMany({
       where: { module: { lessonId, published: true }, published: true, mediaType: 'VIDEO' },
       select: { id: true, durationSec: true },
     })
     const totalDurationSec = lessonVideos.reduce((sum, item) => sum + Math.max(0, item.durationSec || 0), 0)

     const videoProgress = await this.prisma.lessonVideoProgress.findMany({
       where: { userId, lessonId },
       select: { videoId: true, watchedSec: true, completed: true },
     })

     const progressMap = new Map(videoProgress.map((item) => [item.videoId, item]))
     const watchedDurationSec = lessonVideos.reduce((sum, video) => {
       const row = progressMap.get(video.id)
       const capped = Math.min(video.durationSec || 0, Math.max(0, row?.watchedSec || 0))
       return sum + capped
     }, 0)

-    const percent = totalDurationSec <= 0 ? 0 : Math.min(100, Math.round((watchedDurationSec / totalDurationSec) * 100))
-    const isCompleted = totalDurationSec > 0 && percent >= 100
+    const completedVideos = lessonVideos.filter((video) => progressMap.get(video.id)?.completed).length
+    const percentByDuration = totalDurationSec <= 0 ? 0 : Math.min(100, Math.round((watchedDurationSec / totalDurationSec) * 100))
+    const percentByCompletion = lessonVideos.length === 0 ? 0 : Math.min(100, Math.round((completedVideos / lessonVideos.length) * 100))
+
+    const percent = totalDurationSec > 0 ? percentByDuration : percentByCompletion
+    const isCompleted = lessonVideos.length > 0 && percent >= 100

     const lessonProgress = await this.prisma.lessonProgress.upsert({
       where: { userId_lessonId: { userId, lessonId } },
       create: {
         userId,
         lessonId,
         status: isCompleted ? ProgressStatus.COMPLETED : ProgressStatus.IN_PROGRESS,
         percent,
         lastPositionSec: watchedDurationSec,
         lastOpenedAt: new Date(),
         completedAt: isCompleted ? new Date() : null,
       },
       update: {
         status: isCompleted ? ProgressStatus.COMPLETED : ProgressStatus.IN_PROGRESS,
         percent,
         lastPositionSec: watchedDurationSec,
         lastOpenedAt: new Date(),
         completedAt: isCompleted ? new Date() : null,
       },
       select: {
         lessonId: true,
         status: true,
         percent: true,
         lastPositionSec: true,
         lastOpenedAt: true,
